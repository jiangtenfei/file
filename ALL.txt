	ppt宝藏官网


 

服务器：机架式服务器最多，以厚度表示大小，1U＝4.445cm

CPU：Intel Xeon(至强)

内存：ECC纠错技术

硬盘：转速10000RPM/15000RPM

服务器一般托管到IDC（Inernet Data Center）

上网采用的结构：C/S(Client/Server)、B/S(Browser/Server)

协议：语言  TCP/IP

地址：ip地址（ipv4/ipv6），ipv6可以给地球上每一粒沙子分配一个IP地址

ARPAnet：DoD（美国国防部）出资创办了高级研究项目署，即ARPA，它把当时美国三所大学的4台计算机连接起来。

一台网络设备，如果联网需要配置的网络参数有：

ip地址：32位的2进制数。因为这么长的2进制数对于人来说，非学点不友好，为了方便人为记忆、表示，每8位转换成一个10进制数，再把4个数字之间用小数点分隔。称作点分10进制的表示方式。

  子网掩码：可以区分ip地址的网络部分和主机部分。2进制数模式下，将网络部分全部写为1，主机部分全部写为0

  缺省网关：路由器连接局域网端口的IP地址
DNS服务器地址：网络查号台。它可以将好记的名字与不好记的IP地址进行匹配、解析。

电话号码：区号＋座机号码
 
 IP地址：网络部分＋主机部分
同一城市，区号相同，座机号不同；不同城市，区号不同，座机号可以相同。相同网络，网络部分相同，主机部分不同；不同网络，网络部分不同，主机部分可以相同。

 采用交换机连接的网络是同一网络。路由器分开不同网络。

主机间通信：

1、PC1（192.168.1.10）与PC2（192.168.2.10）通信，PC1先查看目标与自己是不是同一网络
2、如果是同一网络，直接发送
3、如果不是同一网络，发给路由器（网关）

11000000 10101000 00000001 00001010
11111111 11111111 11111111 00000000
192      168      1        10
任何0－255间的数字都可以表示成8个0和1的组合。

00000000 -> 0
00000001 -> 1
00000010 -> 2
00000011 -> 3
11111111 -> 255

IP地址分类：
A：前8位作为网络位，第1位必须是0
B：前16位作为网络位，前2位必须是10
C：前24位作为网络位，前3位必须是110
D：前4位必须是1110，用于多播（组播）
E：前5位必须是11110，保留用于互联网研究

单播：一对一
多播（组播）：一对部分
广播：一对全部

Windows修改主机名：桌面计算机上右击－>属性->高级系统设置->计算机名->更改

Windows配置网络参数：桌面网络上右击->属性->更改适配器设置->在本地连接上右击->属性->TCP/IP->属性

Windows查看主机IP地址：开始->运行->cmd->ipconfig/all
测试网络连通性：ping命令
ping  127.0.0.1   测试自己的TCP／IP协议是否正常
127.0.0.1是本地环回地址，表示“我自己”的意思
ping  网关地址    测试局域网通信是否正常
Ping   远程主机    测试外网通信


1，windows ：虚拟化软件 VMware
2，linux ： 虚拟化软件 KVM
222222222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222




Cisco公司模拟器

网络参数：IP地址、子网掩码、网关、DNS服务器

IP地址：32位2进制数，分成网络部分和主机部分。同一网络（交换机连接），网络部分相同，主机部分不同；不同网络（路由器分隔）网络部分不同，主机部分可以相同。

A：前8位网络位，第1位是0                  255.0.0.0         1-127
B：前16位网络位，前2位是10                255.255.0.0       128-191
C：前24位网络位，前3位是110               255.255.255.0    192-223
D：前4位是1110，用于多播                   255.255.255.0    224-239
E：前5位是11110，保留                      255.255.255.0    240-255

背，学历不等于能力，学过不等于掌握。

子网掩码：32位2进制数，可以区分IP地址的网络位和主机位。网络位全置1，主机位全置0。

网关：路由器连接局域网的接口IP地址。

DNS服务器：用于域名解析

自由软件、开源软件(Free)

微软：PC领袖

虚拟机：KVM虚拟机

物理主机：CPU／MEMORY／HDD／DVD－ROM

安装RHEL7系统
1、在虚拟系统管理器中点击新建按钮
2、选择“本地安装介质”
3、ISO镜像位置，“浏览“->右下角“本地浏览”－>左下角“计算机”->右窗格，双击ISO目录，选择rhel-server-7.4-x86_64-dvd.iso
4、内存用2048M，CPU选择1颗
5、硬盘大小，写50G
6、名称填写“myrhel7“

GUI：Graphical  User  Interface图形用户界面
CLI：Command  Line  Interface命令行界面

Windows分区：

C盘只安装系统，D盘只安装程序，E盘保存常用文件，F盘保存不常用文件
Linux为分区起名，不采用CDEF这样的称呼，叫什么自己决定。
Linux有一些默认的名字，比如可执行文件目录叫bin或sbin，为用户准备的目录叫home，为那些经常有变动的目录起名为var，为临时文件夹起名为tmp

Linux认为一切皆文件，硬件设备也是文件，存放在/dev目录下
磁盘文件的命名：如果是物理磁盘，起名为sd，如果是虚拟盘，起名为vd。一台主机上可以有多块磁盘（U盘），采用abcdef字母来表示第几块盘。磁盘上的分区用12345这样的数字表示。

如果要访问分区，先要把分区和一个目录映射起来，叫做挂载。

磁盘分区结束后，还需要格式化。格式化可以选择ext4/xfs。Ext文件系统适合小文件，XFS适合大文件。

Linux默认管理员是root，其他用户都是普通用户。

RHEL7图形界面设置
1、点击屏幕右上角，再点击出现的左下角的“扳手”图标，常用设置包括“隐私”、“电源”、区域和语言
2、工作区：多个窗口的分类，按ctrl+alt+上下箭头

RHEL7命令行界面：

1、RHEL7默认打开了6个终端。按ctrl+alt+Fn（F1－F6）切换

2、在图形界面下还可以打开伪终端：桌面上右击，选择“打开终端”

3、伪终端字体大小快捷键是ctrl + +/ ctrl + -

4、命令提示符的含义：
[root@localhost ~]# 
[用户名@主机名 当前工作路径]用户提示符；如果是root，用户提示符是#，如果是非root用户，用户提示符是$

5、显示当前用户
[root@localhost ~]# whoami
root
[root@localhost ~]# w<tab><tab>  显示所有以w开头的命令

6、显示主机名
[root@localhost ~]# hostname
localhost.localdomain
[root@localhost ~]# hostname  -s
localhost

7、说明：命令、选项、路径等在linux下都区分大小写。命令、选项、参数之间必须有空格

8、显示当前工作目录
[root@localhost ~]# pwd
/root

9、切换用户
[root@localhost ~]#  su  zzg
[zzg@localhost root]$ 

10、列出文件或目录：ls
[root@localhost ~]# ls  /tmp
黑色字体表示单个文件，目录用蓝字表示，绿字表示有执行权限

11、在/tmp目录下创建demo
[root@localhost ~]# mkdir  /tmp/demo
在/tmp/demo下创建abc和xyz
[root@localhost ~]# mkdir  /tmp/demo/abc  /tmp/demo/xyz

12、切换工作目录：cd
(1)只要输入cd就会进入自己的家目录。root的家目录是/root。家目录就是该用户拥有绝对权限的目录，可以删除、写入等。zhangsan的家目录是/home/zhangsan，lisi的家目录是/home/lisi
[root@localhost /]# cd
（2）切换到/tmp/demo/abc
[zzg@localhost ~]$ cd  /tmp/demo/abc/
[zzg@localhost abc]$ pwd
/tmp/demo/abc
(3)切换到上一级目录。  ..表示父目录
[root@localhost abc]# cd  ..
[root@localhost demo]# pwd
/tmp/demo
（4）切换到当前目录下的xyz中
[root@localhost demo]# cd  xyz
（5）绝对路径：以/开头的路径，如/tmp/demo/abc
（6）相对路径：相对某一位置的路径，如xyz，表示相对当前路径的目录xyz
（7）以相对路径切换到/home下
[root@localhost xyz]# pwd
/tmp/demo/xyz
[root@localhost xyz]# cd  ../../../home
[root@localhost home]# pwd
/home
（8）一个英文句点 . 表示当前路径
[root@localhost home]# cd  /tmp/demo/
[root@localhost demo]# cd  ./abc/
[root@localhost abc]# cp  /etc/hosts  .   ->拷贝/etc/hosts到当前目录

13、查看/tmp/demo/abc下详细信息
[root@localhost abc]# ls  -l  /tmp/demo/abc/

14、以KMG显示文件大小，而不是字节
[root@localhost abc]# ls  -l  -h  /root/  或
[root@localhost abc]# ls  -lh  /root/
15、ls  -l因为非常常用，所以为其指定了别名，叫ll

16、查看内核版本号
[root@localhost abc]# uname  -r

17、查看操作系统的版本号
[root@localhost abc]# cat  /etc/redhat-release 
Red Hat Enterprise Linux Server release 7.4 (Maipo)

18、查看ls的帮助
[root@localhost abc]# ls  --help

19、命令格式
命令  [选项]...   [参数]...
[ ]表示可选项， ...表示可以有多个
选项有短格式和长格式，如ls  -a和ls  --all都是显示所有文件。

20、查看CPU
[root@room8pc16 ~]# lscpu 

21、查看内存信息
[root@room8pc16 ~]# cat  /proc/meminfo   或
[root@room8pc16 ~]# free  -m  以多少兆来显示大小

22、查看网卡信息
[root@room8pc16 ~]# ifconfig 
lo ->loopback，本地环回，127.0.0.1
enp2s0：物理网卡以en开头，表示以太网
ethX：传统命名方式（RHEL7之前的命名方式）

23、关机
[root@localhost abc]# shutdown  -h  now

24、重起
[root@localhost abc]# reboot 或
[root@localhost abc]# shutdown  -r  now

25、远程管理服务器：以root身份登陆172.40.50.116
[root@room8pc16 ~]# ssh  root@172.40.50.116

26、创建空文件
[root@localhost abc]# touch abc.txt
[root@localhost abc]# ls
abc.txt  hosts

27、在终端屏幕上显示文件内容
[root@localhost abc]# cat  /etc/passwd
[root@localhost abc]# cat  -n  /etc/passwd

28、分屏显示文件内容
[root@room8pc16 ~]# more  /etc/passwd
按回车向下逐行翻，按空格逐屏向下翻。按q退出。输入/nologin用于搜索nologin，按n向下继续搜索，按N向上继续搜索。
[root@room8pc16 ~]# less  /etc/passwd  
less与more类似，但是还可以按Home/End/PageUp/PageDown

29、head/tail默认查看文件头部/尾部10行，也可以自行指定
[root@room8pc16 ~]# head  /etc/passwd
[root@room8pc16 ~]# tail  /etc/passwd
[root@room8pc16 ~]# head  -3  /etc/passwd
[root@room8pc16 ~]# tail  -2  /etc/passwd

30、查看包含adm的行
[root@room8pc16 ~]# grep  adm  /etc/passwd






ftp://172.205.5.158/centos.tar.gz




















#########################################################
333333333333333333333333333333333333333333333333333333333
3333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333




牛犇
#########################################

命令行基础

Linux命令
– 用来实现某一类功能的指令或程序
– Linux中的命令会有一个执行程序与之相对应

– 命令的执行依赖于解释器(默认的解释器：/bin/bash)

       用户-------->解释器------->内核----->调配所有的硬件

########################################################

• 基本用法
– 命令字     [选项]...      [参数1]     [参数2]...
   

[root@server0 ~]# ls  -l  /root/


Ctrl + c :结束正在运行的命令

快速编辑技巧
• Tab键自动补全
– 可补齐命令字、选项、参数、文件路径、软件名、服务名

	# if 连续按两次tab键
	# ifco（tab）
	
	# cat  /et(tab)/red(tab)-r(tab)

	# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

	# cat /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)


• 快捷键
– Ctrl + l :清空整个屏幕
– Esc + . 或 Alt  + . :粘贴上一个命令的参数
– Ctrl + c :结束正在运行的命令
[root@haha ~]# ls /etc/redhat-release 

[root@haha ~]# ls -l  Alt  +  . 

[root@haha ~]# cat   Alt  +  . 

[root@haha ~]# ls -l /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

[root@haha ~]# cat   Alt  +  . 

[root@haha ~]# ping 127.0.0.1
 按Ctrl + c 


– Ctrl + u : 清空至行首

– Ctrl + w : 往回删除一个单词(以空格界定)


######################################################
mount挂载操作:提供设备资源访问点

显示光盘内容

Windows

  光盘文件-------->光驱设备--------->CD驱动器(访问点)


Linux

  光盘文件-------->光驱设备---------->目录(访问点)
             IDE:/dev/hdc
             SCSI:/dev/sr0


     煤矿------>洞口

1.图形方式将光盘文件，放入虚拟机光驱设备

2.Linux光驱设备

蓝色：目录
黑色：文本文件
青色：快捷方式
[root@haha ~]# ls  /dev/cdrom 
[root@haha ~]# ls  -l  /dev/cdrom

3.访问光盘设备内容
• 使用mount命令
– 格式:mount  设备路径   挂载点目录

[root@haha ~]# mkdir /nsd       #创建访问点目录
[root@haha ~]# ls /
[root@haha ~]# ls /nsd

[root@haha ~]# mount  /dev/cdrom  /nsd   #进行挂载,让nsd成为访问点
mount: /dev/sr0 写保护，将以只读方式挂载

[root@haha ~]# ls /nsd/

[root@haha ~]# ls /nsd/Packages/    #查看光盘中的所有软件包

4.卸载
[root@haha ~]#  umount  /nsd
[root@haha ~]#  ls /nsd


注意：
 1.当有人正在访问挂载点
[root@haha nsd]# umount /nsd
  umount: /nsd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)

 2.挂载时，尽量使用自己创建的目录

#######################################################
• cd — Change Directory
– 用途:切换工作目录
– 格式:cd   [目标文件夹位置]

  cd  ..  :返回上一层

    绝对路径：以/开始的路径
    相对路径：不以/开始的路径

     ~:用户家目录

   ~user表示用户user的家目录

   /root : 管理员root用户的家目录
   /home : 存放所有普通用户家目录

[root@haha ~]# useradd zhangsan    #创建普通用户为zhangsan
[root@haha ~]# useradd dc          #创建普通用户为lisi

[root@haha ~]# cd  ~zhangsan
[root@haha zhangsan]# pwd   #查看当前目录的绝对路径

[root@haha zhangsan]# cd  ~dc
[root@haha dc]# pwd

[root@haha ~]# cd   ~root
[root@haha ~]# pwd

########################################################

• ls — List
– 格式:ls [选项]... [目录或文件名]

• 常用命令选项
– -l :以长格式显示,显示详细属性
– -h:提供易读的容量单位(K、M等)
– -d:显示目录本身(而不是内容)的属性
– -A:包括名称以 . 开头的隐藏文档

[root@haha ~]# ls -ld  /boot/
[root@haha ~]# ls -l  /boot/

[root@haha ~]# ls -lh  /boot/

[root@haha ~]# ls  /boot/
[root@haha ~]# ls -lh  /root
[root@haha ~]# ls -ld  /root

[root@haha ~]# ls -lh  /etc
[root@haha ~]# ls -ld  /etc

#######################################################
统计目录文件大小
[root@haha ~]# du -sh   /root

#######################################################
使用通配符
• 针对不确定的文档名称,以特殊字符表示
  – *:任意多个任意字符
  – ?:单个字符

[root@haha /]# ls  /etc/*tab
[root@haha /]# ls  /boot/vm*
[root@haha /]# ls  /etc/*.conf
[root@haha /]# ls  /dev/tty*

[root@haha /]# ls  /dev/tty?
[root@haha /]# ls  /dev/tty??


• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配

[root@haha /]# ls  /dev/tty[1-3]

[root@haha /]# ls  /dev/tty[2-9]

[root@haha /]# ls  /dev/tty{1,3,7,9,S0}

###################################################
   请显示/dev/的tty设备，tty20～tty30 ?

[root@haha /]# ls  /dev/tty{2[0-9],30}
 
[root@haha /]# ls  /dev/tty{2?,30}

####################################################
  命令的别名：简化复杂的命令

[root@haha /]# alias  别名='实际运行的命令'

[root@haha /]# alias  hn='hostname'     #定义别名
[root@haha /]# alias                    #显示当前生效的别名
[root@haha /]# hn                       #运行成功

[root@haha /]# unalias  hn               #删除别名
[root@haha /]# hn                        #运行失败

#######################################################

 mkdir创建目录
  -p:建立父目录，建立多级目录

[root@haha /]# mkdir -p /opt/aa/bb/cc/dd
[root@haha /]# ls /opt/aa

[root@haha /]# mkdir /root/abc  /opt/test01  /mnt/file
[root@haha /]# ls /root
[root@haha /]# ls /opt
[root@haha /]# ls /mnt

######################################################
rm 删除
• rm — Remove
– 格式:rm  [选项]...   文件或目录...

• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除

    递归:目录本身，以及目录下所有内容

[root@haha /]# rm -rf  /root/abc  /opt/test01  /mnt/file

#######################################################
mv 移动/改名
• mv — Move
– 格式:mv   [选项]...   原文件...     目标路径

[root@haha /]# rm -rf /opt/*
[root@haha /]# mkdir  /opt/nsd01
[root@haha /]# touch  /opt/1.txt
[root@haha /]# ls /opt/

[root@haha /]# mv /opt/1.txt  /opt/nsd01
[root@haha /]# ls /opt/
[root@haha /]# ls /opt/nsd01 

重命名:路径不变的移动
[root@haha /]# mv /opt/nsd01/  /opt/student
[root@haha /]# ls /opt/

[root@haha /]# mv /opt/student/   /opt/nsd02
[root@haha /]# ls /opt/

#######################################################
cp 复制
• cp — Copy

– 格式:cp  [选项]...   原文件...      目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项

[root@haha /]# rm -rf  /opt/*
[root@haha /]# touch  /opt/a.txt
[root@haha /]# mkdir  /opt/nsd01
[root@haha /]# ls  /opt/

[root@haha /]# cp  /opt/a.txt  /opt/nsd01
[root@haha /]# ls  /opt/
[root@haha /]# ls  /opt/nsd01/

[root@haha /]# cp  /etc/redhat-release  /opt/
[root@haha /]# ls  /opt/
[root@haha /]# cp  /etc/redhat-release  /opt/abc.txt
[root@haha /]# ls  /opt/

[root@haha /]# cp -r /boot/   /opt/
[root@haha /]# ls  /opt/
[root@haha /]# ls  /opt/boot/



cp可以支持两个以上的参数，永远会把最后一个参数作为 目标，其他参数都是源

 # cp -r   /etc/passwd    /etc/fstab   /boot/   /opt/

 # ls /opt/

 # rm -rf /opt/*
 # ls /opt/
 # mkdir /test03

 #  cp -r /test03  /opt/dir   #将目录test03放入/opt命名为dir
 #  ls /opt/

 #  cp -r /test03  /opt/dir   #将目录test03放入/opt/dir中
 #  ls /opt/
 #  ls /opt/dir


 在本次操作，临时取消别名
[root@haha /]# cp  -r  /boot/  /opt/
[root@haha /]# cp  -r  /boot/  /opt/  
[root@haha /]# \cp  -r  /boot/  /opt/     #取消覆盖的提示

#######################################################
 
使用vim创建/修改文件
• vim文本编辑器
– 格式:vim [[/目录/]文件名]

– 若目标文件不存在,则新建空文件并编辑
– 若目标文件已存在,则打开此文件并编辑      

 三个模式：命令模式     输入模式(插入模式)       末行模式

[root@haha /]# vim  /opt/haix.txt
         
	命--------- i 键  -------------》输入模式(Esc 键可以返回命令模式）
	令
	模
	式---------  :  键   -------------》末行模式(Esc 键可以返回命令模式）

    末行模式 ：wq   保存并退出    wq! 强制保存并退出
    末行模式 ：q！  强制不保存并退出

##########################################################

44444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444
44444444444444444444444444444444444444444
44444444444444444444444444444444444


使用教学虚拟机

• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机
– classroom —— 提供网关/DNS/软件素材等资源


优先开启classroom虚拟机

1.真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  #先重置资源服务器
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

2.  登陆虚拟机server与虚拟机desktop
      用户名：root   密码: redhat

 虚拟机server
        操作系统版本：RHEL 7.0
        系统IP地址：172.25.0.11/24
        主机名：server0.example.com


 虚拟机desktop
        操作系统版本：RHEL 7.0
        系统IP地址：172.25.0.10/24
        主机名：desktop0.example.com

##########################################################
利用真机远程管理，两台虚拟机

1.真机上操作：测试真机能否通信
[root@room9pc01 ~]# ping 172.25.0.11
[root@room9pc01 ~]# ping 172.25.0.10

2.真机上操作：远程管理
[root@room9pc01 ~]# ssh   用户名@对方的IP地址
[root@room9pc01 ~]# ssh   root@172.25.0.11

 Ctrl+shift+t : 可以再开一个新的终端

[root@room9pc01 ~]# ssh   root@172.25.0.10

[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.

3.运城管理打开对方的图形程序

[root@room9pc01 ~]# ssh -X root@172.25.0.11

[root@server0 ~]# firewall-config    #防火墙图形配置程序


########################################################
零散软件管理

虚拟机Server
1.关闭虚拟机添加光驱设备

2.显示光盘内容
[root@server0 ~]# mount /dev/cdrom  /dvd/
mount: /dev/sr0 写保护，将以只读方式挂载

[root@server0 ~]# ls /dvd/



[root@server0 ~]# rpm  -q   软件名（程序名）
 
[root@server0 ~]# rpm -q firefox    #检测程序是否安装
firefox-24.5.0-1.el7.x86_64
[root@server0 ~]# rpm -q zip
[root@server0 ~]# rpm -q gcc
[root@server0 ~]# rpm -q java
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 

[root@server0 ~]# rpm -ivh /dvd/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm                #安装软件包

[root@server0 ~]# rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64
[root@server0 ~]# rpm -e vsftpd               #卸载软件包
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 

了解：系统导入红帽签名信息
[root@server0 ~]# rpm --import /dvd/RPM-GPG-KEY-redhat-release 

##########################################################
安装软件包，产生依赖关系
常见的提示
错误：依赖检测失败：

##########################################################
自动解决依赖关系，安装软件  Yum软件包管理


   DNS：域名解析，将域名解析为IP地址

 服务：为客户端安装软件

 服务端： classroom.example.com搭建Web服务，共享了7.0光盘所有内容

              1.众多的软件包    2.仓库清单，仓库数据文件   3.共享的服务

    测试： 
    http://classroom.example.com/content/rhel7.0/x86_64/dvd/


 客户端：书写客户端配置文件
       /etc/yum.repos.d/*.repo

      错误的客户端配置文件与正确的客户端配置文件，会相互影响

[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dvd.repo
 [dvd]    #仓库标识
 name=rhel7.0  #仓库描述信息
 baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/    #指定Yum服务端位置

 enabled=1   #启用此该文件
 gpgcheck=0  #不做签名检查

[root@server0 ~]# yum repolist    #列出仓库信息

##########################################################
Yum的使用：

[root@server0 ~]# yum -y install sssd    #安装软件包
[root@server0 ~]# yum -y install httpd   #安装软件包
[root@server0 ~]# yum -y install gcc     #安装软件包

[root@server0 ~]# yum clean all       #清空Yum缓存

[root@server0 ~]# yum  remove  gcc     #卸载软件包

[root@server0 ~]# yum  search  ftp     #查询软件包信息

########################################################

下载软件包

使用wget下载工具
– wget  软件包的URL网址
– wget  软件包的URL网址    -O  /目录路径/新文件名


虚拟机server

 # wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

 # rpm -ivh kernel-3.10.0-123.1.2.el7.x86_64.rpm 

 # reboot 

[root@room9pc01 ~]# ssh -X root@172.25.0.11
Last login: Mon Jun  4 11:17:10 2018 from 172.25.0.250
[root@server0 ~]# uname  -r
3.10.0-123.1.2.el7.x86_64

##########################################################
配置网络
 
1. 配置永久主机名
[root@server0 ~]# vim  /etc/hostname
nsd.tedu.com
[root@server0 ~]# cat  /etc/hostname

[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[root@room9pc01 ~]# ssh -X root@172.25.0.11
Last login: Mon Jun  4 15:43:43 2018 from 172.25.0.250
[root@nsd ~]# hostname
nsd.tedu.com
[root@nsd ~]# 



2.  配置永久IP地址、永久子网掩码、永久网关地址

   IP地址：互联网中计算机的唯一标识
     子网掩码：区分网络位与主机位
     网关地址：一个网络到另一个网络的关口

   /etc/sysconfig/network-scripts/ifcfg-eth0  #网卡配置文件

• 查看nmcli connection 识别网卡的名字
[root@nsd ~]# nmcli connection show

• 配置IP地址、子网掩码、网关地址
[root@nsd ~]# nmcli   connection   modify   'System eth0'    
 ipv4.method   manual  
 ipv4.addresses  '172.25.0.100/24    172.25.0.254'
 connection.autoconnect   yes

[root@nsd ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
                                                 #查看网卡配置文件
    nmcli   connection   修改   '网卡名'
    ipv4.方法   手工配置
    ipv4.地址   'ip地址/子网掩码     网关地址'
       每次开机自动启用

• 激活配置
[root@nsd ~]# nmcli connection up 'System eth0'
[root@nsd ~]# route   #查看网关的指令    gateway


3.永久DNS服务器地址
[root@nsd ~]# vim /etc/resolv.conf
nameserver  172.25.254.254

[root@nsd ~]# cat /etc/resolv.conf

[root@nsd ~]# nslookup server0.example.com    #测试解析
[root@nsd ~]# nslookup desktop0.example.com   #测试解析


#########################################################
重定向输出:将前面命令的输出结果，写入到文本文件中

     > :覆盖重定向
     >> :追加重定向

[root@nsd ~]# ls --help                   #查看命令的帮助信息
[root@nsd ~]# ls --help > /opt/ls.txt   
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# hostname > /opt/ls.txt
[root@nsd ~]# cat /opt/ls.txt 

[root@nsd ~]# hostname >> /opt/ls.txt 
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# hostname >> /opt/ls.txt 
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# echo 123456789
123456789
[root@nsd ~]# echo 123456789   >>  /opt/ls.txt
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# echo A.tedu.com  >  /etc/hostname
[root@nsd ~]# cat /etc/hostname

# echo nameserver 172.25.254.254  > /etc/resolv.conf 
# cat /etc/resolv.conf

   非交互式

######################################################3
555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  #先重置资源服务器
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################


管道操作：将前面命令的输出结果,交由后面命令继续处理,作为后面命令的参数

     显示/etc/passwd第8～12行？

[root@server0 ~]# head -12 /etc/passwd

[root@server0 ~]# head -12 /etc/passwd  | tail -5

[root@server0 ~]# head -12 /etc/passwd  | tail -5 | cat -n

[root@server0 ~]# cat -n /etc/passwd | head -12 | tail -5

 显示第一张网卡的IP地址
[root@server0 ~]# ifconfig | head -2

交互式计算器
[root@server0 ~]# bc

  加   +      减   -     乘   *     除   /       取余运算  %

#######################################################

用户与组的管理

 用户账户：1.可以登陆操作系统    2.实现访问控制，不同用户具备不同的权限

  组：方便对用户的管理（权限方面）

  唯一标识： UID  GID 

  管理员的UID永远为0

  组：基本组(私有组)     附加组(公共组  从属组)
        一个用户至少属于一个组
#####################################################
用户基本信息存放在 /etc/passwd 文件（户口本）

[root@server0 ~]# head  -1  /etc/passwd
root:x:0:0:root:/root:/bin/bash

用户名:密码占位符:UID:基本组GID:用户描述信息:用户家目录:解器程序


• 使用 useradd 命令
– useradd [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 解释器程序、-G 附加组

[root@server0 ~]# useradd nsd02
[root@server0 ~]# grep nsd /etc/passwd

[root@server0 ~]# useradd  -u 1200 nsd03   #指定UID
[root@server0 ~]# grep nsd /etc/passwd

[root@server0 ~]# useradd nsd04
[root@server0 ~]# grep nsd /etc/passwd

[root@server0 ~]# useradd -d /mnt/nsd05   nsd05  #指定家目录
[root@server0 ~]# ls /mnt/
[root@server0 ~]# grep nsd05 /etc/passwd

[root@server0 ~]# id nsd02
[root@server0 ~]# id nsd03
[root@server0 ~]# id nsd04
[root@server0 ~]# id nsd05

/sbin/nologin : 禁止用户登陆系统

[root@server0 ~]# useradd -s /sbin/nologin nsd07
[root@server0 ~]# grep nsd07 /etc/passwd

[root@server0 ~]# groupadd tarena           #创建tarena组
[root@server0 ~]# useradd -G tarena  nsd08  #创建用户加入组
[root@server0 ~]# id nsd08

#######################################################

• 使用 passwd 命令
– passwd [用户名]



[root@server0 ~]# passwd nsd02
更改用户 nsd02 的密码 。
新的 密码：                                              #设置密码
无效的密码： 密码是一个回文
重新输入新的 密码：                                 #重新输入密码
passwd：所有的身份验证令牌已经成功更新。

命令行临时切换用户身份：   su  -  用户名
[root@server0 ~]# su  -  nsd02
[nsd02@server0 ~]$ passwd 
Changing password for user nsd02.
Changing password for nsd02.
(current) UNIX password:          #输入旧密码
New password:                     #输入新密码
Retype new password:              #再次输入新密码
passwd: all authentication tokens updated successfully.
[nsd02@server0 ~]$ exit

非交互式设置密码
– echo '密码'    |    passwd --stdin 用户名


[root@server0 ~]# echo 123 | passwd --stdin nsd02

[root@server0 ~]# echo 123456 | passwd --stdin nsd03

#######################################################
用户密码信息存放在 /etc/shadow 文件

   用户名: 密码加密字符串:上一次修改密码的时间


######################################################
   

修改用户属性
• 使用 usermod 命令
  [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录Shell、-G 附加组

[root@server0 ~]# useradd tom
[root@server0 ~]# id tom
[root@server0 ~]# grep tom /etc/passwd

# usermod -u 1400 -d /mnt/test -s /sbin/nologin -G tarena tom

[root@server0 ~]# grep tom /etc/passwd
[root@server0 ~]# id tom

#######################################################
删除用户
• 使用 userdel    命令
– userdel  [-r]  用户名   #连同家目录一并删除

[root@server0 ~]# userdel -r nsd03
[root@server0 ~]# ls /home/


#####################################################
管理组账号

组基本信息存放在 /etc/group 文件

[root@server0 ~]# grep stugrp /etc/group
 stugrp:x:1303:

  组名:组密码占位符:GID:组成员列表


添加组
• 使用 groupadd 命令
– groupadd [-g 组ID] 组名

[root@serv0 ~]# groupadd stugrp
[root@server0 ~]# grep stugrp /etc/group
stugrp:x:1303:

[root@server0 ~]# useradd harry
[root@server0 ~]# useradd natasha
[root@server0 ~]# useradd kenji
[root@server0 ~]# useradd jack


使用 gpasswd 命令
– gpasswd -a 用户名  组名
– gpasswd -d 用户名  组名

[root@server0 ~]# gpasswd -a harry stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -a kenji stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -d harry stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -a jack stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -d kenji stugrp
[root@server0 ~]# grep stugrp /etc/group

• 使用 groupdel 命令
– groupdel 组名


################################################
tar备份与恢复 

归档和压缩:  1.方便对零散文件的整理   2.减小磁盘空间的占用

 独有压缩格式： 
           gzip -----》 .gz 
           bzip2 -----》 .bz2
           xz -----》 .xz

• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理
– -t:显示归档中的文件清单
– -C:指定释放的位置

命令格式
 打包：
   tar  选项       /路径/压缩包的名字       /路径/被归档及压缩的源文件

 解包:
   tar  选项       /路径/压缩包的名字     -C  /路径

[root@server0 ~]# rm -rf /opt/*

# tar -zcf /opt/file.tar.gz   /home/  /etc/passwd 
[root@server0 ~]# ls /opt/

# tar -jcf /opt/test.tar.bz2  /home/  /etc/passwd
[root@server0 ~]# ls /opt/

# tar -Jcf /opt/nsd.tar.xz  /home/  /etc/passwd
[root@server0 ~]# ls /opt/

[root@server0 ~]# tar -xf /opt/file.tar.gz -C /mnt/
[root@server0 ~]# ls /mnt/
[root@server0 ~]# ls /mnt/etc/
[root@server0 ~]# ls /mnt/home/

查看包里面内容
[root@server0 ~]# tar -tf /opt/nsd.tar.xz 

####################################################
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

 # tar -jcf  /root/backup.tar.bz2   /usr/local/
 # ls /root/
 # tar -tf /root/backup.tar.bz2 

#####################################################
NTP时间同步

• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

服务端：classroom.example.com

客户端：虚拟机server

1.安装同步时间软件chrony
[root@server0 ~]# rpm -q chrony
chrony-1.29.1-1.el7.x86_64

2.修改配置/etc/chrony.conf
 在Linux中大多数配置文件中，以#开头的为注释内容

 #server 0.rhel.pool.ntp.org iburst
 #server 1.rhel.pool.ntp.org iburst
 #server 2.rhel.pool.ntp.org iburst
 server classroom.example.com iburst

3.重起服务刷新配置
   服务名：chronyd

  daemon：守护进程

[root@server0 ~]# systemctl restart chronyd  #重起服务
[root@server0 ~]# systemctl enable chronyd  #开机自启动

4.验证：
[root@server0 ~]# date

[root@server0 ~]# date -s "年-月-日  时:分:秒"
[root@server0 ~]# date -s "2008-10-1 12:30"

[root@server0 ~]# date
[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# date
[root@server0 ~]# date

###############################################
cron计划任务

• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务

• 软件包:cronie、crontabs
• 系统服务:crond
• 日志文件:/var/log/crond

	 *: 匹配范围内任意时间
	 ,: 分隔多个不连续的时间点
	 -: 指定连续时间范围
	/n: 指定时间频率,每n 


       时间                       任务
  分  时  日  月  周         任务命令行


• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]

  每分钟记录系统时间，写入/opt/time.txt

[root@server0 ~]# date  >>  /opt/time.txt
[root@server0 ~]# cat  /opt/time.txt

[root@server0 ~]# crontab  -e  -u  root   #编写计划任务
*  *  *  *  *   date >> /opt/time.txt

[root@server0 ~]# crontab  -l  -u  root   #查看计划任务

[root@server0 ~]# cat   /opt/time.txt 

######################################################
66666666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666666



真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################

基本权限

访问方式(权限)
– 读取:允许查看内容-read  r
– 写入:允许修改内容-write   w
– 可执行:允许运行和切换-execute  x

   对于文本文件:
          r:  cat  less  head  tail 
          w:  vim   重定向
          x:  可以运行该文件


 • 权限适用对象(归属)
    – 所有者(属主):拥有此文件/目录的用户-user   u
    – 所属组(属组):拥有此文件/目录的组-group    g
    – 其他用户:除所有者、所属组以外的用户-other   o

查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

   以  -  开头 ： 文本文件
   以  d 开头 ： 目录
   以  l 开头 ：快捷方式

###############################################

• 使用 chmod 命令
– chmod [-R] 归属关系+-=权限类别    文档...
        [-R] 递归设置权限


[root@server0 /]# mkdir /nsd01
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod u-w /nsd01     #所有者去掉w权限
[root@server0 /]# ls -ld /nsd01 

[root@server0 /]# chmod g+w /nsd01     #所属组加上w权限
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod o=--- /nsd01   #修改其他人权限
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod u=rwx,g=rx,o=rx /nsd01
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod ugo=rwx /nsd01
[root@server0 /]# ls -ld /nsd01

###################################################
如何判断用户的权限：              匹配及停止
        1.判断用户的角色            所有者>所属组>其他人 
        2.查看相应位置的权限


常见的提示：
 Permission denied :权限不足


目录的 r 权限:能够 ls 浏览此目录内容
目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作
目录的 x 权限:能够 cd 切换到此目录

#######################################################


以root用户新建/nsddir/目录，在此目录下新建readme.txt文件，并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录   切换用户  su  -  lisi
     chmod o+w  /nsddir/

 2）使用户lisi不能够在此目录下创建子目录
     chmod o-w  /nsddir/

 3）使用户lisi能够修改readme.txt文件
     chmod o+w  /nsddir/readme.txt

 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/   

 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/

####################################################

• 使用 chown 命令
– chown [-R] 属主         文档...
– chown [-R] :属组       文档...
– chown [-R] 属主:属组  文档...
        [-R]  递归修改归属关系

[root@server0 /]# mkdir /nsd03
[root@server0 /]# ls -ld /nsd03
[root@server0 /]# groupadd tarena
[root@server0 /]# chown lisi:tarena  /nsd03 
[root@server0 /]# ls -ld /nsd03

[root@server0 /]# chown zhangsan /nsd03   #修改所有者
[root@server0 /]# ls -ld /nsd03

[root@server0 /]# chown :root /nsd03   #修改所属组
[root@server0 /]# ls -ld /nsd03

#####################################################
附加权限(特殊权限)

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设置与父目录相同的属组
– 传递所属组身份

[root@server0 ~]# mkdir /nsd06
[root@server0 ~]# chown :tarena /nsd06
[root@server0 ~]# ls -ld /nsd06

[root@server0 ~]# mkdir /nsd06/test01
[root@server0 ~]# ls -ld /nsd06/test01

[root@server0 ~]# chmod g+s /nsd06
[root@server0 ~]# ls -ld /nsd06

[root@server0 ~]# mkdir /nsd06/test02
[root@server0 ~]# ls -ld /nsd06/test02   #所属组会继承父目录

[root@server0 ~]# ls -ld /nsd06/test01

#######################################################
acl访问控制列表

• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持


[root@server0 ~]# mkdir /nsd07
[root@server0 ~]# chmod o=--- /nsd07
[root@server0 ~]# ls -ld /nsd07

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd07
-bash: cd: /nsd07: Permission denied
[lisi@server0 ~]$ exit
[root@server0 ~]# setfacl -m u:lisi:rx /nsd07
[root@server0 ~]# getfacl  /nsd07

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd07
[lisi@server0 nsd07]$ pwd
[lisi@server0 nsd07]$ exit
[root@server0 ~]# 


• 使用 getfacl、setfacl 命令
– getfacl 文档....
– setfacl [-R] -m  u:用户名:权限类别   文档...
– setfacl [-R] -m  g:组名:权限类别   文档...
– setfacl [-R] -b  文档...      #清空所有的ACL策略
– setfacl [-R] -x  文档...      #删除指定的ACL策略


[root@server0 ~]# mkdir /nsd08
[root@server0 ~]# setfacl -m u:zhangsan:rwx  /nsd08
[root@server0 ~]# setfacl -m u:lisi:rx  /nsd08
[root@server0 ~]# setfacl -m u:dc:rx  /nsd08
[root@server0 ~]# getfacl /nsd08

[root@server0 ~]# setfacl -x u:lisi  /nsd08  #删除指定ACL
[root@server0 ~]# getfacl /nsd08

[root@server0 ~]# setfacl -b /nsd08   #清空所有的ACL
[root@server0 ~]# getfacl /nsd08


[root@server0 ~]# mkdir  /public
[root@server0 ~]# chmod  ugo=rwx /public
[root@server0 ~]# ls  -ld  /public

[root@server0 ~]# setfacl  -m  u:lisi:---  /public
[root@server0 ~]# getfacl  /public

####################################################
使用LDAP认证

  LDAP服务器： 网络用户认证       放到网络中LDAP服务器
    本地用户：  /etc/passwd

                 
  LDAP服务器：classroom.example.com


    客户端：虚拟机Server
    1.安装sssd软件包  与LDAP服务器沟通
  [root@server0 ~]# yum -y install sssd
  [root@server0 ~]# rpm -q sssd

    2.图形的配置工具authconfig-gtk软件  修改sssd配置

  [root@server0 ~]# yum -y install authconfig-gtk
 

  3.运行图形的工具进行配置 
  [root@server0 ~]# authconfig-gtk 

    选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名

   勾选TLS加密
   使用证书加密: http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码

  4.重起sssd服务验证
  [root@server0 ~]# systemctl restart sssd
  [root@server0 ~]# systemctl enable sssd   #设置开机自启动
  [root@server0 ~]# grep ldapuser0 /etc/passwd
  [root@server0 ~]# id ldapuser0
########################################################
家目录漫游

什么是NFS共享
• Network File System,网络文件系统
– 由NFS服务器将指定的文件夹共享给客户机
– 客户机将此共享目录 mount 到本地目录,访问此共享
资源就像访问本地目录一样方便
– 类似于 EXT4、XFS等类型,只不过资源在网上

 NFS服务器：classroom.example.com
  客户端：虚拟机Server

   1.查看服务端共享 
 [root@server0 ~]# showmount -e classroom.example.com
 Export list for classroom.example.com:
 /home/guests 172.25.0.0/255.255.0.0

   2.访问共享
 # mount  classroom.example.com:/home/guests   /mnt
 # ls /mnt/

 # mkdir /home/guests
 # ls  /home/guests
 # umount  /mnt/
# mount classroom.example.com:/home/guests/  /home/guests/
 # ls /home/guests/

######################################################
7777777777777777777777777777777777777777777777777777777777
777777777777777777777777777777777777777777777777777777777
77777777777777777777777777777777777777777777777777777777



真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################
grep文件内容过滤

 格式：  grep  '字符串'    /路径/文本文件

[root@server0 ~]# grep  'root'  /etc/passwd
[root@server0 ~]# grep  'bin'   /etc/passwd
[root@server0 ~]# grep  'bash'  /etc/passwd
   选项:   -i 忽略大小写
[root@server0 ~]# grep -i 'man'  /etc/man_db.conf 
[root@server0 ~]# grep -i 'ROOT' /etc/passwd
   选项:   -v 取反
[root@server0 ~]# grep -v 'root'  /etc/passwd

  特殊的过滤条件
         ^root   必须以root开头
         root$   必须以root结尾
                 ^$           匹配空行

[root@server0 ~]# grep '^root' /etc/passwd
[root@server0 ~]# grep 'bash$' /etc/passwd
[root@server0 ~]# grep 'nologin$' /etc/passwd

[root@server0 ~]# grep -v '^$'  /etc/default/useradd 

     显示文本文件有效配置？（去除空行、去除注释行）
# grep -v '^#' /etc/default/useradd   |  grep -v '^$'

# grep -v '^#' /etc/login.defs  |  grep  -v '^$'

###################################################
 find 查找文档所在位置

  格式：  find   查询路径     条件
 
	– 常用条件表示:
	 -type 类型(f 文件   d 目录   l 快捷方式)

[root@server0 ~]# find /boot/ -type l
[root@server0 ~]# ls /boot/grub/menu.lst 
[root@server0 ~]# ls -l /boot/grub/menu.lst

[root@server0 ~]# find /boot/ -type d

[root@server0 ~]# find /boot/ -type f

[root@server0 ~]# find /root -type d

[root@server0 ~]# find /root -type f
####################################################
    -name  "名字"

[root@server0 ~]# find /etc/  -name "passwd"

[root@server0 ~]# find /etc/ -name  "*passwd*"

[root@server0 ~]# find /boot/  -name  "vm*"

[root@server0 ~]# find /etc/ -name  "*.conf"   #包含子目录

#####################################################
多条件的查找  -a   且and，可以不写，默认-a

[root@server0 ~]# mkdir /root/nsd1805
[root@server0 ~]# touch /root/nsd01.txt
[root@server0 ~]# touch /root/nsd02.txt

[root@server0 ~]# find /root/  -name  "nsd*"

[root@server0 ~]# find /root/  -name  "nsd*"   -type f

[root@server0 ~]# find /root/  -name  "nsd*"   -type d

####################################################
  -size +-大小   k M G     按大小查找
  
[root@server0 ~]# find  /boot/   -size +10M

[root@server0 ~]# find  /boot/   -size -10M

[root@server0 ~]# find  /boot/   -size +300k

###################################################

处理find查找的内容（多参数的命令，不支持管道‘|’）
查找完了以后，查找的结果～直接执行处理
– find .. .. -exec  处理命令 {}    \;
– 优势:以 {} 代替每一个结果,逐个处理,遇 \; 结束

# find  /boot/  -size +10M 
# find  /boot/  -size +10M   -exec cp  {}  /opt  \; 

# find /root/ -name "nsd*"   -type ffi

# find /root/ -name "nsd*"   -type f  -exec cp {}  /opt \;

# find /boot/ -size +10M     -exec ls  -lh  {} \;
#######################################################
 按照所有者查找

  -user  zhangsan

[root@server0 ~]# find /home -user student
[root@server0 ~]# find / -user student
[root@server0 ~]# find / -user student  -type f

######################################################

• 根据名称查找,忽略大小写
– -iname

[root@server0 ~]# find /etc/ -iname "passwd"

[root@server0 ~]# find /etc/ -iname "Passwd"

[root@server0 ~]# find /etc/ -iname "PASSWD"



####################################################
• 根据所属组查找
  -group

[root@server0 ~]# find /home/ -group student

• 限制目录查找的深度(最大层数)
– -maxdepth

[root@server0 ~]# find /etc/  -maxdepth 1 -name "*.conf"
 
[root@server0 ~]# find /etc/  -maxdepth 2 -name "*.conf"

[root@server0 ~]# find /etc/  -maxdepth 3 -name "*.conf"



• 根据文件修改时间，所有时间都是过去时间
 -mtime +-天数

 # find  /var/log/  -mtime +90    #90天之前

 # find  /var/log/  -mtime -10    #最近10天之内

######################################################
• 使用find命令完成以下任务
– 找出所有用户 student 拥有的文件
– 把它们拷贝到 /root/findfiles/ 文件夹中

# mkdir /root/findfiles
# find / -user student -type f

# find / -user student -type f  -exec cp  {}  /root/findfiles/   \;

# ls -A /root/findfiles

#####################################################
Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者具有文件属主的身份及部分权限
– 传递所有者身份
 

Sticky Bit
• 附加在其他人的 x 位上
– 其他人的权限标识会变为 t
– 适用于开放w权限的目录,可以阻止用户滥用w写入权限(禁止操作别人的文档)

[root@server0 ~]# mkdir /public
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public
[root@server0 ~]# chmod o+t /public
[root@server0 ~]# ls -ld /public

####################################################
    








EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE



真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################

统计文件有多少行
[root@server

0 ~]# wc -l /etc/passwd
[root@server0 ~]# wc -l /etc/redhat-release 

 请计算Linux系统中一共有多少个用户？
[root@server0 ~]# wc -l /etc/passwd
 
 请计算Linux系统/etc/以tab结尾的文件有多少个？
[root@server0 ~]# find /etc/ -name "*tab" | wc -l

[root@server0 ~]# find /etc/ -name "*.conf" | wc -l

###################################################
扇区:512字节

• 识别硬盘 => 分区规划 => 格式化 => 挂载使用

   毛坯楼层=>打隔断=>装修 => 入驻


格式化：赋予一种规则，数据在空间存放的规则（文件系统）


服务器的硬盘，支持热插拔
###################################################
 分区规划 

分区模式：施工方案

    MBR/msdos：最大支持到2TB
       – 分区的类型：主分区   扩展分区   逻辑分区
       – 4个主分区,或者 3个主分区+1个扩展分区(n个逻辑分区)
       – 扩展分区空间不能直接使用
         扩展分区默认占用剩余的所有

一、进行分区
1.查看当前系统识别的磁盘
[root@server0 ~]# lsblk 
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
vda     253:0    0  10G  0 disk 
└─vda1 253:1    0  10G  0 part /
vdb     253:16   0  10G  0 disk
 
[root@server0 ~]# ls /dev/vdb

2.划分分区
[root@server0 ~]# fdisk  /dev/vdb
   n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
   p 查看分区表
   n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
   d 删除分区
   w 保存并退出   (q 不保存退出)

[root@server0 ~]# lsblk 
[root@server0 ~]# ls /dev/vdb[1-2]


二、格式化           .fat最老的一款文件类型，通用，识别的多
[root@server0 ~]# mkfs.ext4 /dev/vdb1   #格式化文件系统为ext4
[root@server0 ~]# blkid /dev/vdb1       #查看文件系统类型

[root@server0 ~]# blkid /dev/vdb2      
[root@server0 ~]# mkfs.xfs /dev/vdb2   #格式化文件系统为xfs
[root@server0 ~]# blkid /dev/vdb2

  重复格式化
[root@server0 ~]# mkfs.xfs -f /dev/vdb1

三、挂载使用     提供访问点
[root@server0 ~]# mount /dev/vdb1 /part1
mount: 挂载点 /part1 不存在
[root@server0 ~]# mkdir /part1
[root@server0 ~]# mount /dev/vdb1 /part1

[root@server0 ~]# mkdir /part2
[root@server0 ~]# mount /dev/vdb2 /part2

查看当前正在挂载设备的使用情况

[root@server0 ~]# df -h

四、开机自动挂载 /etc/fstab
                                           命令dump
  – 设备路径    挂载点   类型   参数     备份标记   检测顺序
                                                        根分区检测，其他都默认不检测

 补充：vim 命令模式 按 o 可以另起一行 进入插入模式

[root@server0 ~]# vim  /etc/fstab
 /dev/vdb1   /part1    ext4    defaults 0 0
 /dev/vdb2   /part2    xfs     defaults 0 0

[root@server0 ~]# df -h
[root@server0 ~]# umount /part1
[root@server0 ~]# umount /part2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a
[root@server0 ~]# df -h
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载

五、综合分区
  最终有3个主分区，分别为2G、2G、1G
  创建扩展分区
  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +1G
   p 查看分区表
   n 创建扩展分区 
                   ----->回车---->起始回车----->结束回车  将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe  刷新所有分区 
[root@server0 ~]# lsblk
[root@server0 ~]# ls /dev/vdb[1-6]

   /dev/sda5: SCSI接口的第一块硬盘的第一个逻辑分区

####################################################
总结：
   1.查看所有的硬盘设备   lsblk
   2.进行分区        fdisk
   3.刷新分区        partprobe
   4.进行格式化     mkfs.ext4  mkfs.xfs
   5.查看是否有文件系统    blkid
   6.完成挂载        mount   
   7.书写/etc/fstab完成开机自动挂载
   8.进行mount -a测试
   9.查看是否挂载成功  df  -h

###################################################
添加一个80G新虚拟磁盘

[root@room9pc01 ~]# gos

[root@server0 ~]# lsblk
 
 vdc    253:32   0  80G  0 disk
 
综合分区：
   三个主分区，分别10G
   创建扩展分区
   两个逻辑分区，分别10G
[root@server0 ~]# fdisk  /dev/vdc  
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         连续创建3个10G主分区
      ......
   n 创建扩展分区 
                   ----->回车---->起始回车----->结束回车  将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 

#######################################################
LVM逻辑卷的管理

   作用： 1.可以整合分散的空间   2.空间可以扩大

创建思路：

     零散空闲存储 ---->整合的虚拟磁盘 ---->虚拟的分区

     物理卷（PV）     卷组（VG）     逻辑卷（LV）

  将众多的 物理卷(PV)组成卷组(VG)，再从卷组(VG)划分出逻辑卷(LV）

   蒸馒头：
      面粉--------->大面团-------->小面团------->蒸------->吃

   房子：
      砖--------->大房子-------->打隔断-------->装修------->入住

####################################################
  
一、创建逻辑卷

1.直接创建卷组
  格式：vgcreate 卷组名   分区路径

[root@server0 ~]# vgcreate nsd /dev/vdc[1-2]
[root@server0 ~]# pvs   #显示物理卷信息
[root@server0 ~]# vgs   # 显示卷组信息

2.创建逻辑卷
  格式：lvcreate -L 大小    -n  逻辑卷名称     基于的卷组名

[root@server0 ~]# lvcreate -L 16G -n mylv  nsd
[root@server0 ~]# vgs
[root@server0 ~]# lvs

3.逻辑卷的使用
[root@server0 ~]# ls /dev/nsd/mylv         #查看逻辑卷设备
[root@server0 ~]# ls -l /dev/nsd/mylv
[root@server0 ~]# mkfs.ext4 /dev/nsd/mylv   #格式化
[root@server0 ~]# blkid  /dev/nsd/mylv

[root@server0 ~]# vim  /etc/fstab 
/dev/nsd/mylv  /lvm   ext4   defaults   0  0

[root@server0 ~]# mkdir /lvm
[root@server0 ~]# mount -a
[root@server0 ~]# df -h

####################################################
逻辑卷的扩展,支持线上操作

一、卷组有足够的剩余空间

1.直接扩展逻辑卷空间
[root@server0 ~]# vgs
[root@server0 ~]# lvs
[root@server0 ~]# lvextend -L 18G /dev/nsd/mylv 
[root@server0 ~]# lvs

2.扩展文件系统的大小（刷新文件系统的大小）
    扩展ext4文件系统：resize2fs
    扩展xfs文件系统：xfs_growfs

[root@server0 ~]# df -h
[root@server0 ~]# resize2fs /dev/nsd/mylv 
[root@server0 ~]# df -h

二、卷组没有足够的剩余空间

1.扩展卷组空间
[root@server0 ~]# vgextend nsd /dev/vdc3
[root@server0 ~]# vgs

2.直接扩展逻辑卷空间
[root@server0 ~]# lvs
[root@server0 ~]# lvextend -L 25G /dev/nsd/mylv 
[root@server0 ~]# lvs

3.扩展文件系统的大小（刷新文件系统的大小）

[root@server0 ~]# df -h
[root@server0 ~]# resize2fs /dev/nsd/mylv 
[root@server0 ~]# df -h

#######################################################
逻辑卷补充内容：
  ext4：支持缩减
   xfs：不支持缩减

一、逻辑卷的缩减，不支持线上操作
  1.文件系统的缩减
[root@server0 ~]# resize2fs /dev/nsd/mylv 10G
[root@server0 ~]# umount /lvm
[root@server0 ~]# resize2fs /dev/nsd/mylv 10G
resize2fs 1.42.9 (28-Dec-2013)
请先运行 'e2fsck -f /dev/nsd/mylv'.

[root@server0 ~]# e2fsck -f /dev/nsd/mylv
[root@server0 ~]# resize2fs /dev/nsd/mylv 10G

  2.空间的缩减
[root@server0 ~]# lvreduce -L 10G /dev/nsd/mylv 
  WARNING: Reducing active logical volume to 10.00 GiB
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce mylv? [y/n]: y
  Reducing logical volume mylv to 10.00 GiB
  Logical volume mylv successfully resized
[root@server0 ~]# lvs

###################################################
  PE：卷组划分空间的单位
--lvcreate -l PE个数  -n 逻辑卷名 卷组名
[root@server0 ~]# vgdisplay nsd   #显示nsd卷组详细信息

  PE Size               4.00 MiB


  请创建一个大小为250M逻辑卷为lvtest01

[root@server0 ~]# vgchange -s 1M nsd

[root@server0 ~]# vgdisplay 

[root@server0 ~]# lvcreate -L 250M -n lvtest01 nsd

[root@server0 ~]# lvs

[root@server0 ~]# vgchange -s 16M nsd

[root@server0 ~]# lvcreate -l 50 -n lvtest02 nsd

  -l :指定PE个数

##################################################
  逻辑卷的删除
    删除的顺序：先删除逻辑卷,再删除卷组，最后删除物理卷
   

[root@server0 ~]# lvremove /dev/nsd/mylv 
  Logical volume nsd/mylv contains a filesystem in use.
[root@server0 ~]# umount /lvm

[root@server0 ~]# lvremove /dev/nsd/mylv 
Do you really want to remove active logical volume m



2222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222
真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################
Shell脚本
    
    脚本：一个可以执行的文件，可以实现某种功能

[root@server0 ~]# vim  /root/hello.sh
echo hello world

[root@server0 ~]# chmod  +x  /root/hello.sh
 
[root@server0 ~]# /root/hello.sh    #绝对路径执行



###################################################
                #！/bin/bash   1，专业 2，打铺垫 3，考试时有分数
规范Shell脚本的一般组成
 • #! 环境声明  不写的话，默认/bin/bash  为以后学习python打铺垫
 • # 注释文本                                用其他语言必须要写，区分
 • 可执行代码
                               .sh 结尾，标志这是一个shell脚本     
[root@server0 ~]# vim  /root/system.sh 
 #!/bin/bash
 cat  /etc/redhat-release
 uname -r
 hostname
 ifconfig | head -2

 [root@server0 ~]# chmod +x /root/system.sh 

 [root@server0 ~]# /root/system.sh 

#######################################################

管道传递
• 使用 | 管道操作
– 将前一条命令的标准输出交给后一条命令处理


重定向输出
      > : 正确信息的重定向，只收集前面命令的正确输出
     2>: 错误信息的重定向，只收集前面命令的错误输出
     &>:正确与错误信息的重定向，收集前面命令的正确与错误输出

[root@server0 ~]# echo 123 > /opt/1.txt

[root@server0 ~]# cat /opt/1.txt /etc

[root@server0 ~]# cat /opt/1.txt /etc  >  /mnt/a.txt
[root@server0 ~]# cat /mnt/a.txt 

[root@server0 ~]# cat /opt/1.txt /etc  2>  /mnt/a.txt
[root@server0 ~]# cat /mnt/a.txt 
 
[root@server0 ~]# cat /opt/1.txt /etc  &> /mnt/a.txt
[root@server0 ~]# cat /mnt/a.txt

########################################################
  用于收集不要的命令输出，黑洞设备：/dev/null
 
[root@server0 ~]# vim  /root/user.sh

 #!/bin/bash
 useradd  nsd06  &>  /dev/null
 echo  用户nsd06创建成功
 echo  123  |  passwd  --stdin  nsd06  &> /dev/null
 echo  用户nsd06密码设置成功

[root@server0 ~]# chmod +x /root/user.sh

[root@server0 ~]# /root/user.sh


#################################################

 为了增加脚本灵活度，脚本适应多变的环境，方便重复使用一个值.所以使用变量

  变量：会变化的量， 相当于一个容器，存放可以变化的值
            以不变的名称，存放可以变化的值
  $变量名：调用变量储存的值

 [root@server0 ~]# vim /root/user.sh
 #!/bin/bash
 a=nsd10
 useradd  $a  &>  /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd --stdin  $a  &> /dev/null
 echo  用户$a密码设置成功

 [root@server0 ~]#  chmod +x  /root/user.sh
 [root@server0 ~]#  /root/user.sh



########################################################
  产生一个交互式问答，降低脚本使用难度，脚本更加的灵活

 read : 产生一个交互式问答, 
  可以记录用户在键盘的输入，并且会将用户在键盘的输入，赋值给变量储存


[root@server0 ~]# vim  /root/user.sh
 #!/bin/bash
 read -p  '请输入您要创建的用户名:'     a
 useradd  $a   &> /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd  --stdin  $a  &> /dev/null
 echo  用户$a密码设置成功

######################################################

变量的定义/引用

• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值


• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo  $变量名、echo  ${变量名}

[root@server0 ~]# a=rhel
[root@server0 ~]# echo $a

[root@server0 ~]# echo $a7

[root@server0 ~]# echo ${a}7
补充：
  $[ ] :代表运算

[root@server0 ~]# echo $[1+1]
[root@server0 ~]# echo $[4+1]
[root@server0 ~]# echo $[10/3]
[root@server0 ~]# echo $[10%3]      #取余数运算
[root@server0 ~]# echo $[4*2]

 余数运算： 余数一定小于除数


  $( )与反撇号  ` ` ： 将命令的输出结果，作为命令的参数
[root@server0 opt]# date
[root@server0 opt]# date +%F
[root@server0 opt]# cd /opt

[root@server0 opt]# mkdir  dir-$(date +%F)
[root@server0 opt]# ls

[root@server0 opt]# mkdir $(hostname)-$(date +%F)
[root@server0 opt]# ls

   ' ' :取消所有shell中特殊字符意义，原样输出
##################################################
系统定义，用户直接使用

  储存随机数的变量：RANDOM

  请显示 10以内的随机数字 [0-9]?
  余数运算： 余数一定小于除数

[root@server0 /]# echo $[$RANDOM%10]

[root@server0 /]# echo $[$RANDOM%100]

###################################################
环境变量，由系统定义完成

   USER=当前登陆的用户名

[root@server0 /]# echo $USER
root
[root@server0 /]# su - nsd01
[nsd01@server0 ~]$ echo $USER
nsd01
[nsd01@server0 ~]$ exit
logout
[root@server0 /]# 

位置变量
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. 

   read -p  :  可以在脚本运行的时候，从命令行传递变量的值

     位置变量   :  可以在脚本运行的时候，从命令行传递变量的值（非交互）

[root@server0 /]# vim /root/1.sh
  #!/bin/bash
  echo $1
  echo $2
  echo $3

[root@server0 /]#  /root/1.sh  test01  harry   180

[root@server0 /]# vim /root/cat.sh 
  #!/bin/bash
  cat -n $1  | head -$2

[root@server0 /]# /root/cat.sh /etc/passwd  2


预定义变量
• 用来保存脚本程序的执行信息
– 直接使用这些变量
– 不能直接为这些变量赋值

	$#  已加载的位置变量的个数
	$*  所有位置变量的值,再重新输出一遍
	$?  程序退出后的状态值,0表示正常,其他值异常

 [root@server0 /]# vim /root/1.sh 
  #!/bin/bash
  echo $1
  echo $2
  echo $3
  echo $#            #统计位置变量的个数
  echo $*            #输出所有位置变量的值

[root@server0 /]# /root/1.sh haha xixi hehe lele
 haha
 xixi
 hehe
  4
 haha xixi hehe lele

[root@server0 /]# useradd natasha
[root@server0 /]# echo $?
0
[root@server0 /]# id natasha
uid=1020(natasha) gid=1020(natasha) 组=1020(natasha)
[root@server0 /]# echo $?
0
[root@server0 /]# id haxi
id: haxi: no such user
[root@server0 /]# echo $?
1
[root@server0 /]# useradd natasha
useradd：用户“natasha”已存在
[root@server0 /]# echo $?
9
[root@server0 /]# 

#####################################################
条件测试

  [  测试表达式  ]      #每一部分都要有空格

 • 检查文件状态
	-e：判断文档是否存在，存在为真
	-d：存在并且为目录为真
	-f：存在并且为文件为真
	-r：存在并且对其有读取权限为真
	-w：存在并且对其有写入权限为真
	-x：存在并且对其有执行权限为真


[root@server0 /]# [ -e /etc ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ -d /etc/passwd ]
[root@server0 /]# echo $?
1
[root@server0 /]# [ -f /etc/passwd ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ -f /etc/ ]
[root@server0 /]# echo $?
1
[root@server0 /]# [ -e /abcd ]
[root@server0 /]# echo $?



• 比较整数大小( 带e字母的都有等于二字)
	-gt:大于
	-ge:大于等于   
	-eq:等于         
	-ne:不等于
	-lt:小于
	-le:小于等于
[root@server0 /]# [ 1 -eq  1 ]
[root@server0 /]# echo $?

[root@server0 /]# [ 1 -gt 2 ]
[root@server0 /]# echo $?

[root@server0 /]# [ 1 -gt 1 ]
[root@server0 /]# echo $?

[root@server0 /]# [ 1 -ge 1 ]
[root@server0 /]# echo $?

• 字符串比对
   ==: 字符串相等为真
   !=:字符串不相等为真

[root@server0 /]# [  root   ==  student  ]
[root@server0 /]# echo $?

[root@server0 /]# [  root   ==  root  ]
[root@server0 /]# echo $?

[root@server0 /]# [  $USER  ==  root  ]
[root@server0 /]# echo $?

[root@server0 /]# [  student  != root  ]
[root@server0 /]# echo $?

###################################################
if选择结构

if双分支

    if  [条件测试];then
               执行的语句01
     else
               执行的语句02
    fi

案例： 
          用户输入一个IP地址，判断本机是否可以与这个IP地址通信
          如果 可以通信，则输出   可以通信
          如果 不可以通信，则输出  不可以通信   
   
[root@server0 /]# vim  /root/ip.sh 
    #!/bin/bash
    read  -p  '请输入您要测试的IP地址:'     ip
    ping  -c  2  $ip  &>  /dev/null    read:为变量ip赋值
        
    if  [  $?  -eq  0 ];then
          echo $ip 可以通信
    else
          echo $ip 不可以通信   
    fi

案例：
       用户输入一个0到9之间数字，计算机随机产生一个0到9之间数字
       如果 用户输入数字与计算机随机产生数字相等，则输出 您猜对了
       如果 用户输入数字与计算机随机产生数字不相等，则输出 您猜错了

[root@server0 /]# vim /root/num.sh
    #!/bin/bash
    read  -p  '请输入一个0到9之间数字:'     num1
    num2=$[$RANDOM%10]     #随机产生一个0到9之间数字,赋值给num2
     
     if  [  $num2  -eq  $num1  ];then
            echo 您猜对了
       else
            echo 您猜错了
            echo 正确的数字为 $num2
     fi

#####################################################
if多分支处理

  if [条件测试1];then
     命令序列xx

  elif [条件测试2];then
     命令序列yy

  elif [条件测试3];then
     命令序列aa

  else
      命令序列zz
  fi

 案例：
         用户输入成绩：
            如果成绩大于等于90，则输出 优秀
            如果成绩大于等于80，则输出 良好
            如果成绩大于等于70，则输出 合格
            如果成绩大于等于60，则输出 仍需努力
            以上条件均不满足，则输出  在牛的肖邦，也弹不出哥的悲伤

[root@server0 /]# vim  /root/if03.sh
	#!/bin/bash
	read  -p  '请输入您的成绩:'      num
	if [  $num  -ge  90  ];then
	  echo  优秀
	elif  [  $num  -ge  80  ];then
	  echo  良好
	elif  [  $num  -ge  70  ];then
	  echo  合格
	elif  [  $num  -ge  60  ];then
	  echo  仍需努力
	else
	  echo  在牛的肖邦，也弹不出哥的悲伤
	fi

################################################
 
案例：
       用户输入一个0到9之间数字，计算机随机产生一个0到9之间数字
       如果 用户输入数字与计算机随机产生数字相等，则输出 您猜对了

       如果 用户输入数字比计算机随机产生数字大，则输出 您猜大了

       如果 用户输入数字比计算机随机产生数字小，则输出 您猜小了

[root@server0 /]# vim /root/num.sh
    #!/bin/bash
    read  -p  '请输入一个0到9之间数字:'     num1
    num2=$[$RANDOM%10]    
     
     if  [  $num2  -eq  $num1  ];then
            echo 您猜对了
     elif  [  $num1  -gt  $num2  ];then
             echo 您猜大了
             echo 正确的数字为 $num2 
     else
             echo 您猜小了
             echo 正确的数字为 $num2 
     fi


案例：
   在上个案例的基础上，让用户可以猜三次

 #!/bin/bash
 num2=$[$RANDOM%10]
 for  i   in   {1..5}
 do
 read  -p  '请输入一个0到9之间数字:'     num1

 if  [  $num2  -eq  $num1  ];then
       echo 您猜对了
       exit
 elif  [ $num1 -gt $num2 ];then
       echo 您猜大了
 else
       echo 您猜小了
 fi
 done




造数工具  {  起始..结尾 }
格式为{2..10} 中间两个点，不能改.大括号和数字见也不能有空格
{a..f}连续的英文字母也可以执行

for循环结构

• 给定一批对象,反复执行类似的操作

  for 变量名 in 值列表
  do
    命令序列
  done


[root@server0 /]# vim /root/for.sh
 #!/bin/bash
 for  a   in  zhangsan  lisi   wangwu 
 do
   useradd  $a  &>  /dev/null
   echo   $a创建成功
 done


######################################################

 循环内容可以于循环的列表值无关

[root@server0 /]# cat /root/for2.sh
#!/bin/bash
for i in 1 2 3
do
  echo hello
done


333333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333333
333333333333333333333333333333333333333333333333333333333333


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################
 >&2 ： 将正确输出的信息，信息的性质改为错误，输出信息内容不变原样输出

案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者
fedora时,其错误输出产生以下信息:   /root/foo.sh redhat|fedora

[root@server0 ~]# vim /root/foo.sh 
 #!/bin/bash
 if [  $#  -eq  0  ];then
   echo  '/root/foo.sh  redhat|fedora'  >&2 
     #将正确输出变成错误输出
     exit  3
 elif [  $1  ==  redhat  ];then
   echo fedora

 elif  [  $1  ==  fedora  ];then
   echo redhat

 else
   echo  '/root/foo.sh  redhat|fedora'  >&2
     exit 4
 fi

###################################################
案例5:编写一个批量添加用户脚本

在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示 
Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
 http://classroom.example.com/pub/materials/userlist


[root@server0 /]# vim  /root/userlist 
zhangsan
lisi
wangwu 
dc
tc

[root@server0 /]# vim  /root/batchusers
 #!/bin/bash
 for i  in  `cat  /root/userlist`   `` 或 $() 将命令的输出结果作为
 do                                          参数输出
  useradd $i
  echo $i创建成功
 done


[root@server0 /]# vim  /root/batchusers
#!/bin/bash
if  [ -f $1 ];then
for i  in  `cat  $1`
do
 useradd $i 2> /dev/null
 echo $i创建成功
done
else
   echo Input file not found  >&2
   exit 2
fi



[root@server0 /]# vim  /root/batchusers
	#!/bin/bash
	if [ $# -eq 0 ];then        #判断是否输入参数
		 echo 'Usage: /root/batchusers' >&2
		 exit 3

	elif  [ -f $1 ];then        #判断文件是否存在

		for i  in  `cat  $1`
		do
		 useradd -s /bin/false $i 2> /dev/null
		 echo $i创建成功
		done

	else
		   echo Input file not found   >&2
		   exit 2
	fi

######################################################

系统安全保护

SELinux安全机制

• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系


• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

–  变成disabled(彻底禁用)状态，都需要重起机器


• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件


虚拟机Server
[root@server0 /]# getenforce       #查看当前的状态
Enforcing
[root@server0 /]# setenforce 0     #当前修改为Permissive
[root@server0 /]# getenforce 
Permissive
[root@server0 /]# vim /etc/selinux/config#每次开机状态配置文件
SELINUX=permissive

虚拟机Desktop
[root@desktop0 /]# getenforce 
Enforcing
[root@desktop0 /]# setenforce 0
[root@desktop0 /]# getenforce 
Permissive
[root@desktop0 /]# vim /etc/selinux/config
SELINUX=permissive
#####################################################

配置用户环境,永久别名的设置

• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效


• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

虚拟机server：

[root@server0 /]# vim /root/.bashrc   #针对于root生效
alias hello='echo hello'

[root@server0 /]# vim /home/student/.bashrc  #针对于student
alias hi='echo hi'

[root@server0 /]# vim /etc/bashrc   #针对于所有用户
alias haxi='echo hahaxixi'

再开一个新的终端验证
root用户能够执行：hello、haxi

student用户能够执行：hi、haxi

######################################################
配置IPv6地址

     IP地址：唯一标识网络中一台主机

 IPv4地址:  32个二进制组成   以点分隔4部分  最终用4个十进制数表示


 IPv6地址:  128个二进制组成  以 冒号 分隔8部分  最终用4个16进制数表示

   每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::




为两个虚拟机的接口 eth0 配置下列 IPv6 地址
– server0 上的地址应该是 2003:ac18::305/64

虚拟机Server0
[root@server0 ~]# nmcli connection modify 'System eth0' ipv6.method manual ipv6.addresses 2003:ac18::305/64 connection.autoconnect yes

[root@server0 ~]# nmcli connection up 'System eth0'

[root@server0 ~]# ifconfig | less

[root@server0 ~]# ping6 2003:ac18::305

######################################################
配置聚合连接(链路聚合  网卡绑定  网卡组队  )
      
      解决网卡的单点故障
      网卡设备热备份       

• team,聚合连接(也称为链路聚合)
– 由多块网卡(team-slave)一起组建而成的虚拟网卡,即“组队”

– 作用:热备份(activebackup)连接冗余
 1.创建虚拟网卡,参考 man teamd.conf  # /example  全文搜索example
# nmcli  connection  add  type  team     
 con-name  team0  ifname  team0  autoconnect  yes          
 config  '{"runner": {"name": "activebackup"}}'

# nmcli  connection 添加    类型    组队
  配置文件的名字为  team0  ifconfig显示名字为  team0  每次开机自启动
  工作模式配置  热备份方式

# ifconfig  查看team0网卡
#  nmcli connection delete team0   #删除

2.添加成员
# nmcli connection add type team-slave 
con-name team0-1 ifname  eth1   master team0

# nmcli connection add  type team-slave 
con-name team0-2 ifname  eth2  master team0

# nmcli connection 添加   类型    组队-奴隶
  配置文件名 team0-1  网卡名为 eth2  主设备为  team0

删除的配置
# nmcli connection delete team0-1  
# nmcli connection delete team0-2

3.配置IP地址
# nmcli connection modify team0          
  ipv4.method manual ipv4.addresses 192.168.1.1/24     
  connection.autoconnect  yes

4.激活所有配置
[root@server0 ~]# nmcli connection up team0
[root@server0 ~]# nmcli connection up team0-1
[root@server0 ~]# nmcli connection up team0-2

[root@server0 ~]# teamdctl team0 state   #查看team0信息
 
#####################################################
[root@server0 ~]# ifconfig  eth1   down    #禁用网卡
[root@server0 ~]# teamdctl  team0  state

####################################################
搭建基本Web服务

  Apache(httpd)  Nginx并发量    TOMCAT（Java）
  Nginx在并法量上比较优秀，对我国的现状，有取代Apache的可能

服务端虚拟机Server0：

1.安装一个httpd软件    Apache(httpd)  
[root@server0 ~]# yum  -y  install  httpd

2.重起服务即可
[root@server0 ~]# systemctl  restart httpd     

3.书写一个页面文件
   默认存放页面文件的路径：/var/www/html
   默认页面文件的名字： index.html
  html网页语言

[root@server0 ~]# vim /var/www/html/index.html
<h1><font color=red><marquee>NSD1805
最大字体   字体颜色          滚动


客户端：虚拟机Server0
[root@server0 ~]# firefox   172.25.0.11

#################################################

虚拟机Server0：搭建基本FTP服务(主要用于文件、数据传输)
1.安装一个vsftpd软件
[root@server0 ~]# yum -y install vsftpd

2.重起服务
[root@server0 ~]# systemctl  restart  vsftpd

3.测试：
[root@server0 ~]# firefox ftp://172.25.0.11

 默认vsftpd共享数据的路径：/var/ftp

#####################################################
防火墙
    作用：隔离  过滤所有入站请求，允许出站

    硬件防火墙 ~~~整个公司，大范围的


    软件防火墙 ～～软件，防护一台机器(firewalld)

RHEL7的防火墙体系(隔离)
• 系统服务:firewalld
• 管理工具:firewall-cmd（命令）、firewall-config（图形）

• 根据所在的网络场所区分,预设保护规则集 zone 区域
  – public:仅允许访问本机的sshd、ping、dhcp服务
  – trusted:允许任何访问
  – block:阻塞任何来访请求，明确拒绝
  – drop:丢弃任何来访的数据包，直接丢弃，节省资源

• 配置规则的位置
  – 运行时(runtime)
  – 永久(permanent

包：源ip地址   目标ip   数据  访问的端口号

######################################################



4444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444




真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
搭建基本Web服务

服务端虚拟机Server0：
1.安装一个httpd软件    Apache(httpd)  
[root@server0 ~]# yum  -y  install  httpd
2.重起服务即可
[root@server0 ~]# systemctl  restart httpd     

3.书写一个页面文件
   默认存放页面文件的路径：/var/www/html
   默认页面文件的名字： index.html

# echo '<h1>My First Web' > /var/www/html/index.html
# firefox 172.25.0.11

#################################################
虚拟机Server0：搭建基本FTP服务
1.安装一个vsftpd软件
[root@server0 ~]# yum -y install vsftpd

2.重起服务
[root@server0 ~]# systemctl  restart  vsftpd

3.测试：
[root@server0 ~]# firefox ftp://172.25.0.11

 默认vsftpd共享数据的路径：/var/ftp

#####################################################
防火墙
    作用：隔离  过滤所有入站请求，允许出站

    硬件防火墙

    软件防火墙

RHEL7的防火墙体系
• 系统服务:firewalld
• 管理工具:firewall-cmd（命令）、firewall-config（图形）

• 根据所在的网络场所区分,预设保护规则集 zone 区域
  – public:仅允许访问本机的sshd、ping、dhcp服务
  – trusted:允许任何访问
  – block:阻塞任何来访请求，明确拒绝
  – drop:丢弃任何来访的数据包，直接丢弃，节省资源

防火墙判断的规则： 匹配及停止
1.首先看客户端请求中源IP地址,查阅自己所有的区域，那个区域中有对此源IP地址的规则，则进入该区域

2.进入默认区域（public）
                                                             永久(permanent)
######################################################
默认区域的应用

虚拟机server0
# firewall-cmd --get-default-zone   #查看默认区域
虚拟机desktop0
# ping  172.25.0.11  #可以通信

虚拟机server0
# firewall-cmd --set-default-zone=block   #修改默认区域
# firewall-cmd --get-default-zone 
虚拟机desktop0
# ping  172.25.0.11  #不可以通信，有回应

虚拟机server0
# firewall-cmd --set-default-zone=drop    #修改默认区域
# firewall-cmd --get-default-zone 
虚拟机desktop0
# ping  172.25.0.11  #不可以通信，没有回应
####################################################
服务的添加
虚拟机server0：
# firewall-cmd --set-default-zone=public 
# firewall-cmd --zone=public --list-all
# firewall-cmd --zone=public --add-service=http
# firewall-cmd --zone=public --list-all
虚拟机desktop0:
#  firefox 172.25.0.11        #可以访问
#  firefox ftp://172.25.0.11  #不可以访问

虚拟机server0：
# firewall-cmd --zone=public --add-service=ftp
# firewall-cmd --zone=public --list-all
虚拟机desktop0:
#  firefox 172.25.0.11        #可以访问
#  firefox ftp://172.25.0.11  #可以访问

######################################################
实现永久设置规则

 – 永久(permanent)
# firewall-cmd --reload        #重新加载防火墙配置
# firewall-cmd --zone=public --list-all 

# firewall-cmd --permanent --zone=public --add-service=http
# firewall-cmd --reload 
# firewall-cmd --zone=public --list-all 

# firewall-cmd --permanent --zone=public --add-service=ftp
# firewall-cmd --reload 
# firewall-cmd --zone=public --list-all 
#####################################################
 常见服务：
         http:   超文本传输协议           默认的端口号：80
         https:  安全超文本传输协议   默认的端口号：443
         DNS:    域名解析                     默认的端口号：53
         telnet： 远程管理               默认的端口号：23
         FTP：   文件传输协议              默认的端口号：21
         tftp：  简单文件传输协议       默认的端口号：69
         SMTP：  邮件协议，发邮件      默认的端口号：25
         pop3：  邮件协议，收邮件      默认的端口号：110
         SNMP：  简单网络管理协议      默认的端口号：161


  端口号：标识服务，标识程序

###################################################

实现本机的端口映射
• 本地应用的端口重定向(端口1 --> 端口2)
– 从客户机访问 端口1 的请求,自动映射到本机 端口2
– 比如,访问以下两个地址可以看到相同的页面:
 http://172.25.0.11:5423/--> http://172.25.0.11:80/

虚拟机server0：
# firewall-cmd --permanent --zone=public 
--add-forward-port=port=5423:proto=tcp:toport=80

# firewall-cmd  --reload 
# firewall-cmd  --zone=public --list-all 

虚拟机desktop0：
# firefox  172.25.0.11:5423

######################################################
删除：

# firewall-cmd --permanent --zone=public 
--remove-forward-port=port=5423:proto=tcp:toport=80
# firewall-cmd  --reload

#####################################################
首先修改防火墙默认区域

虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

######################################################
Samba服务基础～～～～～～反向编译的思想（windows）跨平台的软件

– 用途:为客户机提供共享使用的文件夹 (跨平台的共享,Windows与Linux）

• 所需软件包:samba
• 系统服务:smb
– 协议:SMB(TCP 139)、    CIFS(TCP 445)
       服务端-客户端沟通         传输数据
管理共享账号
• Samba用户 —— 专用来访问共享文件夹的验证用户
– 采用独立设置的密码
– 但需要提前建立同名的系统用户(可以不设密码)

• 使用 pdbedit 管理工具
– 添加用户:pdbedit -a 用户名
– 查询用户:pdbedit -L [用户名]
– 删除用户:pdbedit -x 用户名

配置文件及参数
• 修改 /etc/samba/smb.conf
[global]
//全局设置
workgroup = 工作组名

[自定共享名]
path = 文件夹绝对路径





服务端：虚拟机Server0：
1.安装samba软件
[root@server0 ~]# yum -y install samba

2.建立Samba共享帐号                  不能登陆操作系统
[root@server0 ~]# useradd -s /sbin/nologin harry
[root@server0 ~]# useradd -s /sbin/nologin kenji
[root@server0 ~]# useradd -s /sbin/nologin chihiro

[root@server0 ~]# pdbedit -a harry    #添加harry为共享帐号
[root@server0 ~]# pdbedit -a kenji    #根据提示设置2次密码
[root@server0 ~]# pdbedit -a chihiro

[root@server0 ~]# pdbedit -L    #查看所有共享帐号

3.修改 /etc/samba/smb.conf主配置文件

  -发布目录  /common ,共享名为 common

[root@server0 ~]# mkdir  /common
[root@server0 ~]# echo 123  > /common/1.txt
[root@server0 ~]# ls  /common/

补充：vim 命令模式下   按G（大写）到全文的最后一行
[root@server0 ~]# vim  /etc/samba/smb.conf 

        workgroup = STAFF   #修改工作组 （可忽略不写，仅作了解）

[common]
path = /common

4.重起smb服务
[root@server0 ~]# systemctl restart smb
[root@server0 ~]# systemctl enable smb   #设置为开机自启动

5.SELinux策略修改，布尔值功能的开关
   – 需要加 -P 选项才能实现永久设置(需要内存支持)

 # getsebool -a | grep samba   #查看所有布尔值

 # setsebool samba_export_all_ro on  #允许所有人只读访问samba
 # getsebool -a | grep samba


客户端：虚拟机desktop0
1. 所需软件包:samba-client(客户端软件)～仅初次看samba用一下，都不用

2.利用smbclient 访问
[root@desktop0 ~]# smbclient -L  //172.25.0.11/  #列出共享

[root@desktop0 ~]# smbclient -U harry //172.25.0.11/common
Enter harry's password: 
smb: \> 

#######################################################
客户端访问服务端：
   1.服务端 防火墙的配置
   2.服务端 SELinux策略      三大策略1，布尔值  2，？ 3，？
   3.服务端 服务本身的访问控制
   4.服务端 本地目录权限



#################################################
通过挂载，更加科学方便的访问Samba共享

虚拟机desktop0
1.安装cifs-utils软件包（支持cifs协议）
[root@desktop0 ~]# yum -y install cifs-utils

2.进行挂载
[root@desktop0 ~]# mkdir /mnt/nsd01

# mount -o user=harry,pass=123 //172.25.0.11/common  /mnt/nsd01/ 

[root@desktop0 ~]# df -h
[root@desktop0 ~]# ls /mnt/nsd01

3.开机自动挂载samba共享/etc/fstab

   _netdev:声明网络设备
     在开机启动时，该设备为网络设备，请先部署网络所有服务，具备网络参数(ip地址)后，再挂载此设备
                    （文件名）
 //172.25.0.11/common   /mnt/nsd01  cifs
 defaults,user=harry,pass=123,_netdev  0  0

[root@desktop0 ~]# umount /mnt/nsd01
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount  -a
[root@desktop0 ~]# df -h

######################################################
搭建读写的Samba共享

服务端：虚拟机Server0

1.修改配置文件/etc/samba/smb.conf
[root@server0 ~]# mkdir /devops
[root@server0 ~]# echo haha > /devops/2.txt
[root@server0 ~]# ls /devops/

[root@server0 ~]# vim  /etc/samba/smb.conf   #追加写入
......
[devops]                  #共享名
path = /devops            #共享实际路径
write list = chihiro      #允许chihiro可以写

2.重起smb服务
[root@server0 ~]# systemctl restart smb

3.修改SELinux策略
[root@server0 ~]# getsebool -a | grep samba
[root@server0 ~]# setsebool samba_export_all_rw on
[root@server0 ~]# getsebool -a | grep samba

4.赋予chihiro本地目录权限

[root@server0 ~]# setfacl -m u:chihiro:rwx /devops
[root@server0 ~]# getfacl /devops

客户端：虚拟机Desktop0
1.实现开机自动挂载
[root@desktop0 ~]# vim /etc/fstab 

 //172.25.0.11/devops  /mnt/nsd02   cifs 
 defaults,user=chihiro,pass=123,_netdev 0 0

[root@desktop0 ~]# mount  -a 
[root@desktop0 ~]# df  -h

#####################################################
multiuser机制,主要为普通用户设计

多用户Samba挂载
   客户端以权限较小的用户验证samba共享
   在必要的时候普通用户，可以通过命令更改验证用户身份，获得写入权限


• mount.cifs 的挂载参数
– multiuser,提供对客户端多个用户身份的区分支持
– sec=ntlmssp,提供NT局域网管理安全支持

[root@desktop0 ~]# vim /etc/fstab 

//172.25.0.11/devops /mnt/nsd02 cifs defaults,user=kenji,pass=123,_netdev,multiuser,sec=ntlmssp  
  0 0

[root@desktop0 ~]# umount /mnt/nsd02

[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
[root@desktop0 ~]# su - student
[student@desktop0 ~]$ cd /mnt/nsd02

$ cifscreds  add  -u  chihiro    172.25.0.11
Password: 

[student@desktop0 nsd02]$ touch 66.txt
[student@desktop0 nsd02]$ exit

#####################################################



55555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555


classroom   WEB服务端装包讲解

真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
防火墙：
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

#####################################################

iSCSI网络磁盘

一、进行分区
[root@server0 ~]# lsblk             #查看当前所有硬盘
[root@server0 ~]# fdisk /dev/vdb
  3G的主分区    2G主分区   1G主分区
    划分扩展分区
  1G逻辑分区

[root@server0 ~]# partprobe         #刷新分区
[root@server0 ~]# ls /dev/vdb*

iSCSI磁盘的工作模式
• Internet SCSI,网际SCSI接口
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

iqn名字的作用：
– 用来识别 target 磁盘组,也用来识别客户机身份


iSCSI磁盘的构成

• backstore,后端存储     冰箱----->纸箱子(名字)
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称

• target,磁盘组        木质箱子
– 是客户端的访问目标,作为一个框架,由多个lun组成
   
• lun,逻辑单元       【冰箱----->纸箱子】--- 放入---【木质箱子】
– 每一个lun需要关联到某一个后端存储设备,在客户端会视为一块虚拟硬盘

二、虚拟机server0，构建iSCSI共享存储服务端

1.安装软件包:targetcli
2.运行 targetcli  进入iSCSI共享存储配置

3.建立后端存储
  格式：后端存储/块设备   创建    名字       具体设备
  
/> backstores/block  create  name=nsd  dev=/dev/vdb1

/> ls    #查看创建效果
 
4.建立target,磁盘组 （木质箱子）
• ISCSI Qualified Name 名称规范（iqn）
– iqn.yyyy-mm.倒序域名:自定义标识
/> iscsi/ create iqn.2018-06.example.com:server0
/> ls

5. lun,关联  [冰箱----->纸箱子]---【放入】---[木质箱子]
/> iscsi/iqn.2018-06.example.com:server0/tpg1/luns      
   create /backstores/block/nsd 
/> ls
6.开启服务监听的端口，开启监听的本机IP地址
[root@server0 ~]# targetcli 

/> iscsi/iqn.2018-06.example.com:server0/tpg1/portals 
   create  172.25.0.11
/> ls
      iSCSI共享存储默认端口： 3260

7.配置访问控制ACL，设置客户端声称名字

/> iscsi/iqn.2018-06.example.com:server0/tpg1/acls create  
   iqn.2018-06.example.com:desktop0
/> ls
/> exit

iqn名字的作用：
– 用来识别 target 磁盘组,也用来识别客户机身份

8.重起服务
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable  target

##################################################
客户端：虚拟机desktop0

1.安装软件包
[root@desktop0 ~]# yum repolist     #产生Yum的缓存
[root@desktop0 ~]# yum -y install iscsi(tab)
[root@desktop0 ~]# yum -y install iscsi-initiator-utils
                                    #iscsi启动软件包
2.修改配置文件，指定客户端声称的名字
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2018-06.example.com:desktop0

3.重起iscsid服务，仅仅就是刷新iqn名称
[root@desktop0 ~]# systemctl restart iscsid
Warning: Unit file of iscsid.service changed on disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload 
                                       #守护进程-重新安装sicsi服务
[root@desktop0 ~]# systemctl restart iscsid

4.发现服务端共享存储 参考：man  iscsiadm
     ctrl shift + :变大
     ctrl  -  :变小
# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

5.重起iscsi服务,将共享存储加载到本机

# lsblk
# systemctl  restart  iscsi
# lsblk   #可以看到sda

######################################################
数据库服务基础

什么是数据库：存放数据的仓库

  数据库中有很的库，在库里面有很多的表格
 
  表字段 、表记录


部署mariadb数据库服务器
• RHEL7 中的 MariaDB 相关包
– mariadb-server:提供服务端有关的系统程序
– MariaDB默认端口号：3306
– 数据库主配置文件：/etc/my.cnf

一、部署mariadb数据库服务器
1.安装mariadb-server
[root@server0 ~]# yum -y install mariadb-server

2.启动mariadb服务
[root@server0 ~]# systemctl  restart  mariadb
[root@server0 ~]# systemctl  enable  mariadb


二、使用数据库
    默认无需密码直接登陆

[root@server0 ~]# mysql
  > show  databases;    #查看所有的库
  > create  database  nsd1805;  #创建库nsd1805
  > show  databases;    #查看所有的库

  > drop  database  nsd1805;  #删除nsd1805库
  > show  databases;    #查看所有的库

  > create  database  nsd;  #创建库nsd
  > show  databases;    #查看所有的库
  > exit
Bye

三、为数据库管理员 账号修改密码
– mysqladmin [-u用户名]  [-p[旧密码]]  password  '新密码'

  数据库管理员：root 数据库最高权限用户   由数据库mysql库user表保存

  系统管理员：root 系统最高权限用户    /etc/passwd

[root@server0 ~]# mysqladmin -u root password '123'

[root@server0 ~]# mysql -u root -p
Enter password: 

[root@server0 ~]# mysql -u root -p123   #非交互式

四、导入数据库的数据

# wget http://classroom.example.com/pub/materials/users.sql
# ls 

[root@server0 ~]# mysql -u root -p123

MariaDB [(none)]> show databases;
MariaDB [(none)]> exit

[root@server0 ~]# mysql -u root -p123 nsd < users.sql
                将users.sql的数据导入到nsd库中
 
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;     #切换nsd库
MariaDB [nsd]> show tables;    #查看所有表格

###################################################
五、表格操作   增(insert)    删(delete)      改(update)     查(select)

select 表字段  from  表名

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;     #切换nsd库
MariaDB [nsd]> show tables;    #查看所有表格

MariaDB [nsd]> select  *  from base;
MariaDB [nsd]> select  *  from location;

MariaDB [nsd]> desc base;   #查看表结构

MariaDB [nsd]> select id,password from base;
MariaDB [nsd]> select id,name from base;

MariaDB [nsd]> use mysql;
MariaDB [nsd]> desc user;  
MariaDB [nsd]> select  user,host,password  from  user; 

六、数据库授权

– 除了root用户,此nsd数据库只能被用户lisi查询,此用户的密码为123
– 不需要创建本地用户lisi

– GRANT 权限列表  ON 数据库名.表名 TO 用户名@客户机地址
 IDENTIFIED BY '密码';

  grant select on  nsd.*  to  lisi@localhost 
  identified by '123';

  当lisi从localhost本地登陆输入密码123，将会获得nsd数据库中所有表的查询权限

[root@server0 ~]# mysql -u root -p123

MariaDB [(none)]> grant select on nsd.* to lisi@localhost  identified by  '123';


    > select user,host,password from mysql.user;




七、多表查询，有条件的查询，表记录的删出及增加
2. 在系统 server0 上使用数据库 nsd,并使用相
应的 SQL 查询以回答下列问题:
1)密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;
MariaDB [nsd]> select * from base  where password='solicitous';

MariaDB [nsd]> select name from base  where password='solicitous';

MariaDB [nsd]> select id,name from base  where password='123';

MariaDB [nsd]> select * from base  where name='tom';


2)有多少人的    姓名是 Barbara 同时居住在 Sunnyvale?
      
> select * from base,location    
 where  base.name='Barbara'  and                
 location.city='Sunnyvale'   and                
 base.id=location.id;

> select count(*) from base,location     
 where base.name='Barbara' and                
 location.city='Sunnyvale' and    
 base.id=location.id;              

MariaDB [nsd]> insert base values('6','Barbara','678');
MariaDB [nsd]> select * from base;
MariaDB [nsd]> insert location values('6','Sunnyvale');
MariaDB [nsd]> select * from location;


3. 禁止空密码 root用户访问 mariadb 数据库
[root@server0 ~]# mysql -u root -p123

MariaDB [nsd]> use mysql;

MariaDB [mysql]> select user,host,password from user;

MariaDB [mysql]> select user,host,password from user   where password='';

MariaDB [mysql]> delete from user where password='';

MariaDB [mysql]> select user,host,password from user;

MariaDB [mysql]> flush privileges;   #刷新user表记录


[root@server0 ~]# mysql -u root -h server0.example.com
  最终登陆失败

#####################################################
 



66666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
防火墙：
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

#####################################################
HTTP服务基础

• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页
 
• Hyper Text Markup Language(html),超文本标记语言
• Hyper Text Transfer Protocol(http),超文本传输协议

                                           Ddos(攻击)
                                               并发攻击的一种手段（访问量）
• 软件包:httpd
• 系统服务:httpd

• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)
– DirectoryIndex:起始页/首页文件名(index.html)


##################################################
虚拟机server0
1.安装httpd软件（Apache一个基金会公司的名字，曾经http服务 由Apache构     建而出名）

2.书写网页文件
# echo '<h1>NSD1805' > /var/www/html/index.html

3.重起httpd服务
# systemctl restart httpd


虚拟机desktop0
访问测试: # firefox 172.25.0.11

################################################

ServerName:本站点注册的DNS名称(空缺)

 DNS服务器:classroom.example.com

   server0.example.com
   www0.example.com
   webapp0.example.com

虚拟机Server0
1.修改配置文件
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
ServerName server0.example.com:80   #注释去掉,修改内容

2.重起httpd服务
[root@server0 ~]# systemctl restart httpd

虚拟机desktop0
访问测试: # firefox server0.example.com

#####################################################
[root@server0 ~]# systemctl restart httpd
Job for httpd.service failed. See 'systemctl status httpd.service' and 'journalctl -xn' for details.
重起服务失败




– DocumentRoot:网页文件根目录(默认为/var/www/html)
   
虚拟机server0
# mkdir /var/www/myweb
# echo '<h1>wo shi myweb' > /var/www/myweb/index.html

# vim /etc/httpd/conf/httpd.conf 

DocumentRoot  "/var/www/myweb"

# systemctl restart httpd

虚拟机desktop0
[root@server0 ~]# firefox server0.example.com

################################################
客户端浏览器路径与服务端真实路径的对照

客户端浏览器: firefox server0.example.com/test/

服务端路径:  /var/www/myweb/test/

######################################################
• 配置文件路径
– /etc/httpd/conf/httpd.conf   #主配置文件
– /etc/httpd/conf.d/*.conf     #调用配置文件

虚拟Web主机

• 虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

• 为每个虚拟站点添加配置,容器类型的配置
	<VirtualHost  IP地址:端口>
	  ServerName  此站点的DNS名称
	  DocumentRoot  此站点的网页根目录
     </VirtualHost>


虚拟机Server0:
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName  www0.example.com
  DocumentRoot  /var/www/qq 
</VirtualHost>

<VirtualHost *:80>
  ServerName  webapp0.example.com
  DocumentRoot /var/www/sina
</VirtualHost>

<VirtualHost *:80>
  ServerName server0.example.com
  DocumentRoot /var/www/myweb
</VirtualHost>

[root@server0 /]# mkdir /var/www/qq  /var/www/sina
[root@server0 /]# echo '<h1>企鹅' > /var/www/qq/index.html
[root@server0 /]# echo '<h1>新浪' > /var/www/sina/index.html
[root@server0 /]# systemctl restart httpd

	
   一旦使用虚拟Web主机功能,所有的Web站点都必须用虚拟Web主机来实现

#######################################################
访问控制

• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置


<Directory 目录的绝对路径>
.. ..
Require all denied|granted
Require ip IP或网段地址 .. ..
</Directory>


案例:
在 Web 网站 http://server0.example.com 的
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:
仅允许本机访问

虚拟机Server0:
# mkdir /var/www/myweb/private
# echo '<h1>woshi private' > /var/www/myweb/private/index.html

# vim /etc/httpd/conf.d/nsd02.conf 
<Directory  "/var/www/myweb/private">
    Require ip 172.25.0.11   #仅允许172.25.0.11
</Directory>
 
# systemctl  restart   httpd

虚拟机desktop0:
# firefox server0.example.com/private   #访问权限不足
虚拟机server0:
# firefox server0.example.com/private   #访问成功
#######################################################


案例:使用自定Web网页文件的根目录
调整 Web 站点 http://server0.example.com 的网页目录
要求如下:

虚拟机Server0:
1)新建目录 /webroot,作为此站点新的网页目录

# mkdir /webroot
# echo '<h1>wo shi webroot' > /webroot/index.html
# ls /webroot

2)修改配置文件/etc/httpd/conf.d/nsd01.conf  #修改不是追加
 <VirtualHost *:80>
   ServerName server0.example.com
   DocumentRoot /webroot
 </VirtualHost>

3)修改配置文件/etc/httpd/conf.d/nsd02.conf  #添加访问控制
 <Directory "/webroot">
     Require all granted       #允许所有客户端
 </Directory>

4)重起httpd服务
[root@server0 /]# systemctl restart httpd


5)修改SELinux策略,安全上下文值(标签值:标识作用)
   以/var/www 为模版修改/webroot/的标签值

 # ls -Zd  /var/www    #专业查看SELinux安全上下文值
 # ls -Zd  /webroot    #专业查看SELinux安全上下文值
 
 # chcon -R  --reference=/var/www    /webroot/

 # ls -Zd /webroot/

虚拟机desktop0:
# firefox  server0.example.com   #访问成功


####################################################
客户端访问服务端:
    1.服务本身的访问控制
    2.防火墙的访问控制
    3.本地目录访问控制
  4.SELinux的访问控制

####################################################

部署动态网站


静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源

动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
–  由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......

虚拟机server0:

1.部署Python的网页文件
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName  webapp0.example.com
  DocumentRoot  /var/www/sina
</VirtualHost>

[root@server0 /]# cd /var/www/sina

 wget  http://classroom.example.com/pub/materials/webinfo.wsgi

2.方便用户访问webinfo.wsgi网页文件
  
  网页跳转(网页文件的别名)

[root@server0 sina]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/sina
  Alias  /    /var/www/sina/webinfo.wsgi
#当客户端访问到网页文件根目录时,将/var/www/sina/webinfo.wsgi呈现

</VirtualHost>

[root@server0 ]# systemctl  restart  httpd
[root@server0 ]# firefox webapp0.example.com

3.翻译Python页面
[root@server0 ]# yum -y install mod_wsgi (解释Python页面软件)
[root@server0 ]# vim /etc/httpd/conf.d/nsd01.conf

<VirtualHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/sina
  WsgiScriptAlias /   /var/www/sina/webinfo.wsgi

</VirtualHost>

[root@server0 ]# systemctl restart httpd
[root@server0 ]# firefox webapp0.example.com

 UNIX时间戳:自1970-1-1  0时0分0秒到现在时间,所有经历的总的秒数

4.此虚拟webapp0.example.com主机侦听在端口8909
[root@server0 /]# vim  /etc/httpd/conf.d/nsd01.conf 
Listen  8909
<VirtualHost  *:8909>
  ServerName  webapp0.example.com
  DocumentRoot  /var/www/sina
  WsgiScriptAlias  /   /var/www/sina/webinfo.wsgi
</VirtualHost>

5.SELinux限制所有非默认的端口开放 (布尔值   安全上下文值)
# semanage  port  -l | grep  http
# semanage  port  -a  -t  http_port_t  -p tcp 8909
    -a:添加     -t:类型    -p:协议
# semanage  port -l  |  grep  http      #-l:列出
         
6.重起httpd服务 
[root@server0 /]# systemctl restart httpd
[root@server0 ~]# firefox webapp0.example.com:8909

####################################################



77777777777777777777777777777777777777777777777777777777777777
7777777777777777777777777777777777777777777777777777777777777
77777777777777777777777777777777777777777777777777777777777777


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
防火墙：
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

#####################################################
安全Web服务,实现https(安全的超文本传输协议)加密传输

– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

搭建虚拟Web主机
1.安装软件包httpd

2.修改配置文件
# vim /etc/httpd/conf.d/nsd01.conf
 <VirtualHost  *:80>
   ServerName www0.example.com
   DocumentRoot /var/www/html
 </VirtualHost>

# echo '<h1>NSD test' > /var/www/html/index.html
# systemctl  restart  httpd

#####################################################
部署安全的Web服务器,端口默认:443

1.安装软件包,支持安全Web服务器
[root@server0 ~]# yum -y install  mod_ssl

2.部署网站证书(营业执照)
# cd /etc/pki/CA/certs/
# wget  http://classroom.example.com/pub/tls/certs/server0.crt

# ls

3.部署根证书(公安局信息)
# cd /etc/pki/CA/certs/
# wget  http://classroom.example.com/pub/example-ca.crt

# ls

4.部署解密的私钥
# cd /etc/pki/CA/private/
# wget http://classroom.example.com/pub/tls/private/server0.key

# ls

5.修改配置文件/etc/httpd/conf.d/ssl.conf
# vim /etc/httpd/conf.d/ssl.conf
 在末行模式下  :set  nu   #显示全文行号
    
 59  DocumentRoot "/var/www/html"
 60  ServerName www0.example.com:443

指定网站证书
100 SSLCertificateFile /etc/pki/CA/certs/server0.crt

指定私钥
107 SSLCertificateKeyFile /etc/pki/CA/private/server0.key

指定根证书
122 SSLCACertificateFile /etc/pki/CA/certs/example-ca.crt

6.重起httpd服务
[root@server0 /]# systemctl  restart  httpd

7.验证:
[root@server0 /]# firefox https://www0.example.com  
网站地址处有一个小锁，由https开头。证明已经成功了
#######################################################
基础邮件服务
• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱          
                                                                                       	
  DNS服务器: classroom.example.com

            server0.example.com

虚拟机Server0:部署邮件服务

1.创建两个邮箱帐号
[root@server0 /]# useradd yg
[root@server0 /]# useradd xln

2.安装邮件功能的软件
[root@server0 /]# rpm -q postfix

3.修改配置文件/etc/postfix/main.cf

 99  myorigin = server0.example.com   #默认补全邮箱域名后缀
 116 inet_interfaces = all            #允许本机所有网络接口
 164 mydestination = server0.example.com 
                                               #根据本字段值,判断为本域邮件

4.重起服务
[root@server0 /]# systemctl restart postfix

###################################################
收发邮件:

• mail 发信操作
– mail -s '邮件主题'     -r  发件人      收件人

• mail 收信操作
– mail [-u 用户名]

[root@server0 /]# mail -s 'test1'   -r  yg   xln
AAAAAAAAAAAA
hahaxixi
.                  #只有一个点,提交

[root@server0 /]# mail -u xln
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/mail/xln": 2 messages
>   1 yg@server0.example.c  Fri Jun 15 14:30  19/606   
 
&  1         #输入编号

& quit   #退出

[root@server0 /]# echo haha | mail -s 'test01' -r yg  xln

#######################################################
parted分区命令,可以划分GPT分区模式

   GPT分区模式:    128个主分区       18EB容量

                1EB=1000PB
                1PB=1000TB                        
     

[root@server0 /]# parted /dev/vdb
(parted) mktable  gpt      #指定分区模式
(parted) print             #输出分区表信息
(parted) mkpart            #划分新的分区
分区名称？  []? haha          #分区名子,随便起
文件系统类型？  [ext2]? ext4   #指定分区文件系统类型,不起作用
起始点？ 0           
结束点？ 2G
忽略/Ignore/放弃/Cancel? Ignore    #忽略
(parted) unit GB                 #使用GB作为显示单位
(parted) mkpart 
分区名称？  []? haha
文件系统类型？  [ext2]? ext4
起始点？ 2G          
结束点？ 4G 
(parted) quit                     #退出
[root@server0 /]#

####################################################
交换空间,虚拟内存

– 当物理内存不够用时,使用磁盘空间来模拟内存
– 在一定程度上缓解内存不足的问题
– 交换分区:以空闲分区充当的交换空间


1.格式化, 交换文件系统
[root@server0 ~]# mkswap  /dev/vdb1  

2.启用交换分区
[root@server0 ~]# swapon  /dev/vdb1  

3.查看交换空间组成的成员
[root@server0 ~]# swapon -s

[root@server0 ~]# mkswap   /dev/vdb2  
[root@server0 ~]# swapon   /dev/vdb2
[root@server0 ~]# swapon  -s
[root@server0 ~]# swapoff  /dev/vdb2     #停用
[root@server0 ~]# swapon  -s

5.开机自动启用交换分区
[root@server0 ~]# vim /etc/fstab 
/dev/vdb1  swap  swap  defaults  0 0
/dev/vdb2  swap  swap  defaults  0 0

[root@server0 ~]# swapoff /dev/vdb1
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s
[root@server0 ~]# swapon  -a   #专用于检测交换分区命令
[root@server0 ~]# swapon -s

###################################################
配置NFS共享, Linux与Linux之间的共享
NFS共享概述
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)  RPC(TCP/UDP 111)

• 所需软件包:nfs-utils
• 系统服务:nfs-server

搭建基本的NFS共享
虚拟机server0
1.安装nfs-utils包
[root@server0 ~]# yum -y install nfs-utils

2.修改配置文件/etc/exports
[root@server0 ~]# mkdir /test
[root@server0 ~]# echo haha > /test/1.txt
[root@server0 ~]# vim /etc/exports
/test     *(ro)

3.重起nfs-server服务
[root@server0 ~]# systemctl restart nfs-server

虚拟机desktop0
客户端访问:
1.查看服务端NFS共享
[root@desktop0 ~]# showmount -e 172.25.0.11

2.挂载访问
[root@desktop0 ~]# mkdir /mnt/nfs
[root@desktop0 ~]# mount 172.25.0.11:/test  /mnt/nfs
[root@desktop0 ~]# df  -h

3.实现开机自动挂载
[root@desktop0 ~]# vim /etc/fstab 
172.25.0.11:/test  /mnt/nfs  nfs defaults,_netdev 0 0

[root@desktop0 ~]# umount /mnt/nfs
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
 




SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS








部署 网络服务进阶  教学环境

真机:快速产生两台虚拟机
[root@room9pc01 ~]# clone-vm7
 Enter VM number: 6
 Creating Virtual Machine disk image......	[OK]
 Defining new virtual machine......		     [OK]

 利用root用户,密码123456登陆两台虚拟机

虚拟机A:作为练习使用的服务端:
1.配置永久的主机名:svr7.tedu.cn
2.配置eth0永久的IP地址:192.168.4.7/24


虚拟机B:作为练习使用的客户端
1.配置永久的主机名:pc207.tedu.cn
2.配置eth0永久的IP地址:192.168.4.207/24
L
####################################################
搭建网络Yum仓库

1.真机构建FTP服务器,共享光盘所有内容
[root@room9pc01 ~]# rpm  -q  vsftpd
vsftpd-3.0.2-22.el7.x86_64
[root@room9pc01 ~]# systemctl restart vsftpd
[root@room9pc01 ~]# systemctl enable vsftpd

[root@room9pc01 ~]# ls /var/ftp/rhel7/   #查看是否有光盘内容

[root@room9pc01 ~]# ls -l /iso
lrwxrwxrwx 1 root root 27 1月  23 17:32 /iso -> /var/lib/libvirt/images/iso

[root@room9pc01 ~]# vim /etc/fstab      #不支持快捷方式
/var/lib/libvirt/images/iso/rhel-server-7.4-x86_64-dvd.iso   /var/ftp/rhel7   iso9660   defaults  0  0


[root@room9pc01 ~]# firefox ftp://192.168.4.254/rhel7
                                                ???
2.在两台虚拟机上操作,指定Yum服务端

[root@svr7 ~]# vim /etc/yum.repos.d/rhel7.repo
 [rhel7]
 name=rhel7.4
 baseurl=ftp://192.168.4.254/rhel7
 enabled=1
 gpgcheck=0

[root@svr7 ~]# yum repolist
[root@svr7 ~]# yum -y install xeyes

######################################################
进行远程管理,为真机永久的别名的设置

[root@room9pc01 ~]# vim /root/.bashrc 
alias  goa='ssh -X root@192.168.4.7'
alias  gob='ssh -X root@192.168.4.207'

#######################################################
目录结构

[root@svr7 ~]# man hier

 /boot 		      存放系统引导必需的文件,包括内核、启动配置
 /bin、/sbin        存放各种命令程	序
 /dev               存放硬盘、键盘、鼠标、光驱等各种设备文件
 /etc 		      存放Linux系统及各种程序的配置文件
 /root、/home/用户名  分别是管理员root、普通用户的默认家目录
 /var 		      存放日志文件、邮箱目录等经常变化的文件
 /proc 			  存放内存中的映射数据,不占用磁盘
 /tmp 			  存放系统运行过程中使用的一些临时文件

#####################################################
权限的数值表示

• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1

[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 755 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

################################################
历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令

• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000     //默认记录1000条


[root@svr7 ~]# history           #查看历史命令列表

[root@svr7 ~]# history -c        #清空历史命令
[root@svr7 ~]# history 

[root@svr7 ~]# cat /etc/redhat-release 

[root@svr7 ~]# ls /root/

[root@svr7 ~]# !cat     #执行历史命令中最近一条以cat开头的命令

[root@svr7 ~]# !ls


####################################################
• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -sh /boot/ /etc/pki/

#####################################################
• date,查看/调整系统日期时间

– date +%F、date +%R
– date +"%Y-%m-%d  %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"    #修改时间

[root@svr7 ~]# date  +%F
[root@svr7 ~]# date  +%Y
[root@svr7 ~]# date  +%m
[root@svr7 ~]# date  +%d
[root@svr7 ~]# date  +%H
[root@svr7 ~]# date  +%M

##################################################
快捷方式制作,必须是绝对路径

–  ln  -s  原始文件或目录    软连接文件

[root@svr7 ~]# ln -s /etc/redhat-release  /
[root@svr7 ~]# ls /

[root@svr7 ~]# ln -s /etc/redhat-release  /abc
[root@svr7 ~]# ls /

[root@svr7 ~]# ls -l /abc 
lrwxrwxrwx. 1 root root 19 6月  19 11:55 /abc -> /etc/redhat-release
[root@svr7 ~]# cat /abc 
 
######################################################
• ln,创建软连接
– 软连接 --> 原始文档 --> i节点 --> 文档数据
– ln -s 原始文件或目录 软连接文件
  若原始文件或目录被删除,连接文件将失效
  软连接可存放在不同分区/文件系统


• ln,创建硬连接
– 硬连接 --> i节点 --> 文档数据
– ln  原始文件    硬连接文件
 若原始文件被删除,连接文件仍可用
 硬连接与原始文件必须在同一分区/文件系统


i节点 :编号标识硬盘独立一个存储空间

   原始文档----->i节点------>硬盘所对应的区域

[root@svr7 ~]# echo 123 > /opt/A
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# ln -s /opt/A  /opt/B   #制作软连接(软链接)
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# ln /opt/A   /opt/C    #制作硬连接(硬链接)
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# ls  -i  /opt       #查看i节点编号

#####################################################
获取命令帮助
• man,格式化手册阅读工具
– 按 上 、下 、 PgUp 、PgDn 键滚动及翻页
– 按 q 键退出
– 按 / 键向后查找关键词(n、N切换)

[root@svr7 ~]# man mkdir
[root@svr7 ~]# man passwd
[root@svr7 ~]# man 5 passwd    #数字5:帮助类型(文件帮助信息)
[root@svr7 ~]# man teamd.conf 

• 对于内部命令,使用“ help 命令名”查看

• 对于外部命令程序,通常 会提供“--help”帮助选项

[root@svr7 ~]# ls --help
[root@svr7 ~]# ls --help | less

#####################################################
zip归档工具,跨平台的归档工具


• 归档+压缩操作
– zip [-r]   备份文件.zip   被归档的文档...

• 释放归档+解压操作
– unzip   备份文件.zip   [-d 目标文件夹]

[root@svr7 ~]# zip -r /root/file.zip  /home/  /etc/passwd 
[root@svr7 ~]# ls /root/

[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# unzip /root/file.zip -d /nsd02


######################################################
自定义Yum仓库

真机将tools.tar.gz上传到虚拟机A上
1.具备自己的软件包

# scp /root/桌面/tools.tar.gz     root@192.168.4.7:/root/

2.虚拟机A上操作:
# ls /root

3.虚拟机A上操作:tar解包
[root@svr7 ~]# tar -xf /root/tools.tar.gz  -C  /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls /tools/

4.虚拟机A上操作:生成仓库数据文件
[root@svr7 ~]# createrepo  /tools/other/
 
[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata/

5.虚拟机A上操作:书写一个客户端文件
[root@svr7 ~]# vim /etc/yum.repos.d/rhel7.repo 
 ......
[myrpm]                 #仓库标识
name=myrpm  
baseurl=file:///tools/other
enabled=1
gpgcheck=0

[root@svr7 ~]# yum repolist 

[root@svr7 ~]# yum -y install  sl
[root@svr7 ~]# rpm -ql  sl  #查询软件包安装的清单

[root@svr7 ~]# yum -y install  cmatrix
[root@svr7 ~]# cmatrix

[root@svr7 ~]# yum -y install  oneko
[root@svr7 ~]# oneko

###################################################

源码编译安装

 rpm包: 简单方便,不够灵活    yum   rpm -ivh


  源码包:非常的灵活,可以指定安装的位置及功能


  源码包------gcc\make----->可以执行的文件-------->运行安装


步骤一:安装开发工具gcc与make
[root@svr7 ~]# yum  -y  install   gcc  make

步骤二:tar进行解包
# tar -xf /tools/inotify-tools-3.13.tar.gz -C /mnt/
# ls /mnt/
# ls /mnt/inotify-tools-3.13/

步骤三:配置 ./configure ,进行指定可以指定安装的位置及功能
# cd /mnt/inotify-tools-3.13/

# ./configure   --prefix=/opt/myrpm
     检测是否安装gcc

常见的报错:没有安装gcc
 checking for gcc... no
 checking for cc... no
 checking for cl.exe... no
 configure: error: no acceptable C compiler found in $PATH

步骤四:编译  make
# make


步骤五:安装 make install

# make install

# ls /opt/

# ls /opt/myrpm/

# ls /opt/myrpm/bin/

#####################################################


22222222222222222222222222222222222222222222222222222222222222
2222222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222



DNS解析的作用
• 为什么需要DNS系统
– www.baidu.com 与 119.75.217.56,哪个更好记?
– 互联网中的114查号台/导航员

• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址


域名的体系结构,所有的域名必须要以点作为结尾

                             .   根域名


一级域名:    .cn     .us     .hk     .tw    .kr ......  


二级域名:   .com.cn    .net.cn   .edu.cn   .org.cn ........


三级域名:   NB.com.cn   dw.com.cn   haha.com.cn  dc.com.cn


完整的主机名: www.NB.com.cn    ftp.NB.com.cn   tts.NB.com.cn
  
• Full Qualified Domain Name,完全合格主机名(FQDN)

######################################################
bind-9.9.4-29.el7.x86_64          //域名服务包
bind-chroot-9.9.4-29.el7.x86_64   //提供虚拟根支持(牢笼机制)

– 系统服务:named
– 默认端口:TCP/UDP 53

• 主配置文件:/etc/named.conf     设置本机负责解析的域名
• 地址库文件:/var/named/         主机名与IP地址对应关系


###################################################
构建基本的DNS服务器

虚拟机A:服务端
1.安装软件 bind  bind-chroot
2.修改配置文件/etc/named.conf
[root@svr7 ~]# cp /etc/named.conf   /root/

[root@svr7 ~]# vim /etc/named.conf   #命令模式  u可以撤销

 options {
 	directory 	"/var/named";    #指定地址库文件存放路径
 };

 zone "tedu.cn" IN {          #指定本机负责解析的域名
 	type master;             #指定本机为主DNS服务器(权威服务器)
 	file "tedu.cn.zone";     #指定地址库文件的名字
 };
 
3.建立地址库文件/var/named/tedu.cn.zone
# cp -p /var/named/named.localhost /var/named/tedu.cn.zone

# ls -l /var/named/tedu.cn.zone

# vim /var/named/tedu.cn.zone
......
  tedu.cn.   NS   svr7
  svr7       A    192.168.4.7
  www        A    1.2.3.4
  ftp        A    5.6.7.8

4.重起服务
# systemctl restart named

######################################################
客户端:虚拟机B

# echo nameserver  192.168.4.7 > /etc/resolv.conf 

# nslookup www.tedu.cn

######################################################
多区域的DNS服务器
虚拟机A:
1.修改配置文件/etc/named.conf   #追加写入
 ........
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
 };

2.建立地址库文件
# cp -p /var/named/tedu.cn.zone  /var/named/qq.com.zone
# vim /var/named/qq.com.zone
 ........
 qq.com.    NS   svr7
 svr7       A    192.168.4.7
 www        A    1.2.3.4
 ftp        A    5.6.7.8

3.重起named服务
######################################################
特殊的解析记录

1.重复解析记录,可以达到轮询
[root@svr7 ~]# vim /var/named/tedu.cn.zone 

	tedu.cn.   NS   svr7
	svr7       A    192.168.4.7
	www        A    192.168.4.10
	www        A    192.168.4.20
	www        A    192.168.4.25
	ftp        A    5.6.7.8

[root@svr7 ~]# systemctl restart named
客户端:多次ping测试



2.泛域名解析
[root@svr7 ~]# vim /var/named/tedu.cn.zone
 ........
 *          A    10.20.30.40
 tedu.cn.   A    50.60.70.80


[root@svr7 ~]# !sys
systemctl restart named

客户端验证
[root@pc207 ~]# nslookup haha.tedu.cn
[root@pc207 ~]# nslookup tedu.cn

3.有规律的泛域名解析
        
            stu1.tedu.cn -------> 192.168.10.1
            stu2.tedu.cn -------> 192.168.10.2
            stu3.tedu.cn -------> 192.168.10.3
                    ........
            stu50.tedu.cn -------> 192.168.10.50

  $GENERATE:产生连续的数字  


  $GENERATE 1-50  stu$    A  192.168.10.$ 
 

4.解析记录的别名

[root@svr7 ~]# vim /var/named/tedu.cn.zone 

   tts        CNAME    ftp

[root@svr7 ~]# systemctl restart named
###################################################
DNS子域授权

     父域: www.qq.com      虚拟机A的DNS服务

     子域: www.bj.qq.com   虚拟机B的DNS服务
 
    虚拟机A的DNS服务,可以解析qq.com 
    虚拟机B的DNS服务,可以解析bj.qq.com

    虚拟机A的DNS服务,可以解析bj.qq.com


虚拟机B操作:
1.安装软件bind  bind-chroot
2.修改配置文件/etc/named.conf
# vim /etc/named.conf 
 options {
 	directory 	"/var/named";    
 };
 zone "bj.qq.com" IN {          
 	type master;             
 	file "bj.qq.com.zone";     
 };
3.建立地址库文件/var/named/bj.qq.com.zone
# vim /var/named/bj.qq.com.zone
  bj.qq.com.   NS   pc207
  pc207        A    192.168.4.207
  www          A    192.168.20.1
4.重起服务
# systemctl  restart  named
5.验证
# nslookup www.bj.qq.com  192.168.4.207

###############################################

    虚拟机A的DNS服务,可以解析bj.qq.com

子域授权

虚拟机A:
1.修改地址库文件
[root@svr7 ~]# vim /var/named/qq.com.zone 
	qq.com.    NS   svr7
	bj.qq.com. NS   pc207
	svr7       A    192.168.4.7
	pc207      A    192.168.4.207
	www        A    1.2.3.4
	ftp        A    5.6.7.8
[root@svr7 ~]# systemctl restart named

[root@svr7 ~]# nslookup www.bj.qq.com  192.168.4.7
Server:		192.168.4.7
Address:	     192.168.4.7#53

Non-authoritative answer:  非权威解答
Name:	www.bj.qq.com
Address: 192.168.20.1

##################################################

递归解析: DNS服务器与其他DNS服务器交互,最终将答案带回来的过程
迭代解析: DNS服务器与其他DNS服务器交互

#################################################
补充: 主机名映射文件/etc/hosts(DNS解析的作用,只为本机提供解析)

[root@svr7 ~]# vim  /etc/hosts
192.168.4.230  www.360.com  
192.168.4.200  www.baidu.com

[root@svr7 ~]# ping  www.360.com
[root@svr7 ~]# ping  www.baidu.com

解析顺序:
  --->/etc/hosts------>/etc/resolv.conf----->DNS服务器

###################################################
缓存DNS,加快解析速度

• 方式1:全局转发
– 将请求转发给指定的公共DNS(其他缓存DNS),请求递归服务


• 方式2:根域迭代
– 依次向根、一级、二级......域的DNS服务器迭代




#############################################
• 方式1:全局转发
1.查看真机DNS服务器ip地址
[root@room9pc01 ~]# cat /etc/resolv.conf 

nameserver 172.40.1.10
[root@room9pc01 ~]# 

2.真机搭建Yum仓库
[root@room9pc01 ~]# mkdir /dvd/
[root@room9pc01 ~]# mount /iso/CentOS-7-x86_64-DVD-1708.iso /dvd/

[root@room9pc01 ~]# ls /dvd/
[root@room9pc01 ~]# cd /etc/yum.repos.d/
[root@room9pc01 yum.repos.d]# ls
[root@room9pc01 yum.repos.d]# mkdir  repo
[root@room9pc01 yum.repos.d]# mv  *.repo   repo

[root@room9pc01 yum.repos.d]# vim dvd.repo 
 [dvd]
 name=CentOS7.4
 baseurl=file:///dvd
 enabled=1
 gpgcheck=0
[root@room9pc01 ~]# yum -y install bind bind-chroot

3.真机搭建缓存DNS服务器,修改配置文件

# vim /etc/named.conf

 options {
    directory   "/var/named";
    forwarders   {  172.40.1.10;  };   #书写真机的DNS地址
  };

# systemctl  restart  named

4.虚拟机A:验证
# echo nameserver 192.168.4.254 > /etc/resolv.conf 
# nslookup www.taobao.com

#######################################################


options {
        directory       "/var/named";
};
view "nsd"  {                             #分类名称
 match-clients  {   192.168.4.7; };    #匹配客户机地址
view "nsd"  {
 match-clients  {   192.168.4.7; };
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
zone "163.com" IN {
        type master;
        file "163.com.zone";
};
};
view "other"  {  
 match-clients  {  192.168.4.207;  };
zone "qq.com" IN {
        type master;
        file "qq.com.other";
};
zone "163.com" IN {
        type master;
        file "163.com.other";
};
};


cp33333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333
######################################################
检测虚拟机A与虚拟机B的Yum仓库
[root@svr7 ~]# yum clean all    #清空缓存
[root@svr7 ~]# yum repolist     #列出仓库信息

#####################################################
 
######################################################
搭建基本的DNS服务

服务端：虚拟机A
1.安装一个可以提供域名解析的软件
[root@svr7 ~]# yum -y install bind-chroot bind
2.修改主配置文件/etc/named.conf
[root@svr7 ~]# vim /etc/named.conf 
	options {
		directory 	"/var/named";    
	};
	zone  "sina.com"  IN  {         
		type master;               
		file "sina.com.zone";        
	};
3. 建立地址库文件/var/named/sina.com.zone   -p:权限不变进行拷贝
# cp -p /var/named/named.localhost /var/named/sina.com.zone
# vim  /var/named/sina.com.zone
	sina.com.      NS      svr7         #指定本区域DNS服务器
	svr7           A       192.168.4.7  #指定DNS服务器的IP地址
	www            A       19.18.16.17
# systemctl restart named   #重起服务
客户端：虚拟机B 验证DNS解析
 # echo nameserver 192.168.4.7 > /etc/resolv.conf 
 # nslookup   www.sina.com  #测试域名解析

######################################################
DNS分离解析

什么是分离解析
• 当收到客户机的DNS查询请求的时候
 – 能够区分客户机的来源地址
 – 为不同类别的客户机提供不同的解析结果(IP地址)
 – 根据客户端的不同，解析同一个域名，得到的解析结果不同

 – 目的：为客户端提供网络最近的服务器资源



   
案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:sina.com

– A记录分离解析 —— 以 www.sina.com 为例

客户机来自 解析结果
       192.168.4.207 --------》 192.168.4.100

       其他地址 --------》 1.2.3.4

 1.由上到下依次匹配，  匹配及停止
 2.使用view时，所有的客户端都必须在分类中
 3.所有的zone都必须在view中
 4.每一个view中的zone必须相同


 view "lan" {
	match-clients {  192.168.4.207; }；
	zone "sina.com" IN {
	...... sina.com.lan;
	};                                                                     192.168.4.100
 };
 view "other" {
	 match-clients { any; }；
	 zone "sina.com"  IN  {
	 ......  sina.com.other;
	 };
 };


  

虚拟机A：
1.修改配置文件/etc/named.conf
 view "nsd" {                                   #分类名称
  match-clients {   192.168.4.207;    };      #匹配客户机地址

  zone "sina.com" IN {
         type master;
         file "sina.com.nsd";
     };
   };

 view "other" {
  match-clients {    any;    };
  zone "sina.com" IN {
         type master;
         file "sina.com.other";
    };
  };
2.建立sina.com.nsd、sina.com.other 地址库文件 ， 写入不同的解析结果
   sina.com.nsd 解析结果为 192.168.4.100
   sina.com.other 解析结果为 1.2.3.4

3.修改/etc/named.conf

  补充：vim 可视模式 在命令模式下  按 ctrl+v 进入可视模式 可以选择列

    按 大写的  I 进入插入模式，然后输入内容 按Esc退回到命令模式

############################################################
acl地址列表  简化match-clients匹配

acl test { 192.168.4.207; 192.168.200; 192.168.4.250; 192.168.1.1; };

view "nsd" {
 match-clients {   test;    };
 zone "sina.com" IN {
        type master;
        file "sina.com.nsd";
  };
};

##########################################################
补充： vim 默认配置文件   ~/.vimrc  
         初始化vim操作，每次使用vim命令首先执行的内容


 [root@svr7 /]# vim /root/.vimrc 

  set nu          #开启行号
  set ai          #启用自动缩进
  set tabstop=2   #一个tab键等于 两个空格

##########################################################
RAID磁盘管理
• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks

– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘

– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率，无容错功能
– 至少由2块磁盘组成


• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少由2块磁盘组成

• RAID5,高性价比模式
 – 相当于RAID0和RAID1的折中方案
 – 需要至少一块磁盘的容量来存放校验数据
 – 至少由3块磁盘组成


• RAID6,高性价比/可靠模式
 – 相当于扩展的RAID5阵列,提供2份独立校验方案
 – 需要至少两块磁盘的容量来存放校验数据
 – 至少由4块磁盘组成


• RAID 0+1/RAID 1+0
 – 整合RAID 0、RAID 1的优势
 – 并行存取提高效率、镜像写入提高可靠性
 – 至少由4块磁盘组成

#################################################
进程管理

     程序：静态的代码，占用磁盘空间

     进程：动态的代码，会占用 CPU  内存
     进程的唯一标识：PID
     父进程与子进程   树形结构

###############################################

查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

  systemd是所有进程的父进程


[root@svr7 /]# pstree             #显示进程树

[root@svr7 /]# pstree  lisi       #显示用户lisi的进程

[root@svr7 /]# pstree -p lisi     #显示进程PID
 
[root@svr7 /]# pstree -ap lisi    #显示进程完整的信息


###############################################

• ps aux 操作
– 列出正在运行的所有进程

用户 进程ID %CPU %内存 虚拟内存 固定内存 终端 状态 起始时间 CPU时间 程序指令


• ps -elf 操作
– 列出正在运行的所有进程
PPID:父进程的PID号

################################################
进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

  按 大写的P  按cpu降序
  按 大写的M  按内存降序

[root@svr7 /]# top -d  1

[root@svr7 /]# ps aux
[root@svr7 /]# ps -elf
[root@svr7 /]# ps aux   |  wc  -l   #统计进程数  
[root@svr7 /]# ps -elf  |  wc  -l   #统计进程数  

##############################################
检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件

• 常用命令选项
 – -l:输出进程名,而不仅仅是 PID
 – -U:检索指定用户的进程
 – -t:检索指定终端的进程
 – -x:精确匹配完整的进程名
 
[root@svr7 /]# pgrep -l  atd
[root@svr7 /]# pgrep -l  cron

[root@svr7 /]# pgrep -lU lisi

[root@svr7 /]# pgrep -lU lisi | wc -l

[root@svr7 /]# pgrep -lx atd
################################################
控制进程


[root@svr7 /]# sleep 900 &   #正在运行放入后台
[root@svr7 /]# jobs          #查看后台进程信息
[root@svr7 /]# sleep 800
^Z                           #按Ctrl+z正在运行放入后台
[2]+  已停止               sleep 800
[root@svr7 /]# jobs 
[root@svr7 /]# bg 2       #将后台编号为2的进程继续运行
[root@svr7 /]# jobs 
[root@svr7 /]# fg 1       #将后台编号为1的进程恢复到前台
sleep 900
^C                    #按Ctrl+c结束
[root@svr7 /]# jobs 
[root@svr7 /]# fg 2       #将后台编号为2的进程恢复到前台
sleep 800
^C                    #按Ctrl+c结束
[root@svr7 /]# jobs 

杀死进程
 – Ctrl+c 组合键,中断当前命令程序
 – kill [-9] PID... 、kill [-9] %后台任务编号
 – killall [-9] 进程名...
 – pkill 查找条件

     -9：强制杀

 – killall  -9  -u  用户名    #杀死该用户开启的所有进程

          强制 踢出 一个用户

##################################################
日志管理

日志的功能
• 系统和程序的“日记本”
 – 记录系统、程序运行中发生的各种事件
 – 通过查看日志,了解及排除故障


• 常见的日志文件

 /var/log/messages   记录内核消息、各种服务的公共消息
 /var/log/dmesg 		记录系统启动过程的各种消息
 /var/log/cron       记录与cron计划任务相关的消息
 /var/log/maillog    记录邮件收发相关的消息
 /var/log/secure     记录与访问限制相关的安全消息


日志分析

    tailf  : 实时跟踪日志信息

   – awk、sed等格式化过滤工具


• users、who、w 命令
  – 查看已登录的用户信息,详细度不同

• last、lastb 命令
  – 查看最近登录成功/失败的用户信息

[root@svr7 /]# users
[root@svr7 /]# who
[root@svr7 /]# w

[root@svr7 /]# last  -2   #最近登陆成功2条记录
[root@svr7 /]# lastb  -2  #最近登陆失败2条记录


• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）	   会导致主机系统不可用的情况
  1  ALERT（警告）	   必须马上采取措施解决的问题
  2  CRIT（严重）	           比较严重的情况
  3  ERR（错误）	            运行出现错误
  4  WARNING（提醒）         可能会影响系统功能的事件
  5  NOTICE（注意）          不会影响系统但值得注意
  6  INFO（信息）	            一般信息
  7  DEBUG（调试）	    程序或系统调试信息等


444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444


DHCP服务构建

用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

DHCP概述及原理,整个过程通过广播进行,先到先得(一个网路中,不能有多台)
• DHCP地址分配的四次会话
– DISCOVERY --> OFFER --> REQUEST -->ACK


部署DHCP服务
1.安装软件包
[root@svr7 /]# yum -y install dhcp

2.修改配置文件/etc/dhcp/dhcpd.conf
[root@svr7 /]# vim  /etc/dhcp/dhcpd.conf
  末行模式 读入其他文件内容:   r  文件路径

  :r  /usr/share/doc/dhcp*/dhcpd.conf.example


 subnet 192.168.4.0 netmask 255.255.255.0 {  #分配的网段
  range 192.168.4.100   192.168.4.150;       #分配ip范围
  option domain-name-servers 192.168.4.7;   #分配DNS地址
  option routers 192.168.4.254;          #分配网关地址
  default-lease-time 600;              #默认组期时间
  max-lease-time 7200;                 #最大组期时间
 }

3.重起dhcpd服务

####################################################
PXE网络装机

• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

PXE组件及过程分析
• 需要哪些服务组件?
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务,提供yum安装源

##################################################
一  搭建DHCP服务,设置网络装机配置

1.修改配置文件/etc/dhcp/dhcpd.conf
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100   192.168.4.150;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server  192.168.4.7;  #指定下一个服务器地址
  filename  "pxelinux.0";    #指定网卡引导文件名称
}

2.重起dhcpd服务

  pxelinux.0:网卡引导文件(安装说明书) 二进制文件
                      安装一个软件可以自动生成

#######################################################
二 部署TFTP服务

   tftp: 简单的文件传输协议    端口:69
     默认共享的位置:/var/lib/tftpboot

1.安装tftp-server软件包
2.重起tftp服务
3.部署pxelinux.0文件
# yum  provides */pxelinux.0   #查询仓库中那个软件包产生该文件

# yum -y install syslinux

# rpm -ql syslinux | grep pxelinux.0  #查询安装清单

# cp /usr/share/syslinux/pxelinux.0     /var/lib/tftpboot/

# ls /var/lib/tftpboot/

 
   dhcp---------->IP地址   next-server  filename 
   tftp---------->pxelinux.0
   pxelinux.0---->读取菜单文件
               /var/lib/tftpboot/pxelinux.cfg/default

4.部署菜单文件
[root@svr7 /]# mkdir  /var/lib/tftpboot/pxelinux.cfg
[root@svr7 /]# mount /dev/cdrom  /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 /]# ls /mnt/
[root@svr7 /]# ls /mnt/isolinux/

[root@svr7 /]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

# chmod u+w /var/lib/tftpboot/pxelinux.cfg/default

# ls -l /var/lib/tftpboot/pxelinux.cfg/default

5.部署 图形模块 与  背景图片

  vesamenu.c32( 图形模块)
  splash.png(背景图片)

[root@svr7 /]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png   /var/lib/tftpboot/

[root@svr7 /]# ls /var/lib/tftpboot/

6.部署 启动内核 与  驱动程序
 
 vmlinuz(启动内核)
 initrd.img(驱动程序)

[root@svr7 /]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img  /var/lib/tftpboot/

[root@svr7 /]# ls /var/lib/tftpboot/
 initrd.img  pxelinux.cfg  vesamenu.c32
 pxelinux.0  splash.png    vmlinuz

7.修改菜单文件内容
# vim /var/lib/tftpboot/pxelinux.cfg/default 
补充内容vim末行模式  : set nu  #开启行号

  1 default vesamenu.c32    #默认加载vesamenu.c32
  2 timeout 600             #超时的时间
   ......
 10 menu background splash.png     #背景图片
 11 menu title NSD1805 PXE Server  #显示的标题
   .......
 61 label linux
 62   menu label  Install RHEL7   #菜单显示内容
 63   menu  default               #读秒结束默认选择
 64   kernel vmlinuz              #加载启动内核
 65   append initrd=initrd.img    #解压驱动程序

#################################################
总结:
  dhcp---------->IP地址   next-server  filename 
  tftp---------->pxelinux.0
  pxelinux.0---->读取菜单文件
               /var/lib/tftpboot/pxelinux.cfg/default

  default---->vesamenu.c32 vmlinuz initrd.img  

#################################################
验证:   新建一个全新的虚拟机
          选则PXE网络安装
          网络类型选择为private1
################################################
三 搭建Web服务,共享光盘所有内容

1.安装httpd软件
2.重起httpd服务
3.建立目录/var/www/html/rhel7
[root@svr7 /]# mkdir /var/www/html/rhel7

4.挂载光驱设备
[root@svr7 /]# mount /dev/cdrom  /var/www/html/rhel7

5.测试访问
[root@svr7 /]# ls /var/www/html/rhel7

[root@svr7 /]# firefox http://192.168.4.7/rhel7

##################################################
四  生成应答文件,实现无人值守安装

1.安装一个图形system-config-kickstart的工具,生成应答文件

2.运行system-config-kickstart
[root@svr7 /]# system-config-kickstart

  首先查看  软件包选择    是否可用
  
  需要Yum的支持: 必须将Yum仓库标识修改 [development]
[root@svr7 /]# vim /etc/yum.repos.d/rhel7.repo
 [development]
......

[root@svr7 /]# system-config-kickstart

  首先查看  软件包选择    是否可用

[root@svr7 /]# ls /root/ks.cfg 
/root/ks.cfg
[root@svr7 /]# vim /root/ks.cfg

3.共享ks.cfg文件

[root@svr7 /]# cp /root/ks.cfg   /var/www/html/
[root@svr7 /]# ls /var/www/html/

4.修改菜单文件,指定ks.cfg文件
# vim  /var/lib/tftpboot/pxelinux.cfg/default
......
label linux
  menu label  Install RHEL7
  menu  default
  kernel vmlinuz
  append initrd=initrd.img  ks=http://192.168.4.7/ks.cfg

#######################################################
总结:
  dhcp---------->IP地址   next-server  filename 
  tftp---------->pxelinux.0
  pxelinux.0---->读取菜单文件
               /var/lib/tftpboot/pxelinux.cfg/default

  default---->vesamenu.c32 vmlinuz initrd.img  ks.cfg

  ks.cfg-----> --url="http://192.168.4.7/rhel7"

######################################################



55555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555




rsync同步操作

• 命令用法
– rsync [选项...] 源目录 目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据


• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压

• 本地同步
– rsync [选项...] 本地目录1 本地目录2

– rsync [选项...] 本地目录1/ 本地目录2

[root@svr7 ~]# mkdir /todir
[root@svr7 ~]# rsync -a /boot /todir  //同步整个文件夹
[root@svr7 ~]# rsync -a /boot/ /todir/  //只同步目录下的数据



[root@svr7 ~]# mkdir /dir
[root@svr7 ~]# mkdir /test
[root@svr7 ~]# echo 123 > /dir/1.txt
[root@svr7 ~]# echo 123 > /dir/2.txt
[root@svr7 ~]# ls /dir/

[root@svr7 ~]# ls /test/

[root@svr7 ~]# rsync -avz /dir   /test
[root@svr7 ~]# ls /test/

[root@svr7 ~]# rsync -avz /dir/   /test
[root@svr7 ~]# ls /test/

[root@svr7 ~]# echo 123 > /dir/3.txt
[root@svr7 ~]# rsync -avz /dir/   /test
[root@svr7 ~]# ls /test/
#######################################################
[root@svr7 ~]# rsync -avz --delete  /dir/  /test/
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test

[root@svr7 ~]# touch /test/abc.txt
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test
[root@svr7 ~]# rsync -avz --delete  /dir/  /test/
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test

[root@svr7 ~]# touch /dir/4.txt
[root@svr7 ~]# rsync -avz --delete  /dir/  /test/
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test

######################################################
rsync+SSH远程同步
   
• 与远程的 SSH目录保持同步
– 下行:rsync [...]   user@host:远程目录    本地目录
– 上行:rsync [...]   本地目录    user@host:远程目录

虚拟机A:
# ls /opt
# rsync -avz --delete  /opt/   root@192.168.4.207:/opt/


虚拟机B:
# ls /opt

######################################################
实现实时同步

一  ssh无密码验证
虚拟机A:
1.生成公钥 私钥 
[root@svr7 ~]# ssh-keygen       #一路回车
[root@svr7 ~]# ls /root/.ssh/

2.传递公钥 到对方机器
[root@svr7 ~]# ssh-copy-id  root@192.168.4.207

3.验证
# rsync -avz --delete /opt/  root@192.168.4.207:/opt/
 

二 部署inotify-tools工具软件,监控目录内容变化

真机的操作:
# scp /root/桌面/tools.tar.gz       root@192.168.4.7:/root/

虚拟机A:

1.安装gcc与make开发工具
2.tar解包
# mkdir /nsd
# tar -xf /root/tools.tar.gz -C /nsd
# tar -xf /nsd/tools/inotify-tools-3.13.tar.gz -C  /

3.运行./configure进行配置
[root@svr7 ~]# cd /inotify-tools-3.13/
[root@svr7 inotify-tools-3.13]# ./configure
4.执行make 编译
5.执行make  install 安装
6.验证 
[root@svr7 /]# ls /usr/local/bin/inotifywait


inotifywait监控用法

– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib 等事件类别



三   书写监控的脚本

     死循环功能:持续不断做一件重复的事情

   for  i  in  {1..20}     #有次数的循环
    do
             重复的事情
    done


    while  [ 1 -eq 1 ]
    do
             重复的事情
    done



[root@svr7 /]# vim  /root/rsync.sh

 #!/bin/bash
 while inotifywait -rqq /opt 
 do
  rsync -az --delete /opt/  root@192.168.4.207:/opt/ 
 done

[root@svr7 /]# chmod +x  /root/rsync.sh

[root@svr7 /]# /root/rsync.sh

[root@svr7 /]# killall rsync.sh

######################################################



cobble       cobble      cobble  


Cobbler装机平台,不同版本的多系统的安装

一  安装一个CentOS虚拟机  

真机: 
[root@room9pc01 ~]# ls /iso/
CentOS-7-x86_64-DVD-1708.iso

虚拟机要求:
             1.硬盘大小50G
             2.网络类型private1
             3.软件包选择 "带GUI的服务器"
             4.分区选择 "自动分区"

             5.将CentOS放入光驱设备,搭建本地Yum仓库
             6.配置IP地址:192.168.4.168/24
             7.配置主机名:Cobbler.tedu.cn


二、虚拟机设置  
   1.设置防火墙为trusted
  # firewall-cmd  --set-default-zone=trusted 

   2.当前及永久设置SELinux状态为permissive
 [root@localhost ~]# setenforce 0    #当前临时关闭
 [root@localhost ~]# getenforce 
 [root@localhost ~]# vim /etc/selinux/config 
  SELINUX=permissive


三、利用scp真机传递Cobbler.zip包到虚拟机192.168.4.168中
 # scp /root/桌面/Cobbler.zip   root@192.168.4.168:/root/
 	


##################################################
重设root密码  

案例1:为虚拟机 server 重设管理密码
1)重启系统,进入 recovery 恢复模式(修复模式)
按e键，找到 linux16 行，末尾添加 rd.break console=tty0
按 ctrl + x 启动
2)以可写方式重新挂载 /sysroot,并切换到此环境
switch_root# mount  -o  remount,rw  /sysroot
switch_root# chroot  /sysroot    
sh-3.2#
3)将root用户的密码设置为 redhat
# echo  redhat  |  passwd  --stdin  root
4)重设SELinux安全标签(安全增强版Linux)
# touch  /.autorelable    #让  SElinux  失忆
5)先后执行 exit、reboot 完成修复
# exit
# reboot

##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压Cobbler.zip包
[root@cobbler /]# unzip /root/Cobbler.zip -d /
[root@cobbler /]# cd /Cobbler/
[root@cobbler Cobbler]# ls

[root@cobbler /]# unzip /Cobbler/cobbler.zip  -d  /opt/ 
[root@cobbler /]# ls /opt/cobbler

#####################################################
五、安装cobbler主程序、工具包等
[root@cobbler /]# yum -y install /opt/cobbler/*.rpm


#################################################################
cobbler网络装机部署

1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  tftp-server 

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务




2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.168    #设置下一个服务器还为本机
 server:   192.168.4.168         #设置本机为cobbler服务器
 manage_dhcp:   1                #设置cobbler管理dhcp服务
 pxe_just_once:   1              #防止客户端重复安装操作系统

 开机启动： 匹配及停止  
     1.硬盘启动     2.光驱设备     3.U盘     4.网络引导   


3.配置cobbler的dhcp
[root@svr7 /]# vim  /etc/cobbler/dhcp.template 


  :%s  /旧/新/g      #全文替换

  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   



4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件

# tar -tf  /Cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /Cobbler/cobbler_boot.tar.gz  #绝对路径释放

# ls  /var/lib/cobbler/loaders/

5.启动相关服务
[root@svr7 /]# systemctl restart cobblerd
[root@svr7 /]# systemctl enable cobblerd

[root@svr7 /]# systemctl restart httpd
[root@svr7 /]# systemctl enable httpd

[root@svr7 /]# systemctl restart tftp
[root@svr7 /]# systemctl enable tftp

[root@svr7 /]# systemctl restart rsyncd   #同步服务
[root@svr7 /]# systemctl enable rsyncd


6.同步刷新cobbler配置
[root@svr7 /]# cobbler sync
[root@svr7 /]# firefox https://192.168.4.168/cobbler_web

   用户名：cobbler
   密码：cobbler


##########################################################################################################
  cobbler import  --path=挂载点   --name=导入系统命名（随意起）
导入安装镜像数据

# mount /dev/cdrom  /dvd

# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror

[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64
###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler


##########################################
############################################################################################################
[root@cobbler ~]# system-config-kickstart  #生成ks文件

默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7.4-A  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

############################################################################################################


















网络、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、网络







  

		练       看      想        记



show running-config
查看当前运行的配置
show ip route
查看路由表
show access-list
查看访问控制列表
show ip nat tranlation
查看nat的缓存表（路由）
show ip interface brief
查看接口模式
特权模式：show  interface  f0/5  switchport



show vlan brief
查看路由表
show mac-address-table
查看mac地址表


11111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111


物理层——网卡、中继器             比特流
*RJ - 45 网络接口                 RJ-11  电话的接口
*光纤接口    FC  ST  SC  LC  MT-RJ  各类接口，用的时候具体挑选
*双绞线 ～TP平常使用的网线，非屏蔽双绞线UTP、屏蔽双绞线STP
双绞线的标准，速率  cat6  1000Mbps（1Gbps）   cat7 （10Gbps
 cat5   cat5e 100Mbps  普通家用，公司基本都是千兆
线缆的连接   T568A :白绿,绿, 白橙, 蓝,白蓝, 橙, 白棕,棕
          T568B : 白橙,橙, 白绿, 蓝,白蓝, 绿, 白棕,棕
线缆的连接    标准网线    交叉网线      全反线
物理层的设备    网络接口卡    10/100M   100/1000M   USB . PCI 网卡
            中继器      放大信号   延长网络传输距离
#Invalid input(无效的输入)
*write    或   copy running-config  startup-config  (保存配置
*enable   #进入特权模式
*config terminal  #进入全剧配置模式
*interface fastethernet f0/1  #进入端口
*enable password 123      #修改进入特权模式的密码
*erase startup-config    #清空设备配置
*reload        #重起
*show running-config  #查看交换机配置信息
*hostname  ..   # 修改交换机主机名
*no ip domain-lookup  #禁用DNS查询(输错信息时,会进入查询.ctrl+shift+6
                           退出,禁用DNS后就不会发生再查询了)
*line console 0
#exec-timeout 0 0     配置控制台会话时间用不超时
*line console 0
#logging synchronous   #配置输出日志同步


222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222



数据链路层——交换机——      数据帧
MAC地址（十六进制）
十六进制，一位=四位，二进制位
MAC 地址的第8位为0时表示该MAC地址为单播地址（物理地址），为1时表示组播地址（逻辑地址）。48位都为1表示广播地址。
广播——向除了接受数据的端口外的所有端口发送数据
Ipconfig  /all  查看MAC地址
一字节=八比特，48位的mac地址，占用六字节
交换机，24个网络接口+2个上层网络接口（用于和外部、网络连接）
广播域——接受同样广播消息的节点的集合。、vlan，分割广播域
交换机的所有端口默认属于同一个广播域
vlan（虚拟局域网） -- 广播控制   安全性  带宽利用  延迟
最多可以创建4096个vlan，0～4095。根据交换机的性能，或许只能创建一千多个
Trunk  中继链路  交换机给每个去往其他交换机的·数据帧·打上vlan标识
Access 接入链路（接入模式）一个   Trunk 中继链路（中继模式）多个
ISL Cisco私有的（外部标记·30）   IEEE 802.1Q 公有的标记方式（内部·4）
dynamic auto动态自动（默认的接口状态）  
EtherChannel-以太通道（多条链路捆绑到一起）


*show mac-address-table   #查看mac地址表     -交换机
*ipconfig /all    #查看主机的ip      —客户机上
*vlan vlan-id     #创建vanl+号    #vlan 5
*name land-name   #给创建好的vlan命名   #name caiwu
*show vlan brief  #查看vlan配置
*no vlan vlan-id  #删除vlan       #no land 2
*switchport access vlan vlan-id #将端口加入vlan 
*no switchport access vlan 2
*interface range f0/1-9   #进入多个端口（将多个端口加入vlan）
----switchport access vlan 2
*show vlan id vlan-id  #精确查看某个vlan的信息，#show vlan id 2
*switchport mode trunk  #配置交换机之间互联的端口为Trunk
*show interfaces f0/1 switchport  #查看接口模式 dynamic auto动态自动
*channel-group 1 mode on  #先进入要捆绑的端口号 range 捆绑成以太通道、号
     以太通道     组号  启用
*interface port-channel 1   #switchport mode trunk 
*show etherchannel summary   #查看捆绑端口信息




33333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333

网络层——路由   网关 ——   数据包
ip地址分、5类 1- 127、128-191、  192-223 、  224-239  、240-254
网络段、是否相同
网络位 ——255.    主机位  ——.0
路由器：识别数据包的目标ip地址、源ip、在路由表中发现可能的路径、
         选择路由表中到达目标最好的路径、维护和检查路由信息
 --每个路由器都维护着一张路由表，这是路由器转发数据包的关键；*指路
路由表：静态、缺省路由‘由管理员手工配置’  分支机构、家居等小型；
    动态路由‘通过路由协议自动设置’  isp服务商、广域网、园区等大型
路由器端口默认是关闭的，需要手动打开
网关地址，默认是该网段的最后一位
·C  直连路由 S 静态路由     S*默认路由
三层交换机——虚接口 、在三层交换机上配置的VLAN接口为虚接口
            • 使用SVI(交换虚拟端口)实现VLAN间路由
              – 虚接口的引入使得应用更加灵活
三层交换机的配置
• 确定哪些VLAN需要配置网关
• 如果三层交换机上没有该VLAN则创建它
• 为每个VLAN创建相关的SVI
• 给每个SVI配置IP地址
• 启用SVI端口
• 启用三层交换机的IP路由功能
• 如果需要,配置三层交换机的劢态或静态路由
OSPF  路由表的数据存放在一个链路数据库中
～邻居列表+链路数据库——计算后的得到路由表（？路由表
OSPF区域    先有区域-0  再有其他的   进程-1    进程号比区域号大-1

路由器只需要宣告内网网段，外网不需要宣告



*ip address ip地址  子网掩码     #给网关配ip
*no shutdown   #打开端口
*show ip route   #查看路由表
*no ip address    #删除端口配的ip，后面不需要再接ip 地址
*ip route 目标网络ID 子网掩码 下一跳   #指定到达ip目的网络“静态路由
                    目标网络ID ，目标ip所在的网段，不是具体的ip *.0
*ip routing      #在三层交换机启用路由功能
# interface vlan vlan-id    三层交换机、虚接口的引入，配置ip
# ip address ip_address netmask
# no shutdown

# no switchport        – 配置路由接口
#interface fastEthernet 0/24           #在三层交换机上配置
#switchport trunk encapsulation dot1q  -Trunk并指定接口封装为802.1q
#switchport mode trunk
*route ospf process-id  #启动OSPF路由进程
*network address inverse-mask area area-id  #inverse-mask:反掩码
                                 #指定OSPF协议运行的接口和所在的区域
*clear ip ospf process   #重起ospf进程（？）

#route ospf 1
#default-information originate  ·宣告自身有默认路由
#network 0.0.0.0  0.0.0.0 area 0 


4444444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444444




传输层         TCP/IP  定义端口号—服务
 TCP  传输控制  可靠、连接 效率低   UDP 用户数据报 不可靠、无连接 效率高 
TCP：源端口号、目标端口号 ACK  SYN  FIN，标志位，经典的三次握手、四断开
SYN：请求建立连接  ACK：同意建立连接  FIN：请求断开连接
TCP: FTP 21 SMTP 25 DNS 53 HTTP 80 Telent 23 ssh 22 . .
UDP: TFTP 69 DNS 53 NTP 123 ..
• 访问控制列表(ACL)
– 读取第三层、第四层 头部信息   ip 端口 
– 根据预先定义好的规则对数据进行过滤
类型 • 标准访问控制列表
     – 基于源IP地址过滤数据包
     – 标准访问控制列表的访问控制列表号是  1~99
   • 扩展访问控制列表
      – 基于源IP地址、目的IP地址、指定协议、端口来过滤数据包
      – 扩展访问控制列表的访问控制列表号是  100~199
access-list 一个列表可以写多个条目——permit|deny  源  反掩码  匹配

私有ip地址分类
• A类 10.0.0.0~10.255.255.255
• B类 172.16.0.0~172.31.255.255
• C类 192.168.0.0~192.168.255.255

NAT作用      网络地址转换
– 通过将内部网络的私有IP地址翻译成全球唯一的
公网IP地址,使内部网络可以连接到互联网等外
部网络上。

*access-list  access-list-number {permint|deny} source [source-wildcard]  #创建ACL 允许or拒绝 ip 子网掩码用  反掩码 （匹配或不匹配）
# access-list 1 deny 0.0.0.0 255.255.255.255  • 隐含的拒绝语句
    或 access-list 1 deny any 任意，所有   —host 只对应一个ip
#ip access-list 1 deny 192.168.1.1  0.0.0.0
或#ip access-list 1 deny host 192.168.1.1

*ip access-group access-list-number {in|out} • 将ACL应用于接口
# no ip access-group access-list-number {in |out} ·取消接口ACL

# Show access-lists   • 查看访问控制列表
# no access-list access-list-number   • 删除ACL
# access-list 101 deny tcp 192.168.1.0 0.0.0.255
host 192.168.2.2 eq 80                 • 应用实例
# access-list 101 permit ip any any

#ip nat inside source static local-ip global-ip  • 静态NAT配置
                    *设置内部和外部的IP地址，然后添加静态地址转换
#ip nat inside source static 192.168.1.1 100.0.0.2
                                            • 建立静态地址转换
#interface g0/1      #ip nat outside   #ip nat inside
                                  • 在内部和外部端口上启用NAT
#ip nat inside source static tcp 192.168.1.6 80
61.159.62.133 80    • 建立NAT端口映射关系     tcp协议  80 * 端口号

• PAT(端口多路复用)
#access-list 1 permit any   • 定义内部ip地址
#ip nat inside source list 1 interface g 0/1 overload
                                      • 设置复用动态IP地址转换
#debug ip nat   • debug ip nat命令跟踪NAT操作
#undebug ip nat





###################################################
#######################################################
######################################################



STP  生成树协议   防止广播风暴、备份线路
根网桥  • 网桥ID（BID） 
     网桥--之前交换机就叫做网桥，随着功能增加，改为交换机的名字了
– 网桥ID是唯一的,交换机之间选择BID值最小的交换机作为网络中的根网桥  
     缺省值：32768  +-4096（整数倍）     主根网桥  次根网桥
  FWD正常转发    BLK阻塞端口、临时断开
• PVST+配置的意义
– 配置网络中比较稳定的交换机为根网桥
– 利用PVST+实现网络的负载分担
HSRP    • 热备份路由选择协议   -HSRP -Cisco私有协议  -VRRP 共有协议
HSRP组成员   -活跃路由器  -备份路由器 -虚拟路由器 -其他路由器
     路由器：优先级100 +  越大越优先



*show version    #查看版本
#spanning-tree vlan vlan-list  ·启用生成树命令
#spanning-tree vlan vlan-list priority Bridge-priority
*spanning-tree vlan vlan-list root {primary|secondary}
                                         ·指定根网桥    主   次 
#show spanning-tree     ·查看生成树的配置
#show spanning-tree vlan vlan-id  ·查看某个vlan的生成树详细信息
            HSRP备份组号（最好用所在vlan的号）
#standby group-number ip virtual-ip-address
                              备份组虚拟ip地址   ·配置为HSRP的成员
#standby group-number priority priority-value  范围0～255，默认100
                                                   ·配置HSRP的优先级
#show standby brief    ·查看HSRP摘要信息
#standby group-number track fastethernet 0/*
                        • HSRP端口跟踪配置
#standby group-number preempt    • HSRP占先权配置






$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
##########################################################
*****************************************************************



                   shell shell shell






  vim  莫行模式
    :nohl   取消高亮






vnc  172.40.50.188:8


shell      逻辑思维   现实的问题---代码（命令）


公式----------------------应用题



理解    自己的逻辑思维能力

shell  就像是汽车的总称      bash  像是某种车（宝马，奔驰）
解释器程序的概述                     某种解释器程序


bash    sh  tcsh  csh    cat /etc/shells



at 21:00    设定时间计划任务

yum -y install ksh    安装ksh包

cat /etc/shells     查看有哪些解释器程序

ksh               进入ksh环境            redhat使用的bash，人性功能全

useradd -s  /bin/ksh  zhangsan   执行修改执行环境操作
usermod  -s  /bin/bash  zhangsan

grep  HISTSIZE  /etc/profile      检查历史命令的容量
vim  /etc/profile        修改历史命令的容量
history | wc -l   查看当前用户记录的历史命令条数
history | tail    最近十条   history | head
!1028   调用第1028条历史命令     !cat  调用最近一条以cat开头的命令
history -c   清空自己的历史命令   cat  ~/.bash_history
 > ~/.bash_history     清空历史命令保存文件



alias   产看已经定义的命令别名列表
grep '^alias' ~/.bashrc   别名的设置一般存放在用户的.bashrc文件内
alias lh='ls -lh'     自定义新的命令别名  alias lh  确认结果
lh  /etc/fstab   验证别名命令的效果
unalias lh   取消别名     alias lh

>   2>   &>  <       重定型标准输入/输出/错误输出   >>  2>>  &>>  

mail -s '..'  root  <  /etc/passwd   发送文件内容多的邮件
echo ‘..’  | mail -s '..' root    内容小的邮件     
echo '..' > a.txt   +  mail -s  '..' root  < a.txt
   |   一条命令可以实现复杂的功能      管道
yum list | grep samba | wc -l    一条命令行支持多个管道


1，屏幕显示hello world
2，自动配置yum源
3，自动安装vsftpd软件；自动启动服务；自动设置开机自启


 *env   查看有哪些环境变量（系统定义好的）   set 检查变量设置
                                   unset 撤销自定义的变量

PWD USER HOME UID SHELL HOSTNAME   MAIL  RANDOM
 
PS1=''                  PS2=''


$$ 执行脚本的PID(进程号)   $0  $1  $2     $?    $#    $*   $$   

双引号可以界定一个完整字符串                     "echo $x"
单引号界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能。  'echo $x'


变量的扩张应用    ""   ''  ` `    read -p       stty -echo  stty echo
  
export xx="123"    使用export命令将xx发布为全剧变量





2222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222
2222222222222222222222222222222222222222222222222222222222222222





expr  整数运算工具    \*   乘法加上 \ ，取消*的预定shell
       +       -      *      /        %

$[]   或  $(())  乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号

let命令
expr或$[]、$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值   let运算操作并不显示结果，但是可以结合echo命令来查看：
let x++ ；x++(x=x+1) let x--;(x=x-1) let x+=3;(x=x+3) let x-=3;
(x=x-3) let x*=2;(x=x*2)  let x/=2;(x=x/2) let x%=2;(x=x%2)

bc交互式运算      可以运算非整数，小数位的长度可采用scale=N限制
bc非交互式运算   将需要运算的表达式通过管道操作交给bc运算
                    echo 'scale=4;12.34+5.678' | bc

echo "2==2" | bc    ;  echo "2>3"  | bc  ;  echo "3<4" | bc
bc可以用来做判断   0 错  1 对

条件测试的基本用法
“test 表达式”          [ 表达式 ]      == (相等)  != （不相等）

 一行执行多条命令的情况
   # A && B     and     //仅当A命令执行成功，才执行B命令
   # A || B     or     //仅当A命令执行失败，才执行B命令
   # A ;  B           //执行A命令后执行B命令，两者没有逻辑关系
   # A && B || C     //思考？

-z 检查变量的值是否未设置（空值）  [ -z $NB ]      -n=! -z 不为空


1,字串判断   ==  ！=  -z  !-z
2.数字判断   -eq   -ne   -gt  -ge  -lt  -le
  [ 3 -eq 3 ]  && echo y  || echo n
3.文件/目录的判断     -e  -f  -d  -r  -w  -x

if  单分支    双分支     多分支

ping 192.168.4.254 -c 2   ping两次   -c 几次   -i 指定ping的间隔时间
                  -W 等待反馈的超时秒数




333333333333333333333333333333333333333333333333333333333333
333333333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333333333




for  i in {1..5}   `seq 5`   `cat /etc/passwd` 
do
..
done
  

while :      判断是真       [  $i -le 100 ]
do
..                        let i++
done

case  变量  in          简化的if判断
1)
   命令;;
2)
   命令;;
*)
   命令;;
esac

funcation  函数名 {
  命令
}
                                     脚本，上面先定义函数； 下面再调用
  函数名（）  {
     命令
}

#  ·Shell版fork炸弹
#    — 仅13个字符：    .(){ .|.& };.
#    — 递归死循环，可迅速耗尽系统资源


*echo {1...5}    {}里面不能有变量
*seq 5      可以是变量, 作用和{}相同，但是在shell里。要用``括起来
`ls /etc/*.conf`   可以是一个有输出的命令

bash -x /root/user.sh   #-x 可以看到脚本执行的过程，方便排错

echo -n ..    # -n 输出完不要换行

sar -P ALL 1 100 #-P 看我的cpu信息  ALL 全部的 1 1秒看一次  100看100次

case 分支属于匹配执行的方式     

while 循环   匹配条件  无心的死循环   ！

for 循环   指定次数，范围

if  选择判断

echo -e "\033[34mOK\\033[0m"       #34字体大小  OK输出什么字颜色
                                              带颜色的echo
shell函数

     halt  reboot=shutdown -h now  


tmp 临时密码 


 break   跳出当前所在的循环体，执行循环体后的语句块
continue 跳过循环体内余下的语句，重新判断条件以决定是否需要执行下一个循环
 exit    退出脚本，默认的返回值是0




44444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444




字串截取的三种用法：
 ·    ${变量名:起始位置:长度}
 ·   expr substr "$变量名"   起始位置   长度  
  ·   echo $变量名 | cut -b 起始位置—结束位置
字串替换的两种用法：
 ·  只替换第一个匹配结果： ${变量名/old/new}
 ·  替换全部匹配结果 ： ${变量名//old/new}
字符串掐头去尾：
  · 从左向右，最短匹配删除 ： ${变量名#*关键字}
  ·              长          ： ${变量名##*关键字}
  · 从右向左，   短         ： ${变量名%关键字*}
  ·               长          ：${变量名%%关键字*}

#phone="15684649976468"     
#echo ${#phone}    #变量phone包括多少 个字符
#echo ${phone:6:2}  #从左侧第七个开始，截取两位～起始位置从0开始


mv  $i  ${i%.*}.txt




数组  （是一个变量，一个变量可以存多个值）
	x=(11   22   33   44)
	echo ${x[0]}  自0开始
	echo ${x[1]}
	echo ${x[2]}
	echo ${x[3]}
	echo ${x[*]}   全部显示    ${x[*]}=${x[@]}  显示所有
	echo ${#x[*]}   统计变量的个数

追加数组——内容
echo ${#x[*]}   显示变量的个数 
x[5]=55         变量个数+，内容
echo ${x[*]}     查看全部的变量


mail -s "test"  root   <<  EOF  #EOF往下的内容一直到下一个EOF，
  xxx                               都是邮件的内容
  yyy
  zzz
EOF


yum -y install expect   #expect 是自动交互软件,帮人自动交互

字符串初值的处理
一，字符串初值的最常见处理方法   1）只取值  ${var:-word}
  #xx=11
  #echo ${xx:-123}  //因xx已存在，输出变量xx的值
       #unset xx
   #echo ${xx:-123}   //xx不存在，所以会输出 123
二，编写脚本...
   3）expect 预期交互 

expect <<EOF
spawn  命令
expect ""   {send "..\n"}
EOF  #结尾

expect脚本的最后一行默认不执行
如果不希望ssh时出现yes/no的提示，远程时使用如下选项:
# ssh -o StrictHostKeyChecking=no server0



什么是正则表达式？
 — 使用“一串符号” 来描述有共同属性的数据

正则表达式                  grep -E  / egrep  过滤工具
基本：
   ^   匹配行首
   $    匹配行尾
   [ ]    集合，匹配集合中的任意单个字符
   [ ^ ]    对集合取反
    .       匹配任意单个字符    "\.""\ "屏蔽"."的特殊含义，只是作为普通的.
     *      匹配前一个字符任意次数 [ *不允许单独使用 ]
   \{n,m\}   匹配前一个字符n到m次
                 \{n\}  匹配n次   \{n,\} 匹配n次以上    

egrep  -n 内容+行号  -i 忽略大小  -v 反  -c 行数     -q 静默  --color



过滤开头不是英文字母
小数点结尾


扩张正则列表

   +       1+
   ？      0-1
  {n,m}   n-m
    ()      整体
    |       或者
   \b    单词边界



***  echo ${变量}
     echo ${变量::}    截取
     echo ${变量///}   替换        ${变量//old/new/} 全替换
     echo ${变量#*:}    掐头       ${变量##*:}   最长匹配
     echo ${变量%:*}    去尾       ${变量%%:*}   最长匹配
     echo  ${变量:-1234}    变量付初值
*** 数组 （一个可以存多个值的变量）
        x[0]=12
        x[1]=12
        x[2]=12
      x=(12  12  12)        echo ${x[0]}
***  expect << EOF
     spawn 命令
     expect 看屏幕输出 { send "输入键盘指令\n"}
     EOF
***  正则表达式
      ^     开始
      $    结尾
      [ ]  集合，集合中的任意单个字符
      [^]   对集合取反
      .     任意单个字符
      *     前一个字符出现了任意次，包括0次
      \{n,m\}    \{n,\}   \{n\}  前一个字符 n-m n+ n  次


*** 扩张正则列表

	   +         1+
	   ？        0-1
	  {n,m}     n-m
	    ()         整体
	    |          或者
	   \b      单词边界





55555555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555555555


/etc/sysconfig/network-scripts/ifcfg-eth0
ip 改了后，写到这个文件里了


 #wait 等后台进程结束后，命令行才结束。返回
 #clear 清屏


*#$
sed ·Stream EDitor ,流式编辑器
 — 非交互，基于模式匹配过滤及修改文本
 — 逐行处理，并将结果输出到屏幕
 — 可实现对文本的输出、删除、替换、复制、剪切、导入、导出等各种操作

sed -n  屏蔽默认输出，默认sed会输出读取文档的全部内容
    -r  让sed支持扩展正则
    -i  sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响
  
  *sed 工具的条件，
   1） 行号 
    #sed -n '3p' '3,5p' '3p;5p' '3,+10p' '1~2p' '2~2p'
 
    #sed -n '1~2p' ..  从第一行开始，每隔2行打印以下  俗称步长,步长2

   2) 正则                                        '/bash$/p' 结尾
     打印包含root的行
     #sed  -n '/root/p'  /etc/passwd  '/^root/p' '5p' 'p'
            '/root/!p' 不包括
   

   3)   p 、打印行    d  、删除行     s  、字符替换  
         a  追加（后    i  插入（前     c 全行都更换掉
         正则  运用到命令里
      #sed -n 'p' /etc/passwd   #没有条件，则表示匹配所有行
	#sed -n '4p' a.txt    #输出第4行
	#sed -n '4,7p' a.txt   #输出第4～7行
	#sed -n '4,+10p' a.txt  #输出第4及其后的十行
	#sed -n '/^bin/p' a.txt #输出以bin开头的行
	#sed -n '$+' a.txt   #输出文件的行数

	#sed  '3,5d' a.txt  //删除第3～5行  
	#sed  '/xml/d' a.txt  #删除所有包含xml的行
	#sed  '/xml/!d' a.txt  #删除所有不包含xml的行
	#sed  '/^install/d' a.txt #删除以install开头的行
	#sed  '$d' a.txt  #删除文件的最后一行
	#sed  '/^$/d' a.txt  #删除所有空行

	#sed  's/xml/XML/' a.txt  #将每行中的第一个xml替换XML
	#sed  's/xml/XML/3' a.txt  #将每行中的第三个xml替换XML
	#sed  's/xml/XML/g'  a.txt #  所有的
	#sed  's/xml//g'  a.txt   #  所有的xml替换成空（删除）
	#sed  's#/bin/bash#/sbin/sh#'   #/bin/bash替换为/sbin/sh
    **替换操作的分隔“/”可改用其他字符，如#、$等，便于修改文件路径
	#sed  '4,s/^/#/'  a.txt  #将第4～7行注释掉（行首加#）
	sed  's/^#an/an/' a.txt  #解除以an开头行的注释（行首去掉#

	#sed 's/.//2'  a.txt   # .所有的  2 替换第二个字符

	# sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt

	# sed 's/[0-9]//' nssw.txt
	# sed -r 's/[0-9]//g;s/^( )+//' nssw2.txt

	# sed 's/([A-Z])/[\1]/g' nssw.txt

	#sed  's/$/***/' a.txt  #在每行末尾添加***
   *cat -A a.txt  #可以看到，每行末尾都默认以$结尾，$替换为*** 

    a=append 追加  （后   在某一行下面写入
    i=insert  插入 （前   在某一行前面写入，
     #sed  '2a  xxx'  a.txt
     #sed  '2i xxx'   a.txt
     #sed  '/root/a xxx'  a.txt  后        '/xa/i xxx'前    
     #sed  '2c  xxx'  a.txt



linux:/etc/hosts
windows:/windows/systemc32/drivers/etc/hosts



sed 文本编辑器，增  删  改 查
    总结知识点： 
   #sed [选项] '条件指令' 文件
    选项:
	-n 屏蔽默认输出
	-r 支持扩展正则
	-i 修改源文件
	条件：
	行号 4 4,5 4~2 4,+10
	/正则/
	指令：
	p 打印
	d 删除
	s 替换s/旧/新/g
	a 追加
	i 插入
	c 替换行


#sed  '2h,5g' a.txt
#sed  '2H,5G' a.txt


**** cat -A /etc/fstab    #末尾行都默认的是 $ 结尾

6666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666
6




*sed  文本编辑器，修改文件  增  删  改   查

*awk  数据过滤，查数据       = grep


* awk 选项 'BEGIN{指令}  条件{指令}  END{指令}'
   print "常量字符串"
   print $0 $1 $2 .. NR NF
  过滤条件：
  1，正则
      /正则/  $1~/正则/  $2~/正则/  $1!~/正则/
  2，数字或字符比较
  NR==3   $3>=1000  $3<1000 $4<10  $5<1000
   $1="root"  $1!="root"
   df -h  挂载使用清空      free 空闲内存
  3，逻辑判断
        && 并且    ||  或者
  4，运算
    awk 'BEGIN{print x++}'
    awk 'BEGIN{print x=x+8}'
* 流程控制  if  分支
  if($3>=1000){x++}else{y++}





过滤  统计      == grep   |  wc    

 ·  awk 编程语言 （不学）/数据处理引擎（主要学习的方面

awk 基本操作方法
 ·  awk 选项  '条件{指令}'    文件     print  ; 分隔
         {print $1，$3}     $ 表示列    默认空格，Tab空  分隔列

#free   看内存，交换分区
    #awk -F:  '{print $1}'  /etc/passwd  *-F  指定分隔符 ：
    #awk -F"[:/]" '{print $1,$10}'  /etc/passwd   *[:/] 正则
    #awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
  "" 可以打印长量，有引号   中间有逗号，有空格。没逗号，也可以，就没空格了
   #awk -F: '{print $NF}' /etc/passwd #输出每行最后一个字段  
  **awk常用内置变量：
	  $0 文本当前行的全部内容
	  $1	文本的第1列
	  $2	文件的第2列
	  $3	文件的第3列，依此类推
	  NR	文件当前行的行号
	  NF	文件当前行的列数（有几列）

   #ifconfig eth0 | awk '/RX p/{print $5}'  //过滤接受数据的流量
            #RX p..接受数据流量的行   第五列      * TX p 发送数据
   # df -h | awk '/\/$/{print $4}'   提取根分区剩余流量
          #根分区  末尾以 /  结尾，第四列   “  \/  屏蔽 /”

# tailf /var/log/secure  动态看..文件的后十行
# tailf /var/log/secure | awk '/Accepted/{print $11}'   成功
# tailf /var/log/secure | awk '/Failed/{print $11}'   失败
     #其他机器远程ssh本机， 查看访问成功/失败 的主机ip


F5 刷新

#awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件
   BEGIN{ }	 行前处理，读取文件内容前执行，指令执行1次    初始化
    { }	  逐行处理，读取文件过程中执行，指令执行n次    指令
   END{ }	 行后处理，读取文件结束后执行，指令执行1次     总结

#awk 'BEGIN{A=24;print A*2}'   #awk 里，A不用加$.默认的就是变量
#awk 'BEGIN{print x+1}'   #任何字母可以不需要定义，直接用，默认的是0
                              a-Z
#awk 'BEGIN{x=0}/bash$/{x++}END{print x}' /etc/passwd

# awk -F: 'BEGIN{print "用户名","UID","家目录"}{print $1,$3,$6}
END{print "总用户量："NR}' /etc/passwd  | column -t  
                                 | column -t 列、纵，对齐

***awk 处理条件：
  1) 使用正则设置条件
    awk -F: '/bash$/{print}' /etc/passwd
    awk -F: '/bash$/' /etc/passwd
    awk -F: '$1~/root/' /etc/passwd       ~ 正则匹配  模糊查找
    awk -F: '/^root/'  /etc/passwd       包含就匹配  区别  =  no
                ~ 包含    !~ 不包含
       awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd
   **  条件
     /正则/  全行匹配（包含即可） /root/
     $1~/正则/   第一列匹配 （包含即可）
    $1!~/root/    不包含      缺点，模糊   不精确

  2) 使用数值/字符串比较设置条件
        比较符号：==(等于) !=（不等于） >（大于）
        >=（大于等于） <（小于） <=（小于等于）
     awk  'NR==3{print $1}'  /etc/passwd
        awk -F: '$3>=1000{print $1}' /etc/passwd   非系统用户
     awk -F: '$1=="root"' /etc/passwd  #awk下，字符串必须加“”
   3) 逻辑测试条件    &&    ||
   awk -F: '$3>1000&&$3<1003' /etc/passwd
   awk -F: '$3>10000||$3<10'  /etc/passwd    
    awk -F: '$3>1000&&$3<10'  /etc/passwd
    awk -F: '$3>1000||$3<1003' /etc/passwd
    # awk 语法没问题就不出错， $  > && || < 之间对空格没要求
 

***** 
   awk  处理条件的设置：
    /正则/    数字/字符串       逻辑 &&  ||      数字运算

   # i=root     # -v 调用shell设定的变量
   # awk -F: -v x=$i '$1==x' /etc/shadow      
   #grep "^$i" /etc/shadow  | awk -F: '{print $1,$2}'

 *** awk 流程控制  一，if分支结构
awk  选项      '条件{指令}'  文件
# awk -F: '$3<=1000{x++}END{print x}' /etc/passwd

awk  选项      '{if ($3<=1000){x++}}END{print x}'    文件
                                      #系统用户有多少个
if($3<=1000){
x++
}                     if 的单分支判断，同上

if ($3<=1000){x++}else{y++}

# awk -F: '{if($3<=1000){x++}else{y++}}END{print x,y}' /etc/passwd         if 的双分支判断


  ***二，awk 数组  (面试里的经典，比较难，但是有用。必须熟记)
  #awk 'BEGIN{x[0]=11;x[1]=22;print a[0],a[2]}'
           #注意  定义数组用 ； 分隔， ;print  调用 用 ， 分隔
  #awk 'BEGIN{a["a"]=11;a["b"]=22;print a["a"],a["b"]}'
            #字母 加 ""
  #awk 'BEGIN{a[0]=1;a[1]=2;a[2]=3;for(i in a){print i,a[i]}}'
             #数组在输出所有变量时    a[i]   加i，加上变量号，好区分


#ll -h /var/log/httpd/access_log     5列$5 能看到文本大小，
                        增加用户访问量，会在日志里记录。所以文件大小会变化
# wc -l /var/log/httpd/access_log   访问量增加，行数会变化

#ab -c100 -n100000 http://192.168.4.254/
   -c 模拟有100人   -n 访问次数

 ** deny of service   #dos 攻击

#awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}'   | sort -n
    #统计每个ip访问的次数  ip 变量     # sort -n  从小到大排序

# who | awk '{root[$1]++}END{for(i in root){print root[i],i}}'
       # 扩展   统计 用户root 开启的终端  只有 $1 会变，其他都可固定不变









 *** awk 扩展应用
 



  #echo -n   横向输出，不要回车  
  #column -t   按列排版，纵  
  #sort -n     从小到大排序   -n 比较整串数字
                没有 -n 只会比较一串数字的第一个，然后第次






77777777777777777777777777777777777777777777777777777777777
7777777777777777777777777777777777777777777777777777777777777
777777777777777777777777777777777777777777777777777777777777




源码包不支持  systemctl start stop  status  ..
    /usr/local/nginx/sbin/ngix
    /usr/



  ps aux | grep httpd  | grep -v grep



  netstat -nutlp   可以看到所有启动的服务 

  uptime   看 cpu

  invalid user  无效的用户

   $!   最后一个进程号



  \n== 回车 Enter


















#######################################################
#########################################################
################################################



















































