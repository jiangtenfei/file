	ppt宝藏官网


 

服务器：机架式服务器最多，以厚度表示大小，1U＝4.445cm

CPU：Intel Xeon(至强)

内存：ECC纠错技术

硬盘：转速10000RPM/15000RPM

服务器一般托管到IDC（Inernet Data Center）

上网采用的结构：C/S(Client/Server)、B/S(Browser/Server)

协议：语言  TCP/IP

地址：ip地址（ipv4/ipv6），ipv6可以给地球上每一粒沙子分配一个IP地址

ARPAnet：DoD（美国国防部）出资创办了高级研究项目署，即ARPA，它把当时美国三所大学的4台计算机连接起来。

一台网络设备，如果联网需要配置的网络参数有：

ip地址：32位的2进制数。因为这么长的2进制数对于人来说，非学点不友好，为了方便人为记忆、表示，每8位转换成一个10进制数，再把4个数字之间用小数点分隔。称作点分10进制的表示方式。

  子网掩码：可以区分ip地址的网络部分和主机部分。2进制数模式下，将网络部分全部写为1，主机部分全部写为0

  缺省网关：路由器连接局域网端口的IP地址
DNS服务器地址：网络查号台。它可以将好记的名字与不好记的IP地址进行匹配、解析。

电话号码：区号＋座机号码
 
 IP地址：网络部分＋主机部分
同一城市，区号相同，座机号不同；不同城市，区号不同，座机号可以相同。相同网络，网络部分相同，主机部分不同；不同网络，网络部分不同，主机部分可以相同。

 采用交换机连接的网络是同一网络。路由器分开不同网络。

主机间通信：

1、PC1（192.168.1.10）与PC2（192.168.2.10）通信，PC1先查看目标与自己是不是同一网络
2、如果是同一网络，直接发送
3、如果不是同一网络，发给路由器（网关）

11000000 10101000 00000001 00001010
11111111 11111111 11111111 00000000
192      168      1        10
任何0－255间的数字都可以表示成8个0和1的组合。

00000000 -> 0
00000001 -> 1
00000010 -> 2
00000011 -> 3
11111111 -> 255

IP地址分类：
A：前8位作为网络位，第1位必须是0
B：前16位作为网络位，前2位必须是10
C：前24位作为网络位，前3位必须是110
D：前4位必须是1110，用于多播（组播）
E：前5位必须是11110，保留用于互联网研究

单播：一对一
多播（组播）：一对部分
广播：一对全部

Windows修改主机名：桌面计算机上右击－>属性->高级系统设置->计算机名->更改

Windows配置网络参数：桌面网络上右击->属性->更改适配器设置->在本地连接上右击->属性->TCP/IP->属性

Windows查看主机IP地址：开始->运行->cmd->ipconfig/all
测试网络连通性：ping命令
ping  127.0.0.1   测试自己的TCP／IP协议是否正常
127.0.0.1是本地环回地址，表示“我自己”的意思
ping  网关地址    测试局域网通信是否正常
Ping   远程主机    测试外网通信


1，windows ：虚拟化软件 VMware
2，linux ： 虚拟化软件 KVM
222222222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222




Cisco公司模拟器

网络参数：IP地址、子网掩码、网关、DNS服务器

IP地址：32位2进制数，分成网络部分和主机部分。同一网络（交换机连接），网络部分相同，主机部分不同；不同网络（路由器分隔）网络部分不同，主机部分可以相同。

A：前8位网络位，第1位是0                  255.0.0.0         1-127
B：前16位网络位，前2位是10                255.255.0.0       128-191
C：前24位网络位，前3位是110               255.255.255.0    192-223
D：前4位是1110，用于多播                   255.255.255.0    224-239
E：前5位是11110，保留                      255.255.255.0    240-255

背，学历不等于能力，学过不等于掌握。

子网掩码：32位2进制数，可以区分IP地址的网络位和主机位。网络位全置1，主机位全置0。

网关：路由器连接局域网的接口IP地址。

DNS服务器：用于域名解析

自由软件、开源软件(Free)

微软：PC领袖

虚拟机：KVM虚拟机

物理主机：CPU／MEMORY／HDD／DVD－ROM

安装RHEL7系统
1、在虚拟系统管理器中点击新建按钮
2、选择“本地安装介质”
3、ISO镜像位置，“浏览“->右下角“本地浏览”－>左下角“计算机”->右窗格，双击ISO目录，选择rhel-server-7.4-x86_64-dvd.iso
4、内存用2048M，CPU选择1颗
5、硬盘大小，写50G
6、名称填写“myrhel7“

GUI：Graphical  User  Interface图形用户界面
CLI：Command  Line  Interface命令行界面

Windows分区：

C盘只安装系统，D盘只安装程序，E盘保存常用文件，F盘保存不常用文件
Linux为分区起名，不采用CDEF这样的称呼，叫什么自己决定。
Linux有一些默认的名字，比如可执行文件目录叫bin或sbin，为用户准备的目录叫home，为那些经常有变动的目录起名为var，为临时文件夹起名为tmp

Linux认为一切皆文件，硬件设备也是文件，存放在/dev目录下
磁盘文件的命名：如果是物理磁盘，起名为sd，如果是虚拟盘，起名为vd。一台主机上可以有多块磁盘（U盘），采用abcdef字母来表示第几块盘。磁盘上的分区用12345这样的数字表示。

如果要访问分区，先要把分区和一个目录映射起来，叫做挂载。

磁盘分区结束后，还需要格式化。格式化可以选择ext4/xfs。Ext文件系统适合小文件，XFS适合大文件。

Linux默认管理员是root，其他用户都是普通用户。

RHEL7图形界面设置
1、点击屏幕右上角，再点击出现的左下角的“扳手”图标，常用设置包括“隐私”、“电源”、区域和语言
2、工作区：多个窗口的分类，按ctrl+alt+上下箭头

RHEL7命令行界面：

1、RHEL7默认打开了6个终端。按ctrl+alt+Fn（F1－F6）切换

2、在图形界面下还可以打开伪终端：桌面上右击，选择“打开终端”

3、伪终端字体大小快捷键是ctrl + +/ ctrl + -

4、命令提示符的含义：
[root@localhost ~]# 
[用户名@主机名 当前工作路径]用户提示符；如果是root，用户提示符是#，如果是非root用户，用户提示符是$

5、显示当前用户
[root@localhost ~]# whoami
root
[root@localhost ~]# w<tab><tab>  显示所有以w开头的命令

6、显示主机名
[root@localhost ~]# hostname
localhost.localdomain
[root@localhost ~]# hostname  -s
localhost

7、说明：命令、选项、路径等在linux下都区分大小写。命令、选项、参数之间必须有空格

8、显示当前工作目录
[root@localhost ~]# pwd
/root

9、切换用户
[root@localhost ~]#  su  zzg
[zzg@localhost root]$ 

10、列出文件或目录：ls
[root@localhost ~]# ls  /tmp
黑色字体表示单个文件，目录用蓝字表示，绿字表示有执行权限

11、在/tmp目录下创建demo
[root@localhost ~]# mkdir  /tmp/demo
在/tmp/demo下创建abc和xyz
[root@localhost ~]# mkdir  /tmp/demo/abc  /tmp/demo/xyz

12、切换工作目录：cd
(1)只要输入cd就会进入自己的家目录。root的家目录是/root。家目录就是该用户拥有绝对权限的目录，可以删除、写入等。zhangsan的家目录是/home/zhangsan，lisi的家目录是/home/lisi
[root@localhost /]# cd
（2）切换到/tmp/demo/abc
[zzg@localhost ~]$ cd  /tmp/demo/abc/
[zzg@localhost abc]$ pwd
/tmp/demo/abc
(3)切换到上一级目录。  ..表示父目录
[root@localhost abc]# cd  ..
[root@localhost demo]# pwd
/tmp/demo
（4）切换到当前目录下的xyz中
[root@localhost demo]# cd  xyz
（5）绝对路径：以/开头的路径，如/tmp/demo/abc
（6）相对路径：相对某一位置的路径，如xyz，表示相对当前路径的目录xyz
（7）以相对路径切换到/home下
[root@localhost xyz]# pwd
/tmp/demo/xyz
[root@localhost xyz]# cd  ../../../home
[root@localhost home]# pwd
/home
（8）一个英文句点 . 表示当前路径
[root@localhost home]# cd  /tmp/demo/
[root@localhost demo]# cd  ./abc/
[root@localhost abc]# cp  /etc/hosts  .   ->拷贝/etc/hosts到当前目录

13、查看/tmp/demo/abc下详细信息
[root@localhost abc]# ls  -l  /tmp/demo/abc/

14、以KMG显示文件大小，而不是字节
[root@localhost abc]# ls  -l  -h  /root/  或
[root@localhost abc]# ls  -lh  /root/
15、ls  -l因为非常常用，所以为其指定了别名，叫ll

16、查看内核版本号
[root@localhost abc]# uname  -r

17、查看操作系统的版本号
[root@localhost abc]# cat  /etc/redhat-release 
Red Hat Enterprise Linux Server release 7.4 (Maipo)

18、查看ls的帮助
[root@localhost abc]# ls  --help

19、命令格式
命令  [选项]...   [参数]...
[ ]表示可选项， ...表示可以有多个
选项有短格式和长格式，如ls  -a和ls  --all都是显示所有文件。

20、查看CPU
[root@room8pc16 ~]# lscpu 

21、查看内存信息
[root@room8pc16 ~]# cat  /proc/meminfo   或
[root@room8pc16 ~]# free  -m  以多少兆来显示大小

22、查看网卡信息
[root@room8pc16 ~]# ifconfig 
lo ->loopback，本地环回，127.0.0.1
enp2s0：物理网卡以en开头，表示以太网
ethX：传统命名方式（RHEL7之前的命名方式）

23、关机
[root@localhost abc]# shutdown  -h  now

24、重起
[root@localhost abc]# reboot 或
[root@localhost abc]# shutdown  -r  now

25、远程管理服务器：以root身份登陆172.40.50.116
[root@room8pc16 ~]# ssh  root@172.40.50.116

26、创建空文件
[root@localhost abc]# touch abc.txt
[root@localhost abc]# ls
abc.txt  hosts

27、在终端屏幕上显示文件内容
[root@localhost abc]# cat  /etc/passwd
[root@localhost abc]# cat  -n  /etc/passwd

28、分屏显示文件内容
[root@room8pc16 ~]# more  /etc/passwd
按回车向下逐行翻，按空格逐屏向下翻。按q退出。输入/nologin用于搜索nologin，按n向下继续搜索，按N向上继续搜索。
[root@room8pc16 ~]# less  /etc/passwd  
less与more类似，但是还可以按Home/End/PageUp/PageDown

29、head/tail默认查看文件头部/尾部10行，也可以自行指定
[root@room8pc16 ~]# head  /etc/passwd
[root@room8pc16 ~]# tail  /etc/passwd
[root@room8pc16 ~]# head  -3  /etc/passwd
[root@room8pc16 ~]# tail  -2  /etc/passwd

30、查看包含adm的行
[root@room8pc16 ~]# grep  adm  /etc/passwd






ftp://172.205.5.158/centos.tar.gz





####################################################


事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：

/ (root, 根目录)：与开机系统有关；

/usr (unix software resource)：与软件安装/执行有关；

/var (variable)：与系统运作过程有关。   可变动



****	/usr (软件放置处)
	/etc (配置文件)
	/opt (第三方协力软件)
	/boot (开机与核心档)
	/bin：存放所有用户都可以使用的linux基本操作命令
	/dev：设备文件目录，虚拟文件系统，主要存放所有系统中device的相关信息
	/home 普通用户家目录
	/proc：虚拟文件系统，此目录是kernel加载后，在内存里面建立的一个虚拟目录，有专属的文件系统，主要提供系统一些实时的信息，此目录下不能建立和删除文件；(某些文件可以修改)

#########################################################
333333333333333333333333333333333333333333333333333333333
3333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333




牛犇
#########################################

命令行基础

Linux命令
– 用来实现某一类功能的指令或程序
– Linux中的命令会有一个执行程序与之相对应

– 命令的执行依赖于解释器(默认的解释器：/bin/bash)

       用户-------->解释器------->内核----->调配所有的硬件

########################################################

• 基本用法
– 命令字     [选项]...      [参数1]     [参数2]...
   

[root@server0 ~]# ls  -l  /root/


Ctrl + c :结束正在运行的命令

快速编辑技巧
• Tab键自动补全
– 可补齐命令字、选项、参数、文件路径、软件名、服务名

	# if 连续按两次tab键
	# ifco（tab）
	
	# cat  /et(tab)/red(tab)-r(tab)

	# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

	# cat /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)


• 快捷键
– Ctrl + l :清空整个屏幕
– Esc + . 或 Alt  + . :粘贴上一个命令的参数
– Ctrl + c :结束正在运行的命令
[root@haha ~]# ls /etc/redhat-release 

[root@haha ~]# ls -l  Alt  +  . 

[root@haha ~]# cat   Alt  +  . 

[root@haha ~]# ls -l /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

[root@haha ~]# cat   Alt  +  . 

[root@haha ~]# ping 127.0.0.1
 按Ctrl + c 


– Ctrl + u : 清空至行首

– Ctrl + w : 往回删除一个单词(以空格界定)


######################################################
mount挂载操作:提供设备资源访问点

显示光盘内容

Windows

  光盘文件-------->光驱设备--------->CD驱动器(访问点)


Linux

  光盘文件-------->光驱设备---------->目录(访问点)
             IDE:/dev/hdc
             SCSI:/dev/sr0


     煤矿------>洞口

1.图形方式将光盘文件，放入虚拟机光驱设备

2.Linux光驱设备

蓝色：目录
黑色：文本文件
青色：快捷方式
[root@haha ~]# ls  /dev/cdrom 
[root@haha ~]# ls  -l  /dev/cdrom

3.访问光盘设备内容
• 使用mount命令
– 格式:mount  设备路径   挂载点目录

[root@haha ~]# mkdir /nsd       #创建访问点目录
[root@haha ~]# ls /
[root@haha ~]# ls /nsd

[root@haha ~]# mount  /dev/cdrom  /nsd   #进行挂载,让nsd成为访问点
mount: /dev/sr0 写保护，将以只读方式挂载

[root@haha ~]# ls /nsd/

[root@haha ~]# ls /nsd/Packages/    #查看光盘中的所有软件包

4.卸载
[root@haha ~]#  umount  /nsd
[root@haha ~]#  ls /nsd


注意：
 1.当有人正在访问挂载点
[root@haha nsd]# umount /nsd
  umount: /nsd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)

 2.挂载时，尽量使用自己创建的目录

#######################################################
• cd — Change Directory
– 用途:切换工作目录
– 格式:cd   [目标文件夹位置]

  cd  ..  :返回上一层

    绝对路径：以/开始的路径
    相对路径：不以/开始的路径

     ~:用户家目录

   ~user表示用户user的家目录

   /root : 管理员root用户的家目录
   /home : 存放所有普通用户家目录

[root@haha ~]# useradd zhangsan    #创建普通用户为zhangsan
[root@haha ~]# useradd dc          #创建普通用户为lisi

[root@haha ~]# cd  ~zhangsan
[root@haha zhangsan]# pwd   #查看当前目录的绝对路径

[root@haha zhangsan]# cd  ~dc
[root@haha dc]# pwd

[root@haha ~]# cd   ~root
[root@haha ~]# pwd

########################################################

• ls — List
– 格式:ls [选项]... [目录或文件名]

• 常用命令选项
– -l :以长格式显示,显示详细属性
– -h:提供易读的容量单位(K、M等)
– -d:显示目录本身(而不是内容)的属性
– -A:包括名称以 . 开头的隐藏文档

[root@haha ~]# ls -ld  /boot/
[root@haha ~]# ls -l  /boot/

[root@haha ~]# ls -lh  /boot/

[root@haha ~]# ls  /boot/
[root@haha ~]# ls -lh  /root
[root@haha ~]# ls -ld  /root

[root@haha ~]# ls -lh  /etc
[root@haha ~]# ls -ld  /etc

#######################################################
统计目录文件大小
[root@haha ~]# du -sh   /root

#######################################################
使用通配符
• 针对不确定的文档名称,以特殊字符表示
  – *:任意多个任意字符
  – ?:单个字符

[root@haha /]# ls  /etc/*tab
[root@haha /]# ls  /boot/vm*
[root@haha /]# ls  /etc/*.conf
[root@haha /]# ls  /dev/tty*

[root@haha /]# ls  /dev/tty?
[root@haha /]# ls  /dev/tty??


• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配

[root@haha /]# ls  /dev/tty[1-3]

[root@haha /]# ls  /dev/tty[2-9]

[root@haha /]# ls  /dev/tty{1,3,7,9,S0}

###################################################
   请显示/dev/的tty设备，tty20～tty30 ?

[root@haha /]# ls  /dev/tty{2[0-9],30}
 
[root@haha /]# ls  /dev/tty{2?,30}

####################################################
  命令的别名：简化复杂的命令

[root@haha /]# alias  别名='实际运行的命令'

[root@haha /]# alias  hn='hostname'     #定义别名
[root@haha /]# alias                    #显示当前生效的别名
[root@haha /]# hn                       #运行成功

[root@haha /]# unalias  hn               #删除别名
[root@haha /]# hn                        #运行失败

#######################################################

 mkdir创建目录
  -p:建立父目录，建立多级目录

[root@haha /]# mkdir -p /opt/aa/bb/cc/dd
[root@haha /]# ls /opt/aa

[root@haha /]# mkdir /root/abc  /opt/test01  /mnt/file
[root@haha /]# ls /root
[root@haha /]# ls /opt
[root@haha /]# ls /mnt

######################################################
rm 删除
• rm — Remove
– 格式:rm  [选项]...   文件或目录...

• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除

    递归:目录本身，以及目录下所有内容

[root@haha /]# rm -rf  /root/abc  /opt/test01  /mnt/file

#######################################################
mv 移动/改名
• mv — Move
– 格式:mv   [选项]...   原文件...     目标路径

[root@haha /]# rm -rf /opt/*
[root@haha /]# mkdir  /opt/nsd01
[root@haha /]# touch  /opt/1.txt
[root@haha /]# ls /opt/

[root@haha /]# mv /opt/1.txt  /opt/nsd01
[root@haha /]# ls /opt/
[root@haha /]# ls /opt/nsd01 

重命名:路径不变的移动
[root@haha /]# mv /opt/nsd01/  /opt/student
[root@haha /]# ls /opt/

[root@haha /]# mv /opt/student/   /opt/nsd02
[root@haha /]# ls /opt/

#######################################################
cp 复制
• cp — Copy

– 格式:cp  [选项]...   原文件...      目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项

[root@haha /]# rm -rf  /opt/*
[root@haha /]# touch  /opt/a.txt
[root@haha /]# mkdir  /opt/nsd01
[root@haha /]# ls  /opt/

[root@haha /]# cp  /opt/a.txt  /opt/nsd01
[root@haha /]# ls  /opt/
[root@haha /]# ls  /opt/nsd01/

[root@haha /]# cp  /etc/redhat-release  /opt/
[root@haha /]# ls  /opt/
[root@haha /]# cp  /etc/redhat-release  /opt/abc.txt
[root@haha /]# ls  /opt/

[root@haha /]# cp -r /boot/   /opt/
[root@haha /]# ls  /opt/
[root@haha /]# ls  /opt/boot/



cp可以支持两个以上的参数，永远会把最后一个参数作为 目标，其他参数都是源

 # cp -r   /etc/passwd    /etc/fstab   /boot/   /opt/

 # ls /opt/

 # rm -rf /opt/*
 # ls /opt/
 # mkdir /test03

 #  cp -r /test03  /opt/dir   #将目录test03放入/opt命名为dir
 #  ls /opt/

 #  cp -r /test03  /opt/dir   #将目录test03放入/opt/dir中
 #  ls /opt/
 #  ls /opt/dir


 在本次操作，临时取消别名
[root@haha /]# cp  -r  /boot/  /opt/
[root@haha /]# cp  -r  /boot/  /opt/  
[root@haha /]# \cp  -r  /boot/  /opt/     #取消覆盖的提示

#######################################################
 
使用vim创建/修改文件
• vim文本编辑器
– 格式:vim [[/目录/]文件名]

– 若目标文件不存在,则新建空文件并编辑
– 若目标文件已存在,则打开此文件并编辑      

 三个模式：命令模式     输入模式(插入模式)       末行模式

[root@haha /]# vim  /opt/haix.txt
         
	命--------- i 键  -------------》输入模式(Esc 键可以返回命令模式）
	令
	模
	式---------  :  键   -------------》末行模式(Esc 键可以返回命令模式）

    末行模式 ：wq   保存并退出    wq! 强制保存并退出
    末行模式 ：q！  强制不保存并退出

##########################################################

44444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444
44444444444444444444444444444444444444444
44444444444444444444444444444444444


使用教学虚拟机

• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机
– classroom —— 提供网关/DNS/软件素材等资源


优先开启classroom虚拟机

1.真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  #先重置资源服务器
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

2.  登陆虚拟机server与虚拟机desktop
      用户名：root   密码: redhat

 虚拟机server
        操作系统版本：RHEL 7.0
        系统IP地址：172.25.0.11/24
        主机名：server0.example.com


 虚拟机desktop
        操作系统版本：RHEL 7.0
        系统IP地址：172.25.0.10/24
        主机名：desktop0.example.com

##########################################################
利用真机远程管理，两台虚拟机

1.真机上操作：测试真机能否通信
[root@room9pc01 ~]# ping 172.25.0.11
[root@room9pc01 ~]# ping 172.25.0.10

2.真机上操作：远程管理
[root@room9pc01 ~]# ssh   用户名@对方的IP地址
[root@room9pc01 ~]# ssh   root@172.25.0.11

 Ctrl+shift+t : 可以再开一个新的终端

[root@room9pc01 ~]# ssh   root@172.25.0.10

[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.

3.运城管理打开对方的图形程序

[root@room9pc01 ~]# ssh -X root@172.25.0.11

[root@server0 ~]# firewall-config    #防火墙图形配置程序


########################################################
零散软件管理

虚拟机Server
1.关闭虚拟机添加光驱设备

2.显示光盘内容
[root@server0 ~]# mount /dev/cdrom  /dvd/
mount: /dev/sr0 写保护，将以只读方式挂载

[root@server0 ~]# ls /dvd/



[root@server0 ~]# rpm  -q   软件名（程序名）
 
[root@server0 ~]# rpm -q firefox    #检测程序是否安装
firefox-24.5.0-1.el7.x86_64
[root@server0 ~]# rpm -q zip
[root@server0 ~]# rpm -q gcc
[root@server0 ~]# rpm -q java
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 

[root@server0 ~]# rpm -ivh /dvd/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm                #安装软件包

[root@server0 ~]# rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64
[root@server0 ~]# rpm -e vsftpd               #卸载软件包
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 

了解：系统导入红帽签名信息
[root@server0 ~]# rpm --import /dvd/RPM-GPG-KEY-redhat-release 

##########################################################
安装软件包，产生依赖关系
常见的提示
错误：依赖检测失败：

##########################################################
自动解决依赖关系，安装软件  Yum软件包管理


   DNS：域名解析，将域名解析为IP地址

 服务：为客户端安装软件

 服务端： classroom.example.com搭建Web服务，共享了7.0光盘所有内容

              1.众多的软件包    2.仓库清单，仓库数据文件   3.共享的服务

    测试： 
    http://classroom.example.com/content/rhel7.0/x86_64/dvd/


 客户端：书写客户端配置文件
       /etc/yum.repos.d/*.repo

      错误的客户端配置文件与正确的客户端配置文件，会相互影响

[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dvd.repo
 [dvd]    #仓库标识
 name=rhel7.0  #仓库描述信息
 baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/    #指定Yum服务端位置

 enabled=1   #启用此该文件
 gpgcheck=0  #不做签名检查

[root@server0 ~]# yum repolist    #列出仓库信息

##########################################################
Yum的使用：

[root@server0 ~]# yum -y install sssd    #安装软件包
[root@server0 ~]# yum -y install httpd   #安装软件包
[root@server0 ~]# yum -y install gcc     #安装软件包

[root@server0 ~]# yum clean all       #清空Yum缓存

[root@server0 ~]# yum  remove  gcc     #卸载软件包

[root@server0 ~]# yum  search  ftp     #查询软件包信息

########################################################

下载软件包

使用wget下载工具
– wget  软件包的URL网址
– wget  软件包的URL网址    -O  /目录路径/新文件名


虚拟机server

 # wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

 # rpm -ivh kernel-3.10.0-123.1.2.el7.x86_64.rpm 

 # reboot 

[root@room9pc01 ~]# ssh -X root@172.25.0.11
Last login: Mon Jun  4 11:17:10 2018 from 172.25.0.250
[root@server0 ~]# uname  -r
3.10.0-123.1.2.el7.x86_64

##########################################################
配置网络
 
1. 配置永久主机名
[root@server0 ~]# vim  /etc/hostname
nsd.tedu.com
[root@server0 ~]# cat  /etc/hostname

[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[root@room9pc01 ~]# ssh -X root@172.25.0.11
Last login: Mon Jun  4 15:43:43 2018 from 172.25.0.250
[root@nsd ~]# hostname
nsd.tedu.com
[root@nsd ~]# 



2.  配置永久IP地址、永久子网掩码、永久网关地址

   IP地址：互联网中计算机的唯一标识
     子网掩码：区分网络位与主机位
     网关地址：一个网络到另一个网络的关口

   /etc/sysconfig/network-scripts/ifcfg-eth0  #网卡配置文件

• 查看nmcli connection 识别网卡的名字
[root@nsd ~]# nmcli connection show

• 配置IP地址、子网掩码、网关地址
[root@nsd ~]# nmcli   connection   modify   'System eth0'    
 ipv4.method   manual  
 ipv4.addresses  '172.25.0.100/24    172.25.0.254'
 connection.autoconnect   yes

[root@nsd ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
                                                 #查看网卡配置文件
    nmcli   connection   修改   '网卡名'
    ipv4.方法   手工配置
    ipv4.地址   'ip地址/子网掩码     网关地址'
       每次开机自动启用

• 激活配置
[root@nsd ~]# nmcli connection up 'System eth0'
[root@nsd ~]# route   #查看网关的指令    gateway


3.永久DNS服务器地址
[root@nsd ~]# vim /etc/resolv.conf
nameserver  172.25.254.254

[root@nsd ~]# cat /etc/resolv.conf

[root@nsd ~]# nslookup server0.example.com    #测试解析
[root@nsd ~]# nslookup desktop0.example.com   #测试解析


#########################################################
重定向输出:将前面命令的输出结果，写入到文本文件中

     > :覆盖重定向
     >> :追加重定向

[root@nsd ~]# ls --help                   #查看命令的帮助信息
[root@nsd ~]# ls --help > /opt/ls.txt   
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# hostname > /opt/ls.txt
[root@nsd ~]# cat /opt/ls.txt 

[root@nsd ~]# hostname >> /opt/ls.txt 
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# hostname >> /opt/ls.txt 
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# echo 123456789
123456789
[root@nsd ~]# echo 123456789   >>  /opt/ls.txt
[root@nsd ~]# cat /opt/ls.txt

[root@nsd ~]# echo A.tedu.com  >  /etc/hostname
[root@nsd ~]# cat /etc/hostname

# echo nameserver 172.25.254.254  > /etc/resolv.conf 
# cat /etc/resolv.conf

   非交互式

######################################################3
555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  #先重置资源服务器
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################


管道操作：将前面命令的输出结果,交由后面命令继续处理,作为后面命令的参数

     显示/etc/passwd第8～12行？

[root@server0 ~]# head -12 /etc/passwd

[root@server0 ~]# head -12 /etc/passwd  | tail -5

[root@server0 ~]# head -12 /etc/passwd  | tail -5 | cat -n

[root@server0 ~]# cat -n /etc/passwd | head -12 | tail -5

 显示第一张网卡的IP地址
[root@server0 ~]# ifconfig | head -2

交互式计算器
[root@server0 ~]# bc

  加   +      减   -     乘   *     除   /       取余运算  %

#######################################################

用户与组的管理

 用户账户：1.可以登陆操作系统    2.实现访问控制，不同用户具备不同的权限

  组：方便对用户的管理（权限方面）

  唯一标识： UID  GID 

  管理员的UID永远为0

  组：基本组(私有组)     附加组(公共组  从属组)
        一个用户至少属于一个组
#####################################################
用户基本信息存放在 /etc/passwd 文件（户口本）

[root@server0 ~]# head  -1  /etc/passwd
root:x:0:0:root:/root:/bin/bash

用户名:密码占位符:UID:基本组GID:用户描述信息:用户家目录:解器程序


• 使用 useradd 命令
– useradd [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 解释器程序、-G 附加组

[root@server0 ~]# useradd nsd02
[root@server0 ~]# grep nsd /etc/passwd

[root@server0 ~]# useradd  -u 1200 nsd03   #指定UID
[root@server0 ~]# grep nsd /etc/passwd

[root@server0 ~]# useradd nsd04
[root@server0 ~]# grep nsd /etc/passwd

[root@server0 ~]# useradd -d /mnt/nsd05   nsd05  #指定家目录
[root@server0 ~]# ls /mnt/
[root@server0 ~]# grep nsd05 /etc/passwd

[root@server0 ~]# id nsd02
[root@server0 ~]# id nsd03
[root@server0 ~]# id nsd04
[root@server0 ~]# id nsd05

/sbin/nologin : 禁止用户登陆系统

[root@server0 ~]# useradd -s /sbin/nologin nsd07
[root@server0 ~]# grep nsd07 /etc/passwd

[root@server0 ~]# groupadd tarena           #创建tarena组
[root@server0 ~]# useradd -G tarena  nsd08  #创建用户加入组
[root@server0 ~]# id nsd08

#######################################################

• 使用 passwd 命令
– passwd [用户名]



[root@server0 ~]# passwd nsd02
更改用户 nsd02 的密码 。
新的 密码：                                              #设置密码
无效的密码： 密码是一个回文
重新输入新的 密码：                                 #重新输入密码
passwd：所有的身份验证令牌已经成功更新。

命令行临时切换用户身份：   su  -  用户名
[root@server0 ~]# su  -  nsd02
[nsd02@server0 ~]$ passwd 
Changing password for user nsd02.
Changing password for nsd02.
(current) UNIX password:          #输入旧密码
New password:                     #输入新密码
Retype new password:              #再次输入新密码
passwd: all authentication tokens updated successfully.
[nsd02@server0 ~]$ exit

非交互式设置密码
– echo '密码'    |    passwd --stdin 用户名


[root@server0 ~]# echo 123 | passwd --stdin nsd02

[root@server0 ~]# echo 123456 | passwd --stdin nsd03

#######################################################
用户密码信息存放在 /etc/shadow 文件

   用户名: 密码加密字符串:上一次修改密码的时间


######################################################
   

修改用户属性
• 使用 usermod 命令
  [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录Shell、-G 附加组

[root@server0 ~]# useradd tom
[root@server0 ~]# id tom
[root@server0 ~]# grep tom /etc/passwd

# usermod -u 1400 -d /mnt/test -s /sbin/nologin -G tarena tom

[root@server0 ~]# grep tom /etc/passwd
[root@server0 ~]# id tom

#######################################################
删除用户
• 使用 userdel    命令
– userdel  [-r]  用户名   #连同家目录一并删除

[root@server0 ~]# userdel -r nsd03
[root@server0 ~]# ls /home/


#####################################################
管理组账号

组基本信息存放在 /etc/group 文件

[root@server0 ~]# grep stugrp /etc/group
 stugrp:x:1303:

  组名:组密码占位符:GID:组成员列表


添加组
• 使用 groupadd 命令
– groupadd [-g 组ID] 组名

[root@serv0 ~]# groupadd stugrp
[root@server0 ~]# grep stugrp /etc/group
stugrp:x:1303:

[root@server0 ~]# useradd harry
[root@server0 ~]# useradd natasha
[root@server0 ~]# useradd kenji
[root@server0 ~]# useradd jack


使用 gpasswd 命令
– gpasswd -a 用户名  组名
– gpasswd -d 用户名  组名

[root@server0 ~]# gpasswd -a harry stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -a kenji stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -d harry stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -a jack stugrp
[root@server0 ~]# grep stugrp /etc/group

[root@server0 ~]# gpasswd -d kenji stugrp
[root@server0 ~]# grep stugrp /etc/group

• 使用 groupdel 命令
– groupdel 组名


################################################
tar备份与恢复 

归档和压缩:  1.方便对零散文件的整理   2.减小磁盘空间的占用

 独有压缩格式： 
           gzip -----》 .gz 
           bzip2 -----》 .bz2
           xz -----》 .xz

• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理
– -t:显示归档中的文件清单
– -C:指定释放的位置

命令格式
 打包：
   tar  选项       /路径/压缩包的名字       /路径/被归档及压缩的源文件

 解包:
   tar  选项       /路径/压缩包的名字     -C  /路径

[root@server0 ~]# rm -rf /opt/*

# tar -zcf /opt/file.tar.gz   /home/  /etc/passwd 
[root@server0 ~]# ls /opt/

# tar -jcf /opt/test.tar.bz2  /home/  /etc/passwd
[root@server0 ~]# ls /opt/

# tar -Jcf /opt/nsd.tar.xz  /home/  /etc/passwd
[root@server0 ~]# ls /opt/

[root@server0 ~]# tar -xf /opt/file.tar.gz -C /mnt/
[root@server0 ~]# ls /mnt/
[root@server0 ~]# ls /mnt/etc/
[root@server0 ~]# ls /mnt/home/

查看包里面内容
[root@server0 ~]# tar -tf /opt/nsd.tar.xz 

####################################################
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

 # tar -jcf  /root/backup.tar.bz2   /usr/local/
 # ls /root/
 # tar -tf /root/backup.tar.bz2 

#####################################################
NTP时间同步

• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

服务端：classroom.example.com

客户端：虚拟机server

1.安装同步时间软件chrony
[root@server0 ~]# rpm -q chrony
chrony-1.29.1-1.el7.x86_64

2.修改配置/etc/chrony.conf
 在Linux中大多数配置文件中，以#开头的为注释内容

 #server 0.rhel.pool.ntp.org iburst
 #server 1.rhel.pool.ntp.org iburst
 #server 2.rhel.pool.ntp.org iburst
 server classroom.example.com iburst

3.重起服务刷新配置
   服务名：chronyd

  daemon：守护进程

[root@server0 ~]# systemctl restart chronyd  #重起服务
[root@server0 ~]# systemctl enable chronyd  #开机自启动

4.验证：
[root@server0 ~]# date

[root@server0 ~]# date -s "年-月-日  时:分:秒"
[root@server0 ~]# date -s "2008-10-1 12:30"

[root@server0 ~]# date
[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# date
[root@server0 ~]# date

###############################################
cron计划任务

• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务

• 软件包:cronie、crontabs
• 系统服务:crond
• 日志文件:/var/log/crond

	 *: 匹配范围内任意时间
	 ,: 分隔多个不连续的时间点
	 -: 指定连续时间范围
	/n: 指定时间频率,每n 


       时间                       任务
  分  时  日  月  周         任务命令行


• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]

  每分钟记录系统时间，写入/opt/time.txt

[root@server0 ~]# date  >>  /opt/time.txt
[root@server0 ~]# cat  /opt/time.txt

[root@server0 ~]# crontab  -e  -u  root   #编写计划任务
*  *  *  *  *   date >> /opt/time.txt

[root@server0 ~]# crontab  -l  -u  root   #查看计划任务

[root@server0 ~]# cat   /opt/time.txt 

######################################################
66666666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666666



真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################

基本权限

访问方式(权限)
– 读取:允许查看内容-read  r
– 写入:允许修改内容-write   w
– 可执行:允许运行和切换-execute  x

   对于文本文件:
          r:  cat  less  head  tail 
          w:  vim   重定向
          x:  可以运行该文件


 • 权限适用对象(归属)
    – 所有者(属主):拥有此文件/目录的用户-user   u
    – 所属组(属组):拥有此文件/目录的组-group    g
    – 其他用户:除所有者、所属组以外的用户-other   o

查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

   以  -  开头 ： 文本文件
   以  d 开头 ： 目录
   以  l 开头 ：快捷方式

###############################################

• 使用 chmod 命令
– chmod [-R] 归属关系+-=权限类别    文档...
        [-R] 递归设置权限


[root@server0 /]# mkdir /nsd01
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod u-w /nsd01     #所有者去掉w权限
[root@server0 /]# ls -ld /nsd01 

[root@server0 /]# chmod g+w /nsd01     #所属组加上w权限
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod o=--- /nsd01   #修改其他人权限
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod u=rwx,g=rx,o=rx /nsd01
[root@server0 /]# ls -ld /nsd01

[root@server0 /]# chmod ugo=rwx /nsd01
[root@server0 /]# ls -ld /nsd01

###################################################
如何判断用户的权限：              匹配及停止
        1.判断用户的角色            所有者>所属组>其他人 
        2.查看相应位置的权限


常见的提示：
 Permission denied :权限不足


目录的 r 权限:能够 ls 浏览此目录内容
目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作
目录的 x 权限:能够 cd 切换到此目录

#######################################################


以root用户新建/nsddir/目录，在此目录下新建readme.txt文件，并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录   切换用户  su  -  lisi
     chmod o+w  /nsddir/

 2）使用户lisi不能够在此目录下创建子目录
     chmod o-w  /nsddir/

 3）使用户lisi能够修改readme.txt文件
     chmod o+w  /nsddir/readme.txt

 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/   

 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/

####################################################

• 使用 chown 命令
– chown [-R] 属主         文档...
– chown [-R] :属组       文档...
– chown [-R] 属主:属组  文档...
        [-R]  递归修改归属关系

[root@server0 /]# mkdir /nsd03
[root@server0 /]# ls -ld /nsd03
[root@server0 /]# groupadd tarena
[root@server0 /]# chown lisi:tarena  /nsd03 
[root@server0 /]# ls -ld /nsd03

[root@server0 /]# chown zhangsan /nsd03   #修改所有者
[root@server0 /]# ls -ld /nsd03

[root@server0 /]# chown :root /nsd03   #修改所属组
[root@server0 /]# ls -ld /nsd03

#####################################################
附加权限(特殊权限)

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设置与父目录相同的属组
– 传递所属组身份

[root@server0 ~]# mkdir /nsd06
[root@server0 ~]# chown :tarena /nsd06
[root@server0 ~]# ls -ld /nsd06

[root@server0 ~]# mkdir /nsd06/test01
[root@server0 ~]# ls -ld /nsd06/test01

[root@server0 ~]# chmod g+s /nsd06
[root@server0 ~]# ls -ld /nsd06

[root@server0 ~]# mkdir /nsd06/test02
[root@server0 ~]# ls -ld /nsd06/test02   #所属组会继承父目录

[root@server0 ~]# ls -ld /nsd06/test01

#######################################################
acl访问控制列表

• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持


[root@server0 ~]# mkdir /nsd07
[root@server0 ~]# chmod o=--- /nsd07
[root@server0 ~]# ls -ld /nsd07

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd07
-bash: cd: /nsd07: Permission denied
[lisi@server0 ~]$ exit
[root@server0 ~]# setfacl -m u:lisi:rx /nsd07
[root@server0 ~]# getfacl  /nsd07

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd07
[lisi@server0 nsd07]$ pwd
[lisi@server0 nsd07]$ exit
[root@server0 ~]# 


• 使用 getfacl、setfacl 命令
– getfacl 文档....
– setfacl [-R] -m  u:用户名:权限类别   文档...
– setfacl [-R] -m  g:组名:权限类别   文档...
– setfacl [-R] -b  文档...      #清空所有的ACL策略
– setfacl [-R] -x  文档...      #删除指定的ACL策略


[root@server0 ~]# mkdir /nsd08
[root@server0 ~]# setfacl -m u:zhangsan:rwx  /nsd08
[root@server0 ~]# setfacl -m u:lisi:rx  /nsd08
[root@server0 ~]# setfacl -m u:dc:rx  /nsd08
[root@server0 ~]# getfacl /nsd08

[root@server0 ~]# setfacl -x u:lisi  /nsd08  #删除指定ACL
[root@server0 ~]# getfacl /nsd08

[root@server0 ~]# setfacl -b /nsd08   #清空所有的ACL
[root@server0 ~]# getfacl /nsd08


[root@server0 ~]# mkdir  /public
[root@server0 ~]# chmod  ugo=rwx /public
[root@server0 ~]# ls  -ld  /public

[root@server0 ~]# setfacl  -m  u:lisi:---  /public
[root@server0 ~]# getfacl  /public

####################################################
使用LDAP认证

  LDAP服务器： 网络用户认证       放到网络中LDAP服务器
    本地用户：  /etc/passwd

                 
  LDAP服务器：classroom.example.com


    客户端：虚拟机Server
    1.安装sssd软件包  与LDAP服务器沟通
  [root@server0 ~]# yum -y install sssd
  [root@server0 ~]# rpm -q sssd

    2.图形的配置工具authconfig-gtk软件  修改sssd配置

  [root@server0 ~]# yum -y install authconfig-gtk
 

  3.运行图形的工具进行配置 
  [root@server0 ~]# authconfig-gtk 

    选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名

   勾选TLS加密
   使用证书加密: http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码

  4.重起sssd服务验证
  [root@server0 ~]# systemctl restart sssd
  [root@server0 ~]# systemctl enable sssd   #设置开机自启动
  [root@server0 ~]# grep ldapuser0 /etc/passwd
  [root@server0 ~]# id ldapuser0
########################################################
家目录漫游

什么是NFS共享
• Network File System,网络文件系统
– 由NFS服务器将指定的文件夹共享给客户机
– 客户机将此共享目录 mount 到本地目录,访问此共享
资源就像访问本地目录一样方便
– 类似于 EXT4、XFS等类型,只不过资源在网上

 NFS服务器：classroom.example.com
  客户端：虚拟机Server

   1.查看服务端共享 
 [root@server0 ~]# showmount -e classroom.example.com
 Export list for classroom.example.com:
 /home/guests 172.25.0.0/255.255.0.0

   2.访问共享
 # mount  classroom.example.com:/home/guests   /mnt
 # ls /mnt/

 # mkdir /home/guests
 # ls  /home/guests
 # umount  /mnt/
# mount classroom.example.com:/home/guests/  /home/guests/
 # ls /home/guests/

######################################################
7777777777777777777777777777777777777777777777777777777777
777777777777777777777777777777777777777777777777777777777
77777777777777777777777777777777777777777777777777777777



真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################
grep文件内容过滤

 格式：  grep  '字符串'    /路径/文本文件

[root@server0 ~]# grep  'root'  /etc/passwd
[root@server0 ~]# grep  'bin'   /etc/passwd
[root@server0 ~]# grep  'bash'  /etc/passwd
   选项:   -i 忽略大小写
[root@server0 ~]# grep -i 'man'  /etc/man_db.conf 
[root@server0 ~]# grep -i 'ROOT' /etc/passwd
   选项:   -v 取反
[root@server0 ~]# grep -v 'root'  /etc/passwd

  特殊的过滤条件
         ^root   必须以root开头
         root$   必须以root结尾
                 ^$           匹配空行

[root@server0 ~]# grep '^root' /etc/passwd
[root@server0 ~]# grep 'bash$' /etc/passwd
[root@server0 ~]# grep 'nologin$' /etc/passwd

[root@server0 ~]# grep -v '^$'  /etc/default/useradd 

     显示文本文件有效配置？（去除空行、去除注释行）
# grep -v '^#' /etc/default/useradd   |  grep -v '^$'

# grep -v '^#' /etc/login.defs  |  grep  -v '^$'

###################################################
 find 查找文档所在位置

  格式：  find   查询路径     条件
 
	– 常用条件表示:
	 -type 类型(f 文件   d 目录   l 快捷方式)

[root@server0 ~]# find /boot/ -type l
[root@server0 ~]# ls /boot/grub/menu.lst 
[root@server0 ~]# ls -l /boot/grub/menu.lst

[root@server0 ~]# find /boot/ -type d

[root@server0 ~]# find /boot/ -type f

[root@server0 ~]# find /root -type d

[root@server0 ~]# find /root -type f
####################################################
    -name  "名字"

[root@server0 ~]# find /etc/  -name "passwd"

[root@server0 ~]# find /etc/ -name  "*passwd*"

[root@server0 ~]# find /boot/  -name  "vm*"

[root@server0 ~]# find /etc/ -name  "*.conf"   #包含子目录

#####################################################
多条件的查找  -a   且and，可以不写，默认-a

[root@server0 ~]# mkdir /root/nsd1805
[root@server0 ~]# touch /root/nsd01.txt
[root@server0 ~]# touch /root/nsd02.txt

[root@server0 ~]# find /root/  -name  "nsd*"

[root@server0 ~]# find /root/  -name  "nsd*"   -type f

[root@server0 ~]# find /root/  -name  "nsd*"   -type d

####################################################
  -size +-大小   k M G     按大小查找
  
[root@server0 ~]# find  /boot/   -size +10M

[root@server0 ~]# find  /boot/   -size -10M

[root@server0 ~]# find  /boot/   -size +300k

###################################################

处理find查找的内容（多参数的命令，不支持管道‘|’）
查找完了以后，查找的结果～直接执行处理
– find .. .. -exec  处理命令 {}    \;
– 优势:以 {} 代替每一个结果,逐个处理,遇 \; 结束

# find  /boot/  -size +10M 
# find  /boot/  -size +10M   -exec cp  {}  /opt  \; 

# find /root/ -name "nsd*"   -type ffi

# find /root/ -name "nsd*"   -type f  -exec cp {}  /opt \;

# find /boot/ -size +10M     -exec ls  -lh  {} \;
#######################################################
 按照所有者查找

  -user  zhangsan

[root@server0 ~]# find /home -user student
[root@server0 ~]# find / -user student
[root@server0 ~]# find / -user student  -type f

######################################################

• 根据名称查找,忽略大小写
– -iname

[root@server0 ~]# find /etc/ -iname "passwd"

[root@server0 ~]# find /etc/ -iname "Passwd"

[root@server0 ~]# find /etc/ -iname "PASSWD"



####################################################
• 根据所属组查找
  -group

[root@server0 ~]# find /home/ -group student

• 限制目录查找的深度(最大层数)
– -maxdepth

[root@server0 ~]# find /etc/  -maxdepth 1 -name "*.conf"
 
[root@server0 ~]# find /etc/  -maxdepth 2 -name "*.conf"

[root@server0 ~]# find /etc/  -maxdepth 3 -name "*.conf"



• 根据文件修改时间，所有时间都是过去时间
 -mtime +-天数

 # find  /var/log/  -mtime +90    #90天之前

 # find  /var/log/  -mtime -10    #最近10天之内

######################################################
• 使用find命令完成以下任务
– 找出所有用户 student 拥有的文件
– 把它们拷贝到 /root/findfiles/ 文件夹中

# mkdir /root/findfiles
# find / -user student -type f

# find / -user student -type f  -exec cp  {}  /root/findfiles/   \;

# ls -A /root/findfiles

#####################################################
Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者具有文件属主的身份及部分权限
– 传递所有者身份
 

Sticky Bit
• 附加在其他人的 x 位上
– 其他人的权限标识会变为 t
– 适用于开放w权限的目录,可以阻止用户滥用w写入权限(禁止操作别人的文档)

[root@server0 ~]# mkdir /public
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public
[root@server0 ~]# chmod o+t /public
[root@server0 ~]# ls -ld /public

####################################################
    








EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE



真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################

统计文件有多少行
[root@server

0 ~]# wc -l /etc/passwd
[root@server0 ~]# wc -l /etc/redhat-release 

 请计算Linux系统中一共有多少个用户？
[root@server0 ~]# wc -l /etc/passwd
 
 请计算Linux系统/etc/以tab结尾的文件有多少个？
[root@server0 ~]# find /etc/ -name "*tab" | wc -l

[root@server0 ~]# find /etc/ -name "*.conf" | wc -l

###################################################
扇区:512字节

• 识别硬盘 => 分区规划 => 格式化 => 挂载使用

   毛坯楼层=>打隔断=>装修 => 入驻


格式化：赋予一种规则，数据在空间存放的规则（文件系统）


服务器的硬盘，支持热插拔
###################################################
 分区规划 

分区模式：施工方案

    MBR/msdos：最大支持到2TB
       – 分区的类型：主分区   扩展分区   逻辑分区
       – 4个主分区,或者 3个主分区+1个扩展分区(n个逻辑分区)
       – 扩展分区空间不能直接使用
         扩展分区默认占用剩余的所有

一、进行分区
1.查看当前系统识别的磁盘
[root@server0 ~]# lsblk 
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
vda     253:0    0  10G  0 disk 
└─vda1 253:1    0  10G  0 part /
vdb     253:16   0  10G  0 disk
 
[root@server0 ~]# ls /dev/vdb

2.划分分区
[root@server0 ~]# fdisk  /dev/vdb
   n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
   p 查看分区表
   n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
   d 删除分区
   w 保存并退出   (q 不保存退出)

[root@server0 ~]# lsblk 
[root@server0 ~]# ls /dev/vdb[1-2]


二、格式化           .fat最老的一款文件类型，通用，识别的多
[root@server0 ~]# mkfs.ext4 /dev/vdb1   #格式化文件系统为ext4
[root@server0 ~]# blkid /dev/vdb1       #查看文件系统类型

[root@server0 ~]# blkid /dev/vdb2      
[root@server0 ~]# mkfs.xfs /dev/vdb2   #格式化文件系统为xfs
[root@server0 ~]# blkid /dev/vdb2

  重复格式化
[root@server0 ~]# mkfs.xfs -f /dev/vdb1

三、挂载使用     提供访问点
[root@server0 ~]# mount /dev/vdb1 /part1
mount: 挂载点 /part1 不存在
[root@server0 ~]# mkdir /part1
[root@server0 ~]# mount /dev/vdb1 /part1

[root@server0 ~]# mkdir /part2
[root@server0 ~]# mount /dev/vdb2 /part2

查看当前正在挂载设备的使用情况

[root@server0 ~]# df -h

四、开机自动挂载 /etc/fstab
                                           命令dump
  – 设备路径    挂载点   类型   参数     备份标记   检测顺序
                                                        根分区检测，其他都默认不检测

 补充：vim 命令模式 按 o 可以另起一行 进入插入模式

[root@server0 ~]# vim  /etc/fstab
 /dev/vdb1   /part1    ext4    defaults 0 0
 /dev/vdb2   /part2    xfs     defaults 0 0

[root@server0 ~]# df -h
[root@server0 ~]# umount /part1
[root@server0 ~]# umount /part2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a
[root@server0 ~]# df -h
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载

五、综合分区
  最终有3个主分区，分别为2G、2G、1G
  创建扩展分区
  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +1G
   p 查看分区表
   n 创建扩展分区 
                   ----->回车---->起始回车----->结束回车  将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe  刷新所有分区 
[root@server0 ~]# lsblk
[root@server0 ~]# ls /dev/vdb[1-6]

   /dev/sda5: SCSI接口的第一块硬盘的第一个逻辑分区

####################################################
总结：
   1.查看所有的硬盘设备   lsblk
   2.进行分区        fdisk
   3.刷新分区        partprobe
   4.进行格式化     mkfs.ext4  mkfs.xfs
   5.查看是否有文件系统    blkid
   6.完成挂载        mount   
   7.书写/etc/fstab完成开机自动挂载
   8.进行mount -a测试
   9.查看是否挂载成功  df  -h

###################################################
添加一个80G新虚拟磁盘

[root@room9pc01 ~]# gos

[root@server0 ~]# lsblk
 
 vdc    253:32   0  80G  0 disk
 
综合分区：
   三个主分区，分别10G
   创建扩展分区
   两个逻辑分区，分别10G
[root@server0 ~]# fdisk  /dev/vdc  
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         连续创建3个10G主分区
      ......
   n 创建扩展分区 
                   ----->回车---->起始回车----->结束回车  将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 

#######################################################
LVM逻辑卷的管理

   作用： 1.可以整合分散的空间   2.空间可以扩大

创建思路：

     零散空闲存储 ---->整合的虚拟磁盘 ---->虚拟的分区

     物理卷（PV）     卷组（VG）     逻辑卷（LV）

  将众多的 物理卷(PV)组成卷组(VG)，再从卷组(VG)划分出逻辑卷(LV）

   蒸馒头：
      面粉--------->大面团-------->小面团------->蒸------->吃

   房子：
      砖--------->大房子-------->打隔断-------->装修------->入住

####################################################
  
一、创建逻辑卷

1.直接创建卷组
  格式：vgcreate 卷组名   分区路径

[root@server0 ~]# vgcreate nsd /dev/vdc[1-2]
[root@server0 ~]# pvs   #显示物理卷信息
[root@server0 ~]# vgs   # 显示卷组信息

2.创建逻辑卷
  格式：lvcreate -L 大小    -n  逻辑卷名称     基于的卷组名

[root@server0 ~]# lvcreate -L 16G -n mylv  nsd
[root@server0 ~]# vgs
[root@server0 ~]# lvs

3.逻辑卷的使用
[root@server0 ~]# ls /dev/nsd/mylv         #查看逻辑卷设备
[root@server0 ~]# ls -l /dev/nsd/mylv
[root@server0 ~]# mkfs.ext4 /dev/nsd/mylv   #格式化
[root@server0 ~]# blkid  /dev/nsd/mylv

[root@server0 ~]# vim  /etc/fstab 
/dev/nsd/mylv  /lvm   ext4   defaults   0  0

[root@server0 ~]# mkdir /lvm
[root@server0 ~]# mount -a
[root@server0 ~]# df -h

####################################################
逻辑卷的扩展,支持线上操作

一、卷组有足够的剩余空间

1.直接扩展逻辑卷空间
[root@server0 ~]# vgs
[root@server0 ~]# lvs
[root@server0 ~]# lvextend -L 18G /dev/nsd/mylv 
[root@server0 ~]# lvs

2.扩展文件系统的大小（刷新文件系统的大小）
    扩展ext4文件系统：resize2fs
    扩展xfs文件系统：xfs_growfs

[root@server0 ~]# df -h
[root@server0 ~]# resize2fs /dev/nsd/mylv 
[root@server0 ~]# df -h

二、卷组没有足够的剩余空间

1.扩展卷组空间
[root@server0 ~]# vgextend nsd /dev/vdc3
[root@server0 ~]# vgs

2.直接扩展逻辑卷空间
[root@server0 ~]# lvs
[root@server0 ~]# lvextend -L 25G /dev/nsd/mylv 
[root@server0 ~]# lvs

3.扩展文件系统的大小（刷新文件系统的大小）

[root@server0 ~]# df -h
[root@server0 ~]# resize2fs /dev/nsd/mylv 
[root@server0 ~]# df -h

#######################################################
逻辑卷补充内容：
  ext4：支持缩减
   xfs：不支持缩减

一、逻辑卷的缩减，不支持线上操作
  1.文件系统的缩减
[root@server0 ~]# resize2fs /dev/nsd/mylv 10G
[root@server0 ~]# umount /lvm
[root@server0 ~]# resize2fs /dev/nsd/mylv 10G
resize2fs 1.42.9 (28-Dec-2013)
请先运行 'e2fsck -f /dev/nsd/mylv'.

[root@server0 ~]# e2fsck -f /dev/nsd/mylv
[root@server0 ~]# resize2fs /dev/nsd/mylv 10G

  2.空间的缩减
[root@server0 ~]# lvreduce -L 10G /dev/nsd/mylv 
  WARNING: Reducing active logical volume to 10.00 GiB
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce mylv? [y/n]: y
  Reducing logical volume mylv to 10.00 GiB
  Logical volume mylv successfully resized
[root@server0 ~]# lvs

###################################################
  PE：卷组划分空间的单位
--lvcreate -l PE个数  -n 逻辑卷名 卷组名
[root@server0 ~]# vgdisplay nsd   #显示nsd卷组详细信息

  PE Size               4.00 MiB


  请创建一个大小为250M逻辑卷为lvtest01

[root@server0 ~]# vgchange -s 1M nsd

[root@server0 ~]# vgdisplay 

[root@server0 ~]# lvcreate -L 250M -n lvtest01 nsd

[root@server0 ~]# lvs

[root@server0 ~]# vgchange -s 16M nsd

[root@server0 ~]# lvcreate -l 50 -n lvtest02 nsd

  -l :指定PE个数

##################################################
  逻辑卷的删除
    删除的顺序：先删除逻辑卷,再删除卷组，最后删除物理卷
   

[root@server0 ~]# lvremove /dev/nsd/mylv 
  Logical volume nsd/mylv contains a filesystem in use.
[root@server0 ~]# umount /lvm

[root@server0 ~]# lvremove /dev/nsd/mylv 
Do you really want to remove active logical volume m



2222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222
真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################
Shell脚本
    
    脚本：一个可以执行的文件，可以实现某种功能

[root@server0 ~]# vim  /root/hello.sh
echo hello world

[root@server0 ~]# chmod  +x  /root/hello.sh
 
[root@server0 ~]# /root/hello.sh    #绝对路径执行



###################################################
                #！/bin/bash   1，专业 2，打铺垫 3，考试时有分数
规范Shell脚本的一般组成
 • #! 环境声明  不写的话，默认/bin/bash  为以后学习python打铺垫
 • # 注释文本                                用其他语言必须要写，区分
 • 可执行代码
                               .sh 结尾，标志这是一个shell脚本     
[root@server0 ~]# vim  /root/system.sh 
 #!/bin/bash
 cat  /etc/redhat-release
 uname -r
 hostname
 ifconfig | head -2

 [root@server0 ~]# chmod +x /root/system.sh 

 [root@server0 ~]# /root/system.sh 

#######################################################

管道传递
• 使用 | 管道操作
– 将前一条命令的标准输出交给后一条命令处理


重定向输出
      > : 正确信息的重定向，只收集前面命令的正确输出
     2>: 错误信息的重定向，只收集前面命令的错误输出
     &>:正确与错误信息的重定向，收集前面命令的正确与错误输出

[root@server0 ~]# echo 123 > /opt/1.txt

[root@server0 ~]# cat /opt/1.txt /etc

[root@server0 ~]# cat /opt/1.txt /etc  >  /mnt/a.txt
[root@server0 ~]# cat /mnt/a.txt 

[root@server0 ~]# cat /opt/1.txt /etc  2>  /mnt/a.txt
[root@server0 ~]# cat /mnt/a.txt 
 
[root@server0 ~]# cat /opt/1.txt /etc  &> /mnt/a.txt
[root@server0 ~]# cat /mnt/a.txt

########################################################
  用于收集不要的命令输出，黑洞设备：/dev/null
 
[root@server0 ~]# vim  /root/user.sh

 #!/bin/bash
 useradd  nsd06  &>  /dev/null
 echo  用户nsd06创建成功
 echo  123  |  passwd  --stdin  nsd06  &> /dev/null
 echo  用户nsd06密码设置成功

[root@server0 ~]# chmod +x /root/user.sh

[root@server0 ~]# /root/user.sh


#################################################

 为了增加脚本灵活度，脚本适应多变的环境，方便重复使用一个值.所以使用变量

  变量：会变化的量， 相当于一个容器，存放可以变化的值
            以不变的名称，存放可以变化的值
  $变量名：调用变量储存的值

 [root@server0 ~]# vim /root/user.sh
 #!/bin/bash
 a=nsd10
 useradd  $a  &>  /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd --stdin  $a  &> /dev/null
 echo  用户$a密码设置成功

 [root@server0 ~]#  chmod +x  /root/user.sh
 [root@server0 ~]#  /root/user.sh



########################################################
  产生一个交互式问答，降低脚本使用难度，脚本更加的灵活

 read : 产生一个交互式问答, 
  可以记录用户在键盘的输入，并且会将用户在键盘的输入，赋值给变量储存


[root@server0 ~]# vim  /root/user.sh
 #!/bin/bash
 read -p  '请输入您要创建的用户名:'     a
 useradd  $a   &> /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd  --stdin  $a  &> /dev/null
 echo  用户$a密码设置成功

######################################################

变量的定义/引用

• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值


• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo  $变量名、echo  ${变量名}

[root@server0 ~]# a=rhel
[root@server0 ~]# echo $a

[root@server0 ~]# echo $a7

[root@server0 ~]# echo ${a}7
补充：
  $[ ] :代表运算

[root@server0 ~]# echo $[1+1]
[root@server0 ~]# echo $[4+1]
[root@server0 ~]# echo $[10/3]
[root@server0 ~]# echo $[10%3]      #取余数运算
[root@server0 ~]# echo $[4*2]

 余数运算： 余数一定小于除数


  $( )与反撇号  ` ` ： 将命令的输出结果，作为命令的参数
[root@server0 opt]# date
[root@server0 opt]# date +%F
[root@server0 opt]# cd /opt

[root@server0 opt]# mkdir  dir-$(date +%F)
[root@server0 opt]# ls

[root@server0 opt]# mkdir $(hostname)-$(date +%F)
[root@server0 opt]# ls

   ' ' :取消所有shell中特殊字符意义，原样输出
##################################################
系统定义，用户直接使用

  储存随机数的变量：RANDOM

  请显示 10以内的随机数字 [0-9]?
  余数运算： 余数一定小于除数

[root@server0 /]# echo $[$RANDOM%10]

[root@server0 /]# echo $[$RANDOM%100]

###################################################
环境变量，由系统定义完成

   USER=当前登陆的用户名

[root@server0 /]# echo $USER
root
[root@server0 /]# su - nsd01
[nsd01@server0 ~]$ echo $USER
nsd01
[nsd01@server0 ~]$ exit
logout
[root@server0 /]# 

位置变量
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. 

   read -p  :  可以在脚本运行的时候，从命令行传递变量的值

     位置变量   :  可以在脚本运行的时候，从命令行传递变量的值（非交互）

[root@server0 /]# vim /root/1.sh
  #!/bin/bash
  echo $1
  echo $2
  echo $3

[root@server0 /]#  /root/1.sh  test01  harry   180

[root@server0 /]# vim /root/cat.sh 
  #!/bin/bash
  cat -n $1  | head -$2

[root@server0 /]# /root/cat.sh /etc/passwd  2


预定义变量
• 用来保存脚本程序的执行信息
– 直接使用这些变量
– 不能直接为这些变量赋值

	$#  已加载的位置变量的个数
	$*  所有位置变量的值,再重新输出一遍
	$?  程序退出后的状态值,0表示正常,其他值异常

 [root@server0 /]# vim /root/1.sh 
  #!/bin/bash
  echo $1
  echo $2
  echo $3
  echo $#            #统计位置变量的个数
  echo $*            #输出所有位置变量的值

[root@server0 /]# /root/1.sh haha xixi hehe lele
 haha
 xixi
 hehe
  4
 haha xixi hehe lele

[root@server0 /]# useradd natasha
[root@server0 /]# echo $?
0
[root@server0 /]# id natasha
uid=1020(natasha) gid=1020(natasha) 组=1020(natasha)
[root@server0 /]# echo $?
0
[root@server0 /]# id haxi
id: haxi: no such user
[root@server0 /]# echo $?
1
[root@server0 /]# useradd natasha
useradd：用户“natasha”已存在
[root@server0 /]# echo $?
9
[root@server0 /]# 

#####################################################
条件测试

  [  测试表达式  ]      #每一部分都要有空格

 • 检查文件状态
	-e：判断文档是否存在，存在为真
	-d：存在并且为目录为真
	-f：存在并且为文件为真
	-r：存在并且对其有读取权限为真
	-w：存在并且对其有写入权限为真
	-x：存在并且对其有执行权限为真


[root@server0 /]# [ -e /etc ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ -d /etc/passwd ]
[root@server0 /]# echo $?
1
[root@server0 /]# [ -f /etc/passwd ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ -f /etc/ ]
[root@server0 /]# echo $?
1
[root@server0 /]# [ -e /abcd ]
[root@server0 /]# echo $?



• 比较整数大小( 带e字母的都有等于二字)
	-gt:大于
	-ge:大于等于   
	-eq:等于         
	-ne:不等于
	-lt:小于
	-le:小于等于
[root@server0 /]# [ 1 -eq  1 ]
[root@server0 /]# echo $?

[root@server0 /]# [ 1 -gt 2 ]
[root@server0 /]# echo $?

[root@server0 /]# [ 1 -gt 1 ]
[root@server0 /]# echo $?

[root@server0 /]# [ 1 -ge 1 ]
[root@server0 /]# echo $?

• 字符串比对
   ==: 字符串相等为真
   !=:字符串不相等为真

[root@server0 /]# [  root   ==  student  ]
[root@server0 /]# echo $?

[root@server0 /]# [  root   ==  root  ]
[root@server0 /]# echo $?

[root@server0 /]# [  $USER  ==  root  ]
[root@server0 /]# echo $?

[root@server0 /]# [  student  != root  ]
[root@server0 /]# echo $?

###################################################
if选择结构

if双分支

    if  [条件测试];then
               执行的语句01
     else
               执行的语句02
    fi

案例： 
          用户输入一个IP地址，判断本机是否可以与这个IP地址通信
          如果 可以通信，则输出   可以通信
          如果 不可以通信，则输出  不可以通信   
   
[root@server0 /]# vim  /root/ip.sh 
    #!/bin/bash
    read  -p  '请输入您要测试的IP地址:'     ip
    ping  -c  2  $ip  &>  /dev/null    read:为变量ip赋值
        
    if  [  $?  -eq  0 ];then
          echo $ip 可以通信
    else
          echo $ip 不可以通信   
    fi

案例：
       用户输入一个0到9之间数字，计算机随机产生一个0到9之间数字
       如果 用户输入数字与计算机随机产生数字相等，则输出 您猜对了
       如果 用户输入数字与计算机随机产生数字不相等，则输出 您猜错了

[root@server0 /]# vim /root/num.sh
    #!/bin/bash
    read  -p  '请输入一个0到9之间数字:'     num1
    num2=$[$RANDOM%10]     #随机产生一个0到9之间数字,赋值给num2
     
     if  [  $num2  -eq  $num1  ];then
            echo 您猜对了
       else
            echo 您猜错了
            echo 正确的数字为 $num2
     fi

#####################################################
if多分支处理

  if [条件测试1];then
     命令序列xx

  elif [条件测试2];then
     命令序列yy

  elif [条件测试3];then
     命令序列aa

  else
      命令序列zz
  fi

 案例：
         用户输入成绩：
            如果成绩大于等于90，则输出 优秀
            如果成绩大于等于80，则输出 良好
            如果成绩大于等于70，则输出 合格
            如果成绩大于等于60，则输出 仍需努力
            以上条件均不满足，则输出  在牛的肖邦，也弹不出哥的悲伤

[root@server0 /]# vim  /root/if03.sh
	#!/bin/bash
	read  -p  '请输入您的成绩:'      num
	if [  $num  -ge  90  ];then
	  echo  优秀
	elif  [  $num  -ge  80  ];then
	  echo  良好
	elif  [  $num  -ge  70  ];then
	  echo  合格
	elif  [  $num  -ge  60  ];then
	  echo  仍需努力
	else
	  echo  在牛的肖邦，也弹不出哥的悲伤
	fi

################################################
 
案例：
       用户输入一个0到9之间数字，计算机随机产生一个0到9之间数字
       如果 用户输入数字与计算机随机产生数字相等，则输出 您猜对了

       如果 用户输入数字比计算机随机产生数字大，则输出 您猜大了

       如果 用户输入数字比计算机随机产生数字小，则输出 您猜小了

[root@server0 /]# vim /root/num.sh
    #!/bin/bash
    read  -p  '请输入一个0到9之间数字:'     num1
    num2=$[$RANDOM%10]    
     
     if  [  $num2  -eq  $num1  ];then
            echo 您猜对了
     elif  [  $num1  -gt  $num2  ];then
             echo 您猜大了
             echo 正确的数字为 $num2 
     else
             echo 您猜小了
             echo 正确的数字为 $num2 
     fi


案例：
   在上个案例的基础上，让用户可以猜三次

 #!/bin/bash
 num2=$[$RANDOM%10]
 for  i   in   {1..5}
 do
 read  -p  '请输入一个0到9之间数字:'     num1

 if  [  $num2  -eq  $num1  ];then
       echo 您猜对了
       exit
 elif  [ $num1 -gt $num2 ];then
       echo 您猜大了
 else
       echo 您猜小了
 fi
 done




造数工具  {  起始..结尾 }
格式为{2..10} 中间两个点，不能改.大括号和数字见也不能有空格
{a..f}连续的英文字母也可以执行

for循环结构

• 给定一批对象,反复执行类似的操作

  for 变量名 in 值列表
  do
    命令序列
  done


[root@server0 /]# vim /root/for.sh
 #!/bin/bash
 for  a   in  zhangsan  lisi   wangwu 
 do
   useradd  $a  &>  /dev/null
   echo   $a创建成功
 done


######################################################

 循环内容可以于循环的列表值无关

[root@server0 /]# cat /root/for2.sh
#!/bin/bash
for i in 1 2 3
do
  echo hello
done


333333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333333
333333333333333333333333333333333333333333333333333333333333


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

########################################################
 >&2 ： 将正确输出的信息，信息的性质改为错误，输出信息内容不变原样输出

案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者
fedora时,其错误输出产生以下信息:   /root/foo.sh redhat|fedora

[root@server0 ~]# vim /root/foo.sh 
 #!/bin/bash
 if [  $#  -eq  0  ];then
   echo  '/root/foo.sh  redhat|fedora'  >&2 
     #将正确输出变成错误输出
     exit  3
 elif [  $1  ==  redhat  ];then
   echo fedora

 elif  [  $1  ==  fedora  ];then
   echo redhat

 else
   echo  '/root/foo.sh  redhat|fedora'  >&2
     exit 4
 fi

###################################################
案例5:编写一个批量添加用户脚本

在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示 
Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
 http://classroom.example.com/pub/materials/userlist


[root@server0 /]# vim  /root/userlist 
zhangsan
lisi
wangwu 
dc
tc

[root@server0 /]# vim  /root/batchusers
 #!/bin/bash
 for i  in  `cat  /root/userlist`   `` 或 $() 将命令的输出结果作为
 do                                          参数输出
  useradd $i
  echo $i创建成功
 done


[root@server0 /]# vim  /root/batchusers
#!/bin/bash
if  [ -f $1 ];then
for i  in  `cat  $1`
do
 useradd $i 2> /dev/null
 echo $i创建成功
done
else
   echo Input file not found  >&2
   exit 2
fi



[root@server0 /]# vim  /root/batchusers
	#!/bin/bash
	if [ $# -eq 0 ];then        #判断是否输入参数
		 echo 'Usage: /root/batchusers' >&2
		 exit 3

	elif  [ -f $1 ];then        #判断文件是否存在

		for i  in  `cat  $1`
		do
		 useradd -s /bin/false $i 2> /dev/null
		 echo $i创建成功
		done

	else
		   echo Input file not found   >&2
		   exit 2
	fi

######################################################

系统安全保护

SELinux安全机制

• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系


• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

–  变成disabled(彻底禁用)状态，都需要重起机器


• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件


虚拟机Server
[root@server0 /]# getenforce       #查看当前的状态
Enforcing
[root@server0 /]# setenforce 0     #当前修改为Permissive
[root@server0 /]# getenforce 
Permissive
[root@server0 /]# vim /etc/selinux/config#每次开机状态配置文件
SELINUX=permissive

虚拟机Desktop
[root@desktop0 /]# getenforce 
Enforcing
[root@desktop0 /]# setenforce 0
[root@desktop0 /]# getenforce 
Permissive
[root@desktop0 /]# vim /etc/selinux/config
SELINUX=permissive
#####################################################

配置用户环境,永久别名的设置

• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效


• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

虚拟机server：

[root@server0 /]# vim /root/.bashrc   #针对于root生效
alias hello='echo hello'

[root@server0 /]# vim /home/student/.bashrc  #针对于student
alias hi='echo hi'

[root@server0 /]# vim /etc/bashrc   #针对于所有用户
alias haxi='echo hahaxixi'

再开一个新的终端验证
root用户能够执行：hello、haxi

student用户能够执行：hi、haxi

######################################################
配置IPv6地址

     IP地址：唯一标识网络中一台主机

 IPv4地址:  32个二进制组成   以点分隔4部分  最终用4个十进制数表示


 IPv6地址:  128个二进制组成  以 冒号 分隔8部分  最终用4个16进制数表示

   每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::




为两个虚拟机的接口 eth0 配置下列 IPv6 地址
– server0 上的地址应该是 2003:ac18::305/64

虚拟机Server0
[root@server0 ~]# nmcli connection modify 'System eth0' ipv6.method manual ipv6.addresses 2003:ac18::305/64 connection.autoconnect yes

[root@server0 ~]# nmcli connection up 'System eth0'

[root@server0 ~]# ifconfig | less

[root@server0 ~]# ping6 2003:ac18::305

######################################################
配置聚合连接(链路聚合  网卡绑定  网卡组队  )
      
      解决网卡的单点故障
      网卡设备热备份       

• team,聚合连接(也称为链路聚合)
– 由多块网卡(team-slave)一起组建而成的虚拟网卡,即“组队”

– 作用:热备份(activebackup)连接冗余
 1.创建虚拟网卡,参考 man teamd.conf  # /example  全文搜索example
# nmcli  connection  add  type  team     
 con-name  team0  ifname  team0  autoconnect  yes          
 config  '{"runner": {"name": "activebackup"}}'

# nmcli  connection 添加    类型    组队
  配置文件的名字为  team0  ifconfig显示名字为  team0  每次开机自启动
  工作模式配置  热备份方式

# ifconfig  查看team0网卡
#  nmcli connection delete team0   #删除

2.添加成员
# nmcli connection add type team-slave 
con-name team0-1 ifname  eth1   master team0

# nmcli connection add  type team-slave 
con-name team0-2 ifname  eth2  master team0

# nmcli connection 添加   类型    组队-奴隶
  配置文件名 team0-1  网卡名为 eth2  主设备为  team0

删除的配置
# nmcli connection delete team0-1  
# nmcli connection delete team0-2

3.配置IP地址
# nmcli connection modify team0          
  ipv4.method manual ipv4.addresses 192.168.1.1/24     
  connection.autoconnect  yes

4.激活所有配置
[root@server0 ~]# nmcli connection up team0
[root@server0 ~]# nmcli connection up team0-1
[root@server0 ~]# nmcli connection up team0-2

[root@server0 ~]# teamdctl team0 state   #查看team0信息
 
#####################################################
[root@server0 ~]# ifconfig  eth1   down    #禁用网卡
[root@server0 ~]# teamdctl  team0  state

####################################################
搭建基本Web服务

  Apache(httpd)  Nginx并发量    TOMCAT（Java）
  Nginx在并法量上比较优秀，对我国的现状，有取代Apache的可能

服务端虚拟机Server0：

1.安装一个httpd软件    Apache(httpd)  
[root@server0 ~]# yum  -y  install  httpd

2.重起服务即可
[root@server0 ~]# systemctl  restart httpd     

3.书写一个页面文件
   默认存放页面文件的路径：/var/www/html
   默认页面文件的名字： index.html
  html网页语言

[root@server0 ~]# vim /var/www/html/index.html
<h1><font color=red><marquee>NSD1805
最大字体   字体颜色          滚动


客户端：虚拟机Server0
[root@server0 ~]# firefox   172.25.0.11

#################################################

虚拟机Server0：搭建基本FTP服务(主要用于文件、数据传输)
1.安装一个vsftpd软件
[root@server0 ~]# yum -y install vsftpd

2.重起服务
[root@server0 ~]# systemctl  restart  vsftpd

3.测试：
[root@server0 ~]# firefox ftp://172.25.0.11

 默认vsftpd共享数据的路径：/var/ftp

#####################################################
防火墙
    作用：隔离  过滤所有入站请求，允许出站

    硬件防火墙 ~~~整个公司，大范围的


    软件防火墙 ～～软件，防护一台机器(firewalld)

RHEL7的防火墙体系(隔离)
• 系统服务:firewalld
• 管理工具:firewall-cmd（命令）、firewall-config（图形）

• 根据所在的网络场所区分,预设保护规则集 zone 区域
  – public:仅允许访问本机的sshd、ping、dhcp服务
  – trusted:允许任何访问
  – block:阻塞任何来访请求，明确拒绝
  – drop:丢弃任何来访的数据包，直接丢弃，节省资源

• 配置规则的位置
  – 运行时(runtime)
  – 永久(permanent

包：源ip地址   目标ip   数据  访问的端口号

######################################################



4444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444




真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
搭建基本Web服务

服务端虚拟机Server0：
1.安装一个httpd软件    Apache(httpd)  
[root@server0 ~]# yum  -y  install  httpd
2.重起服务即可
[root@server0 ~]# systemctl  restart httpd     

3.书写一个页面文件
   默认存放页面文件的路径：/var/www/html
   默认页面文件的名字： index.html

# echo '<h1>My First Web' > /var/www/html/index.html
# firefox 172.25.0.11

#################################################
虚拟机Server0：搭建基本FTP服务
1.安装一个vsftpd软件
[root@server0 ~]# yum -y install vsftpd

2.重起服务
[root@server0 ~]# systemctl  restart  vsftpd

3.测试：
[root@server0 ~]# firefox ftp://172.25.0.11

 默认vsftpd共享数据的路径：/var/ftp

#####################################################
防火墙
    作用：隔离  过滤所有入站请求，允许出站

    硬件防火墙

    软件防火墙

RHEL7的防火墙体系
• 系统服务:firewalld
• 管理工具:firewall-cmd（命令）、firewall-config（图形）

• 根据所在的网络场所区分,预设保护规则集 zone 区域
  – public:仅允许访问本机的sshd、ping、dhcp服务
  – trusted:允许任何访问
  – block:阻塞任何来访请求，明确拒绝
  – drop:丢弃任何来访的数据包，直接丢弃，节省资源

防火墙判断的规则： 匹配及停止
1.首先看客户端请求中源IP地址,查阅自己所有的区域，那个区域中有对此源IP地址的规则，则进入该区域

2.进入默认区域（public）
                                                             永久(permanent)
######################################################
默认区域的应用

虚拟机server0
# firewall-cmd --get-default-zone   #查看默认区域
虚拟机desktop0
# ping  172.25.0.11  #可以通信

虚拟机server0
# firewall-cmd --set-default-zone=block   #修改默认区域
# firewall-cmd --get-default-zone 
虚拟机desktop0
# ping  172.25.0.11  #不可以通信，有回应

虚拟机server0
# firewall-cmd --set-default-zone=drop    #修改默认区域
# firewall-cmd --get-default-zone 
虚拟机desktop0
# ping  172.25.0.11  #不可以通信，没有回应
####################################################
服务的添加
虚拟机server0：
# firewall-cmd --set-default-zone=public 
# firewall-cmd --zone=public --list-all
# firewall-cmd --zone=public --add-service=http
# firewall-cmd --zone=public --list-all
虚拟机desktop0:
#  firefox 172.25.0.11        #可以访问
#  firefox ftp://172.25.0.11  #不可以访问

虚拟机server0：
# firewall-cmd --zone=public --add-service=ftp
# firewall-cmd --zone=public --list-all
虚拟机desktop0:
#  firefox 172.25.0.11        #可以访问
#  firefox ftp://172.25.0.11  #可以访问

######################################################
实现永久设置规则

 – 永久(permanent)
# firewall-cmd --reload        #重新加载防火墙配置
# firewall-cmd --zone=public --list-all 

# firewall-cmd --permanent --zone=public --add-service=http
# firewall-cmd --reload 
# firewall-cmd --zone=public --list-all 

# firewall-cmd --permanent --zone=public --add-service=ftp
# firewall-cmd --reload 
# firewall-cmd --zone=public --list-all 
#####################################################
 常见服务：
         http:   超文本传输协议           默认的端口号：80
         https:  安全超文本传输协议   默认的端口号：443
         DNS:    域名解析                     默认的端口号：53
         telnet： 远程管理               默认的端口号：23
         FTP：   文件传输协议              默认的端口号：21
         tftp：  简单文件传输协议       默认的端口号：69
         SMTP：  邮件协议，发邮件      默认的端口号：25
         pop3：  邮件协议，收邮件      默认的端口号：110
         SNMP：  简单网络管理协议      默认的端口号：161


  端口号：标识服务，标识程序

###################################################

实现本机的端口映射
• 本地应用的端口重定向(端口1 --> 端口2)
– 从客户机访问 端口1 的请求,自动映射到本机 端口2
– 比如,访问以下两个地址可以看到相同的页面:
 http://172.25.0.11:5423/--> http://172.25.0.11:80/

虚拟机server0：
# firewall-cmd --permanent --zone=public 
--add-forward-port=port=5423:proto=tcp:toport=80

# firewall-cmd  --reload 
# firewall-cmd  --zone=public --list-all 

虚拟机desktop0：
# firefox  172.25.0.11:5423

######################################################
删除：

# firewall-cmd --permanent --zone=public 
--remove-forward-port=port=5423:proto=tcp:toport=80
# firewall-cmd  --reload

#####################################################
首先修改防火墙默认区域

虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

######################################################
Samba服务基础～～～～～～反向编译的思想（windows）跨平台的软件

– 用途:为客户机提供共享使用的文件夹 (跨平台的共享,Windows与Linux）

• 所需软件包:samba
• 系统服务:smb
– 协议:SMB(TCP 139)、    CIFS(TCP 445)
       服务端-客户端沟通         传输数据
管理共享账号
• Samba用户 —— 专用来访问共享文件夹的验证用户
– 采用独立设置的密码
– 但需要提前建立同名的系统用户(可以不设密码)

• 使用 pdbedit 管理工具
– 添加用户:pdbedit -a 用户名
– 查询用户:pdbedit -L [用户名]
– 删除用户:pdbedit -x 用户名

配置文件及参数
• 修改 /etc/samba/smb.conf
[global]
//全局设置
workgroup = 工作组名

[自定共享名]
path = 文件夹绝对路径





服务端：虚拟机Server0：
1.安装samba软件
[root@server0 ~]# yum -y install samba

2.建立Samba共享帐号                  不能登陆操作系统
[root@server0 ~]# useradd -s /sbin/nologin harry
[root@server0 ~]# useradd -s /sbin/nologin kenji
[root@server0 ~]# useradd -s /sbin/nologin chihiro

[root@server0 ~]# pdbedit -a harry    #添加harry为共享帐号
[root@server0 ~]# pdbedit -a kenji    #根据提示设置2次密码
[root@server0 ~]# pdbedit -a chihiro

[root@server0 ~]# pdbedit -L    #查看所有共享帐号

3.修改 /etc/samba/smb.conf主配置文件

  -发布目录  /common ,共享名为 common

[root@server0 ~]# mkdir  /common
[root@server0 ~]# echo 123  > /common/1.txt
[root@server0 ~]# ls  /common/

补充：vim 命令模式下   按G（大写）到全文的最后一行
[root@server0 ~]# vim  /etc/samba/smb.conf 

        workgroup = STAFF   #修改工作组 （可忽略不写，仅作了解）

[common]
path = /common

4.重起smb服务
[root@server0 ~]# systemctl restart smb
[root@server0 ~]# systemctl enable smb   #设置为开机自启动

5.SELinux策略修改，布尔值功能的开关
   – 需要加 -P 选项才能实现永久设置(需要内存支持)

 # getsebool -a | grep samba   #查看所有布尔值

 # setsebool samba_export_all_ro on  #允许所有人只读访问samba
 # getsebool -a | grep samba


客户端：虚拟机desktop0
1. 所需软件包:samba-client(客户端软件)～仅初次看samba用一下，都不用

2.利用smbclient 访问
[root@desktop0 ~]# smbclient -L  //172.25.0.11/  #列出共享

[root@desktop0 ~]# smbclient -U harry //172.25.0.11/common
Enter harry's password: 
smb: \> 

#######################################################
客户端访问服务端：
   1.服务端 防火墙的配置
   2.服务端 SELinux策略      三大策略1，布尔值  2，？ 3，？
   3.服务端 服务本身的访问控制
   4.服务端 本地目录权限



#################################################
通过挂载，更加科学方便的访问Samba共享

虚拟机desktop0
1.安装cifs-utils软件包（支持cifs协议）
[root@desktop0 ~]# yum -y install cifs-utils

2.进行挂载
[root@desktop0 ~]# mkdir /mnt/nsd01

# mount -o user=harry,pass=123 //172.25.0.11/common  /mnt/nsd01/ 

[root@desktop0 ~]# df -h
[root@desktop0 ~]# ls /mnt/nsd01

3.开机自动挂载samba共享/etc/fstab

   _netdev:声明网络设备
     在开机启动时，该设备为网络设备，请先部署网络所有服务，具备网络参数(ip地址)后，再挂载此设备
                    （文件名）
 //172.25.0.11/common   /mnt/nsd01  cifs
 defaults,user=harry,pass=123,_netdev  0  0

[root@desktop0 ~]# umount /mnt/nsd01
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount  -a
[root@desktop0 ~]# df -h

######################################################
搭建读写的Samba共享

服务端：虚拟机Server0

1.修改配置文件/etc/samba/smb.conf
[root@server0 ~]# mkdir /devops
[root@server0 ~]# echo haha > /devops/2.txt
[root@server0 ~]# ls /devops/

[root@server0 ~]# vim  /etc/samba/smb.conf   #追加写入
......
[devops]                  #共享名
path = /devops            #共享实际路径
write list = chihiro      #允许chihiro可以写

2.重起smb服务
[root@server0 ~]# systemctl restart smb

3.修改SELinux策略
[root@server0 ~]# getsebool -a | grep samba
[root@server0 ~]# setsebool samba_export_all_rw on
[root@server0 ~]# getsebool -a | grep samba

4.赋予chihiro本地目录权限

[root@server0 ~]# setfacl -m u:chihiro:rwx /devops
[root@server0 ~]# getfacl /devops

客户端：虚拟机Desktop0
1.实现开机自动挂载
[root@desktop0 ~]# vim /etc/fstab 

 //172.25.0.11/devops  /mnt/nsd02   cifs 
 defaults,user=chihiro,pass=123,_netdev 0 0

[root@desktop0 ~]# mount  -a 
[root@desktop0 ~]# df  -h

#####################################################
multiuser机制,主要为普通用户设计

多用户Samba挂载
   客户端以权限较小的用户验证samba共享
   在必要的时候普通用户，可以通过命令更改验证用户身份，获得写入权限


• mount.cifs 的挂载参数
– multiuser,提供对客户端多个用户身份的区分支持
– sec=ntlmssp,提供NT局域网管理安全支持

[root@desktop0 ~]# vim /etc/fstab 

//172.25.0.11/devops /mnt/nsd02 cifs defaults,user=kenji,pass=123,_netdev,multiuser,sec=ntlmssp  
  0 0

[root@desktop0 ~]# umount /mnt/nsd02

[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
[root@desktop0 ~]# su - student
[student@desktop0 ~]$ cd /mnt/nsd02

$ cifscreds  add  -u  chihiro    172.25.0.11
Password: 

[student@desktop0 nsd02]$ touch 66.txt
[student@desktop0 nsd02]$ exit

#####################################################



55555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555


classroom   WEB服务端装包讲解

真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
防火墙：
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

#####################################################

iSCSI网络磁盘

一、进行分区
[root@server0 ~]# lsblk             #查看当前所有硬盘
[root@server0 ~]# fdisk /dev/vdb
  3G的主分区    2G主分区   1G主分区
    划分扩展分区
  1G逻辑分区

[root@server0 ~]# partprobe         #刷新分区
[root@server0 ~]# ls /dev/vdb*

iSCSI磁盘的工作模式
• Internet SCSI,网际SCSI接口
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

iqn名字的作用：
– 用来识别 target 磁盘组,也用来识别客户机身份


iSCSI磁盘的构成

• backstore,后端存储     冰箱----->纸箱子(名字)
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称

• target,磁盘组        木质箱子
– 是客户端的访问目标,作为一个框架,由多个lun组成
   
• lun,逻辑单元       【冰箱----->纸箱子】--- 放入---【木质箱子】
– 每一个lun需要关联到某一个后端存储设备,在客户端会视为一块虚拟硬盘

二、虚拟机server0，构建iSCSI共享存储服务端

1.安装软件包:targetcli
2.运行 targetcli  进入iSCSI共享存储配置

3.建立后端存储
  格式：后端存储/块设备   创建    名字       具体设备
  
/> backstores/block  create  name=nsd  dev=/dev/vdb1

/> ls    #查看创建效果
 
4.建立target,磁盘组 （木质箱子）
• ISCSI Qualified Name 名称规范（iqn）
– iqn.yyyy-mm.倒序域名:自定义标识
/> iscsi/ create iqn.2018-06.example.com:server0
/> ls

5. lun,关联  [冰箱----->纸箱子]---【放入】---[木质箱子]
/> iscsi/iqn.2018-06.example.com:server0/tpg1/luns      
   create /backstores/block/nsd 
/> ls
6.开启服务监听的端口，开启监听的本机IP地址
[root@server0 ~]# targetcli 

/> iscsi/iqn.2018-06.example.com:server0/tpg1/portals 
   create  172.25.0.11
/> ls
      iSCSI共享存储默认端口： 3260

7.配置访问控制ACL，设置客户端声称名字

/> iscsi/iqn.2018-06.example.com:server0/tpg1/acls create  
   iqn.2018-06.example.com:desktop0
/> ls
/> exit

iqn名字的作用：
– 用来识别 target 磁盘组,也用来识别客户机身份

8.重起服务
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable  target

##################################################
客户端：虚拟机desktop0

1.安装软件包
[root@desktop0 ~]# yum repolist     #产生Yum的缓存
[root@desktop0 ~]# yum -y install iscsi(tab)
[root@desktop0 ~]# yum -y install iscsi-initiator-utils
                                    #iscsi启动软件包
2.修改配置文件，指定客户端声称的名字
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2018-06.example.com:desktop0

3.重起iscsid服务，仅仅就是刷新iqn名称
[root@desktop0 ~]# systemctl restart iscsid
Warning: Unit file of iscsid.service changed on disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload 
                                       #守护进程-重新安装sicsi服务
[root@desktop0 ~]# systemctl restart iscsid

4.发现服务端共享存储 参考：man  iscsiadm
     ctrl shift + :变大
     ctrl  -  :变小
# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

5.重起iscsi服务,将共享存储加载到本机

# lsblk
# systemctl  restart  iscsi
# lsblk   #可以看到sda

######################################################
数据库服务基础

什么是数据库：存放数据的仓库

  数据库中有很的库，在库里面有很多的表格
 
  表字段 、表记录


部署mariadb数据库服务器
• RHEL7 中的 MariaDB 相关包
– mariadb-server:提供服务端有关的系统程序
– MariaDB默认端口号：3306
– 数据库主配置文件：/etc/my.cnf

一、部署mariadb数据库服务器
1.安装mariadb-server
[root@server0 ~]# yum -y install mariadb-server

2.启动mariadb服务
[root@server0 ~]# systemctl  restart  mariadb
[root@server0 ~]# systemctl  enable  mariadb


二、使用数据库
    默认无需密码直接登陆

[root@server0 ~]# mysql
  > show  databases;    #查看所有的库
  > create  database  nsd1805;  #创建库nsd1805
  > show  databases;    #查看所有的库

  > drop  database  nsd1805;  #删除nsd1805库
  > show  databases;    #查看所有的库

  > create  database  nsd;  #创建库nsd
  > show  databases;    #查看所有的库
  > exit
Bye

三、为数据库管理员 账号修改密码
– mysqladmin [-u用户名]  [-p[旧密码]]  password  '新密码'

  数据库管理员：root 数据库最高权限用户   由数据库mysql库user表保存

  系统管理员：root 系统最高权限用户    /etc/passwd

[root@server0 ~]# mysqladmin -u root password '123'

[root@server0 ~]# mysql -u root -p
Enter password: 

[root@server0 ~]# mysql -u root -p123   #非交互式

四、导入数据库的数据

# wget http://classroom.example.com/pub/materials/users.sql
# ls 

[root@server0 ~]# mysql -u root -p123

MariaDB [(none)]> show databases;
MariaDB [(none)]> exit

[root@server0 ~]# mysql -u root -p123 nsd < users.sql
                将users.sql的数据导入到nsd库中
 
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;     #切换nsd库
MariaDB [nsd]> show tables;    #查看所有表格

###################################################
五、表格操作   增(insert)    删(delete)      改(update)     查(select)

select 表字段  from  表名

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;     #切换nsd库
MariaDB [nsd]> show tables;    #查看所有表格

MariaDB [nsd]> select  *  from base;
MariaDB [nsd]> select  *  from location;

MariaDB [nsd]> desc base;   #查看表结构

MariaDB [nsd]> select id,password from base;
MariaDB [nsd]> select id,name from base;

MariaDB [nsd]> use mysql;
MariaDB [nsd]> desc user;  
MariaDB [nsd]> select  user,host,password  from  user; 

六、数据库授权

– 除了root用户,此nsd数据库只能被用户lisi查询,此用户的密码为123
– 不需要创建本地用户lisi

– GRANT 权限列表  ON 数据库名.表名 TO 用户名@客户机地址
 IDENTIFIED BY '密码';

  grant select on  nsd.*  to  lisi@localhost 
  identified by '123';

  当lisi从localhost本地登陆输入密码123，将会获得nsd数据库中所有表的查询权限

[root@server0 ~]# mysql -u root -p123

MariaDB [(none)]> grant select on nsd.* to lisi@localhost  identified by  '123';


    > select user,host,password from mysql.user;




七、多表查询，有条件的查询，表记录的删出及增加
2. 在系统 server0 上使用数据库 nsd,并使用相
应的 SQL 查询以回答下列问题:
1)密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd;
MariaDB [nsd]> select * from base  where password='solicitous';

MariaDB [nsd]> select name from base  where password='solicitous';

MariaDB [nsd]> select id,name from base  where password='123';

MariaDB [nsd]> select * from base  where name='tom';


2)有多少人的    姓名是 Barbara 同时居住在 Sunnyvale?
      
> select * from base,location    
 where  base.name='Barbara'  and                
 location.city='Sunnyvale'   and                
 base.id=location.id;

> select count(*) from base,location     
 where base.name='Barbara' and                
 location.city='Sunnyvale' and    
 base.id=location.id;              

MariaDB [nsd]> insert base values('6','Barbara','678');
MariaDB [nsd]> select * from base;
MariaDB [nsd]> insert location values('6','Sunnyvale');
MariaDB [nsd]> select * from location;


3. 禁止空密码 root用户访问 mariadb 数据库
[root@server0 ~]# mysql -u root -p123

MariaDB [nsd]> use mysql;

MariaDB [mysql]> select user,host,password from user;

MariaDB [mysql]> select user,host,password from user   where password='';

MariaDB [mysql]> delete from user where password='';

MariaDB [mysql]> select user,host,password from user;

MariaDB [mysql]> flush privileges;   #刷新user表记录


[root@server0 ~]# mysql -u root -h server0.example.com
  最终登陆失败

#####################################################
 



66666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
防火墙：
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

#####################################################
HTTP服务基础

• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页
 
• Hyper Text Markup Language(html),超文本标记语言
• Hyper Text Transfer Protocol(http),超文本传输协议

                                           Ddos(攻击)
                                               并发攻击的一种手段（访问量）
• 软件包:httpd
• 系统服务:httpd

• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)
– DirectoryIndex:起始页/首页文件名(index.html)


##################################################
虚拟机server0
1.安装httpd软件（Apache一个基金会公司的名字，曾经http服务 由Apache构     建而出名）

2.书写网页文件
# echo '<h1>NSD1805' > /var/www/html/index.html

3.重起httpd服务
# systemctl restart httpd


虚拟机desktop0
访问测试: # firefox 172.25.0.11

################################################

ServerName:本站点注册的DNS名称(空缺)

 DNS服务器:classroom.example.com

   server0.example.com
   www0.example.com
   webapp0.example.com

虚拟机Server0
1.修改配置文件
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
ServerName server0.example.com:80   #注释去掉,修改内容

2.重起httpd服务
[root@server0 ~]# systemctl restart httpd

虚拟机desktop0
访问测试: # firefox server0.example.com

#####################################################
[root@server0 ~]# systemctl restart httpd
Job for httpd.service failed. See 'systemctl status httpd.service' and 'journalctl -xn' for details.
重起服务失败




– DocumentRoot:网页文件根目录(默认为/var/www/html)
   
虚拟机server0
# mkdir /var/www/myweb
# echo '<h1>wo shi myweb' > /var/www/myweb/index.html

# vim /etc/httpd/conf/httpd.conf 

DocumentRoot  "/var/www/myweb"

# systemctl restart httpd

虚拟机desktop0
[root@server0 ~]# firefox server0.example.com

################################################
客户端浏览器路径与服务端真实路径的对照

客户端浏览器: firefox server0.example.com/test/

服务端路径:  /var/www/myweb/test/

######################################################
• 配置文件路径
– /etc/httpd/conf/httpd.conf   #主配置文件
– /etc/httpd/conf.d/*.conf     #调用配置文件

虚拟Web主机

• 虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

• 为每个虚拟站点添加配置,容器类型的配置
	<VirtualHost  IP地址:端口>
	  ServerName  此站点的DNS名称
	  DocumentRoot  此站点的网页根目录
     </VirtualHost>


虚拟机Server0:
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName  www0.example.com
  DocumentRoot  /var/www/qq 
</VirtualHost>

<VirtualHost *:80>
  ServerName  webapp0.example.com
  DocumentRoot /var/www/sina
</VirtualHost>

<VirtualHost *:80>
  ServerName server0.example.com
  DocumentRoot /var/www/myweb
</VirtualHost>

[root@server0 /]# mkdir /var/www/qq  /var/www/sina
[root@server0 /]# echo '<h1>企鹅' > /var/www/qq/index.html
[root@server0 /]# echo '<h1>新浪' > /var/www/sina/index.html
[root@server0 /]# systemctl restart httpd

	
   一旦使用虚拟Web主机功能,所有的Web站点都必须用虚拟Web主机来实现

#######################################################
访问控制

• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置


<Directory 目录的绝对路径>
.. ..
Require all denied|granted
Require ip IP或网段地址 .. ..
</Directory>


案例:
在 Web 网站 http://server0.example.com 的
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:
仅允许本机访问

虚拟机Server0:
# mkdir /var/www/myweb/private
# echo '<h1>woshi private' > /var/www/myweb/private/index.html

# vim /etc/httpd/conf.d/nsd02.conf 
<Directory  "/var/www/myweb/private">
    Require ip 172.25.0.11   #仅允许172.25.0.11
</Directory>
 
# systemctl  restart   httpd

虚拟机desktop0:
# firefox server0.example.com/private   #访问权限不足
虚拟机server0:
# firefox server0.example.com/private   #访问成功
#######################################################


案例:使用自定Web网页文件的根目录
调整 Web 站点 http://server0.example.com 的网页目录
要求如下:

虚拟机Server0:
1)新建目录 /webroot,作为此站点新的网页目录

# mkdir /webroot
# echo '<h1>wo shi webroot' > /webroot/index.html
# ls /webroot

2)修改配置文件/etc/httpd/conf.d/nsd01.conf  #修改不是追加
 <VirtualHost *:80>
   ServerName server0.example.com
   DocumentRoot /webroot
 </VirtualHost>

3)修改配置文件/etc/httpd/conf.d/nsd02.conf  #添加访问控制
 <Directory "/webroot">
     Require all granted       #允许所有客户端
 </Directory>

4)重起httpd服务
[root@server0 /]# systemctl restart httpd


5)修改SELinux策略,安全上下文值(标签值:标识作用)
   以/var/www 为模版修改/webroot/的标签值

 # ls -Zd  /var/www    #专业查看SELinux安全上下文值
 # ls -Zd  /webroot    #专业查看SELinux安全上下文值
 
 # chcon -R  --reference=/var/www    /webroot/

 # ls -Zd /webroot/

虚拟机desktop0:
# firefox  server0.example.com   #访问成功


####################################################
客户端访问服务端:
    1.服务本身的访问控制
    2.防火墙的访问控制
    3.本地目录访问控制
  4.SELinux的访问控制

####################################################

部署动态网站


静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源

动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
–  由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......

虚拟机server0:

1.部署Python的网页文件
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName  webapp0.example.com
  DocumentRoot  /var/www/sina
</VirtualHost>

[root@server0 /]# cd /var/www/sina

 wget  http://classroom.example.com/pub/materials/webinfo.wsgi

2.方便用户访问webinfo.wsgi网页文件
  
  网页跳转(网页文件的别名)

[root@server0 sina]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/sina
  Alias  /    /var/www/sina/webinfo.wsgi
#当客户端访问到网页文件根目录时,将/var/www/sina/webinfo.wsgi呈现

</VirtualHost>

[root@server0 ]# systemctl  restart  httpd
[root@server0 ]# firefox webapp0.example.com

3.翻译Python页面
[root@server0 ]# yum -y install mod_wsgi (解释Python页面软件)
[root@server0 ]# vim /etc/httpd/conf.d/nsd01.conf

<VirtualHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/sina
  WsgiScriptAlias /   /var/www/sina/webinfo.wsgi

</VirtualHost>

[root@server0 ]# systemctl restart httpd
[root@server0 ]# firefox webapp0.example.com

 UNIX时间戳:自1970-1-1  0时0分0秒到现在时间,所有经历的总的秒数

4.此虚拟webapp0.example.com主机侦听在端口8909
[root@server0 /]# vim  /etc/httpd/conf.d/nsd01.conf 
Listen  8909
<VirtualHost  *:8909>
  ServerName  webapp0.example.com
  DocumentRoot  /var/www/sina
  WsgiScriptAlias  /   /var/www/sina/webinfo.wsgi
</VirtualHost>

5.SELinux限制所有非默认的端口开放 (布尔值   安全上下文值)
# semanage  port  -l | grep  http
# semanage  port  -a  -t  http_port_t  -p tcp 8909
    -a:添加     -t:类型    -p:协议
# semanage  port -l  |  grep  http      #-l:列出
         
6.重起httpd服务 
[root@server0 /]# systemctl restart httpd
[root@server0 ~]# firefox webapp0.example.com:8909

####################################################



77777777777777777777777777777777777777777777777777777777777777
7777777777777777777777777777777777777777777777777777777777777
77777777777777777777777777777777777777777777777777777777777777


真机：还原三台虚拟机
[root@room9pc13 ~]# rht-vmctl reset classroom  
[root@room9pc13 ~]# rht-vmctl reset server
[root@room9pc13 ~]# rht-vmctl reset desktop   

####################################################
防火墙：
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

#####################################################
安全Web服务,实现https(安全的超文本传输协议)加密传输

– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

搭建虚拟Web主机
1.安装软件包httpd

2.修改配置文件
# vim /etc/httpd/conf.d/nsd01.conf
 <VirtualHost  *:80>
   ServerName www0.example.com
   DocumentRoot /var/www/html
 </VirtualHost>

# echo '<h1>NSD test' > /var/www/html/index.html
# systemctl  restart  httpd

#####################################################
部署安全的Web服务器,端口默认:443

1.安装软件包,支持安全Web服务器
[root@server0 ~]# yum -y install  mod_ssl

2.部署网站证书(营业执照)
# cd /etc/pki/CA/certs/
# wget  http://classroom.example.com/pub/tls/certs/server0.crt

# ls

3.部署根证书(公安局信息)
# cd /etc/pki/CA/certs/
# wget  http://classroom.example.com/pub/example-ca.crt

# ls

4.部署解密的私钥
# cd /etc/pki/CA/private/
# wget http://classroom.example.com/pub/tls/private/server0.key

# ls

5.修改配置文件/etc/httpd/conf.d/ssl.conf
# vim /etc/httpd/conf.d/ssl.conf
 在末行模式下  :set  nu   #显示全文行号
    
 59  DocumentRoot "/var/www/html"
 60  ServerName www0.example.com:443

指定网站证书
100 SSLCertificateFile /etc/pki/CA/certs/server0.crt

指定私钥
107 SSLCertificateKeyFile /etc/pki/CA/private/server0.key

指定根证书
122 SSLCACertificateFile /etc/pki/CA/certs/example-ca.crt

6.重起httpd服务
[root@server0 /]# systemctl  restart  httpd

7.验证:
[root@server0 /]# firefox https://www0.example.com  
网站地址处有一个小锁，由https开头。证明已经成功了
#######################################################
基础邮件服务
• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱          
                                                                                       	
  DNS服务器: classroom.example.com

            server0.example.com

虚拟机Server0:部署邮件服务

1.创建两个邮箱帐号
[root@server0 /]# useradd yg
[root@server0 /]# useradd xln

2.安装邮件功能的软件
[root@server0 /]# rpm -q postfix

3.修改配置文件/etc/postfix/main.cf

 99  myorigin = server0.example.com   #默认补全邮箱域名后缀
 116 inet_interfaces = all            #允许本机所有网络接口
 164 mydestination = server0.example.com 
                                               #根据本字段值,判断为本域邮件

4.重起服务
[root@server0 /]# systemctl restart postfix

###################################################
收发邮件:

• mail 发信操作
– mail -s '邮件主题'     -r  发件人      收件人

• mail 收信操作
– mail [-u 用户名]

[root@server0 /]# mail -s 'test1'   -r  yg   xln
AAAAAAAAAAAA
hahaxixi
.                  #只有一个点,提交

[root@server0 /]# mail -u xln
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/mail/xln": 2 messages
>   1 yg@server0.example.c  Fri Jun 15 14:30  19/606   
 
&  1         #输入编号

& quit   #退出

[root@server0 /]# echo haha | mail -s 'test01' -r yg  xln

#######################################################
parted分区命令,可以划分GPT分区模式

   GPT分区模式:    128个主分区       18EB容量

                1EB=1000PB
                1PB=1000TB                        
     

[root@server0 /]# parted /dev/vdb
(parted) mktable  gpt      #指定分区模式
(parted) print             #输出分区表信息
(parted) mkpart            #划分新的分区
分区名称？  []? haha          #分区名子,随便起
文件系统类型？  [ext2]? ext4   #指定分区文件系统类型,不起作用
起始点？ 0           
结束点？ 2G
忽略/Ignore/放弃/Cancel? Ignore    #忽略
(parted) unit GB                 #使用GB作为显示单位
(parted) mkpart 
分区名称？  []? haha
文件系统类型？  [ext2]? ext4
起始点？ 2G          
结束点？ 4G 
(parted) quit                     #退出
[root@server0 /]#

####################################################
交换空间,虚拟内存

– 当物理内存不够用时,使用磁盘空间来模拟内存
– 在一定程度上缓解内存不足的问题
– 交换分区:以空闲分区充当的交换空间


1.格式化, 交换文件系统
[root@server0 ~]# mkswap  /dev/vdb1  

2.启用交换分区
[root@server0 ~]# swapon  /dev/vdb1  

3.查看交换空间组成的成员
[root@server0 ~]# swapon -s

[root@server0 ~]# mkswap   /dev/vdb2  
[root@server0 ~]# swapon   /dev/vdb2
[root@server0 ~]# swapon  -s
[root@server0 ~]# swapoff  /dev/vdb2     #停用
[root@server0 ~]# swapon  -s

5.开机自动启用交换分区
[root@server0 ~]# vim /etc/fstab 
/dev/vdb1  swap  swap  defaults  0 0
/dev/vdb2  swap  swap  defaults  0 0

[root@server0 ~]# swapoff /dev/vdb1
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s
[root@server0 ~]# swapon  -a   #专用于检测交换分区命令
[root@server0 ~]# swapon -s

###################################################
配置NFS共享, Linux与Linux之间的共享
NFS共享概述
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)  RPC(TCP/UDP 111)

• 所需软件包:nfs-utils
• 系统服务:nfs-server

搭建基本的NFS共享
虚拟机server0
1.安装nfs-utils包
[root@server0 ~]# yum -y install nfs-utils

2.修改配置文件/etc/exports
[root@server0 ~]# mkdir /test
[root@server0 ~]# echo haha > /test/1.txt
[root@server0 ~]# vim /etc/exports
/test     *(ro)

3.重起nfs-server服务
[root@server0 ~]# systemctl restart nfs-server

虚拟机desktop0
客户端访问:
1.查看服务端NFS共享
[root@desktop0 ~]# showmount -e 172.25.0.11

2.挂载访问
[root@desktop0 ~]# mkdir /mnt/nfs
[root@desktop0 ~]# mount 172.25.0.11:/test  /mnt/nfs
[root@desktop0 ~]# df  -h

3.实现开机自动挂载
[root@desktop0 ~]# vim /etc/fstab 
172.25.0.11:/test  /mnt/nfs  nfs defaults,_netdev 0 0

[root@desktop0 ~]# umount /mnt/nfs
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
 




SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS








部署 网络服务进阶  教学环境

真机:快速产生两台虚拟机
[root@room9pc01 ~]# clone-vm7
 Enter VM number: 6
 Creating Virtual Machine disk image......	[OK]
 Defining new virtual machine......		     [OK]

 利用root用户,密码123456登陆两台虚拟机

虚拟机A:作为练习使用的服务端:
1.配置永久的主机名:svr7.tedu.cn
2.配置eth0永久的IP地址:192.168.4.7/24


虚拟机B:作为练习使用的客户端
1.配置永久的主机名:pc207.tedu.cn
2.配置eth0永久的IP地址:192.168.4.207/24
L
####################################################
搭建网络Yum仓库

1.真机构建FTP服务器,共享光盘所有内容
[root@room9pc01 ~]# rpm  -q  vsftpd
vsftpd-3.0.2-22.el7.x86_64
[root@room9pc01 ~]# systemctl restart vsftpd
[root@room9pc01 ~]# systemctl enable vsftpd

[root@room9pc01 ~]# ls /var/ftp/rhel7/   #查看是否有光盘内容

[root@room9pc01 ~]# ls -l /iso
lrwxrwxrwx 1 root root 27 1月  23 17:32 /iso -> /var/lib/libvirt/images/iso

[root@room9pc01 ~]# vim /etc/fstab      #不支持快捷方式
/var/lib/libvirt/images/iso/rhel-server-7.4-x86_64-dvd.iso   /var/ftp/rhel7   iso9660   defaults  0  0


[root@room9pc01 ~]# firefox ftp://192.168.4.254/rhel7
                                                ???
2.在两台虚拟机上操作,指定Yum服务端

[root@svr7 ~]# vim /etc/yum.repos.d/rhel7.repo
 [rhel7]
 name=rhel7.4
 baseurl=ftp://192.168.4.254/rhel7
 enabled=1
 gpgcheck=0

[root@svr7 ~]# yum repolist
[root@svr7 ~]# yum -y install xeyes

######################################################
进行远程管理,为真机永久的别名的设置

[root@room9pc01 ~]# vim /root/.bashrc 
alias  goa='ssh -X root@192.168.4.7'
alias  gob='ssh -X root@192.168.4.207'

#######################################################
目录结构

[root@svr7 ~]# man hier

 /boot 		 存放系统引导必需的文件,包括内核、启动配置
 /bin、/sbin        存放各种命令程序
 /dev               存放硬盘、键盘、鼠标、光驱等各种设备文件
 /etc 		 存放Linux系统及各种程序的配置文件
 /root、/home/用户名  分别是管理员root、普通用户的默认家目录
 /var 		  存放日志文件、邮箱目录等经常变化的文件
 /proc 		  存放内存中的映射数据,不占用磁盘
 /tmp 		  存放系统运行过程中使用的一些临时文件

#####################################################
权限的数值表示

• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1

[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 755 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

################################################
历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令

• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000     //默认记录1000条


[root@svr7 ~]# history           #查看历史命令列表

[root@svr7 ~]# history -c        #清空历史命令
[root@svr7 ~]# history 

[root@svr7 ~]# cat /etc/redhat-release 

[root@svr7 ~]# ls /root/

[root@svr7 ~]# !cat     #执行历史命令中最近一条以cat开头的命令

[root@svr7 ~]# !ls


####################################################
• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -sh /boot/ /etc/pki/

#####################################################
• date,查看/调整系统日期时间

– date +%F、date +%R
– date +"%Y-%m-%d  %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"    #修改时间

[root@svr7 ~]# date  +%F
[root@svr7 ~]# date  +%Y
[root@svr7 ~]# date  +%m
[root@svr7 ~]# date  +%d
[root@svr7 ~]# date  +%H
[root@svr7 ~]# date  +%M

##################################################
快捷方式制作,必须是绝对路径

–  ln  -s  原始文件或目录    软连接文件

[root@svr7 ~]# ln -s /etc/redhat-release  /
[root@svr7 ~]# ls /

[root@svr7 ~]# ln -s /etc/redhat-release  /abc
[root@svr7 ~]# ls /

[root@svr7 ~]# ls -l /abc 
lrwxrwxrwx. 1 root root 19 6月  19 11:55 /abc -> /etc/redhat-release
[root@svr7 ~]# cat /abc 
 
######################################################
• ln,创建软连接
– 软连接 --> 原始文档 --> i节点 --> 文档数据
– ln -s 原始文件或目录 软连接文件
  若原始文件或目录被删除,连接文件将失效
  软连接可存放在不同分区/文件系统


• ln,创建硬连接
– 硬连接 --> i节点 --> 文档数据
– ln  原始文件    硬连接文件
 若原始文件被删除,连接文件仍可用
 硬连接与原始文件必须在同一分区/文件系统


i节点 :编号标识硬盘独立一个存储空间

   原始文档----->i节点------>硬盘所对应的区域

[root@svr7 ~]# echo 123 > /opt/A
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# ln -s /opt/A  /opt/B   #制作软连接(软链接)
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# ln /opt/A   /opt/C    #制作硬连接(硬链接)
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# ls  -i  /opt       #查看i节点编号

#####################################################
获取命令帮助
• man,格式化手册阅读工具
– 按 上 、下 、 PgUp 、PgDn 键滚动及翻页
– 按 q 键退出
– 按 / 键向后查找关键词(n、N切换)

[root@svr7 ~]# man mkdir
[root@svr7 ~]# man passwd
[root@svr7 ~]# man 5 passwd    #数字5:帮助类型(文件帮助信息)
[root@svr7 ~]# man teamd.conf 

• 对于内部命令,使用“ help 命令名”查看

• 对于外部命令程序,通常 会提供“--help”帮助选项

[root@svr7 ~]# ls --help
[root@svr7 ~]# ls --help | less

#####################################################
zip归档工具,跨平台的归档工具


• 归档+压缩操作
– zip [-r]   备份文件.zip   被归档的文档...

• 释放归档+解压操作
– unzip   备份文件.zip   [-d 目标文件夹]

[root@svr7 ~]# zip -r /root/file.zip  /home/  /etc/passwd 
[root@svr7 ~]# ls /root/

[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# unzip /root/file.zip -d /nsd02


######################################################
自定义Yum仓库

真机将tools.tar.gz上传到虚拟机A上
1.具备自己的软件包

# scp /root/桌面/tools.tar.gz     root@192.168.4.7:/root/

2.虚拟机A上操作:
# ls /root

3.虚拟机A上操作:tar解包
[root@svr7 ~]# tar -xf /root/tools.tar.gz  -C  /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls /tools/

4.虚拟机A上操作:生成仓库数据文件
[root@svr7 ~]# createrepo  /tools/other/
 
[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata/

5.虚拟机A上操作:书写一个客户端文件
[root@svr7 ~]# vim /etc/yum.repos.d/rhel7.repo 
 ......
[myrpm]                 #仓库标识
name=myrpm  
baseurl=file:///tools/other
enabled=1
gpgcheck=0

[root@svr7 ~]# yum repolist 

[root@svr7 ~]# yum -y install  sl
[root@svr7 ~]# rpm -ql  sl  #查询软件包安装的清单

[root@svr7 ~]# yum -y install  cmatrix
[root@svr7 ~]# cmatrix

[root@svr7 ~]# yum -y install  oneko
[root@svr7 ~]# oneko

###################################################

源码编译安装

 rpm包: 简单方便,不够灵活    yum   rpm -ivh


  源码包:非常的灵活,可以指定安装的位置及功能


  源码包------gcc\make----->可以执行的文件-------->运行安装


步骤一:安装开发工具gcc与make
[root@svr7 ~]# yum  -y  install   gcc  make

步骤二:tar进行解包
# tar -xf /tools/inotify-tools-3.13.tar.gz -C /mnt/
# ls /mnt/
# ls /mnt/inotify-tools-3.13/

步骤三:配置 ./configure ,进行指定可以指定安装的位置及功能
# cd /mnt/inotify-tools-3.13/

# ./configure   --prefix=/opt/myrpm
     检测是否安装gcc

常见的报错:没有安装gcc
 checking for gcc... no
 checking for cc... no
 checking for cl.exe... no
 configure: error: no acceptable C compiler found in $PATH

步骤四:编译  make
# make


步骤五:安装 make install

# make install

# ls /opt/

# ls /opt/myrpm/

# ls /opt/myrpm/bin/

#####################################################


22222222222222222222222222222222222222222222222222222222222222
2222222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222



DNS解析的作用
• 为什么需要DNS系统
– www.baidu.com 与 119.75.217.56,哪个更好记?
– 互联网中的114查号台/导航员

• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址


域名的体系结构,所有的域名必须要以点作为结尾

                             .   根域名


一级域名:    .cn     .us     .hk     .tw    .kr ......  


二级域名:   .com.cn    .net.cn   .edu.cn   .org.cn ........


三级域名:   NB.com.cn   dw.com.cn   haha.com.cn  dc.com.cn


完整的主机名: www.NB.com.cn    ftp.NB.com.cn   tts.NB.com.cn
  
• Full Qualified Domain Name,完全合格主机名(FQDN)

######################################################
bind-9.9.4-29.el7.x86_64          //域名服务包
bind-chroot-9.9.4-29.el7.x86_64   //提供虚拟根支持(牢笼机制)

– 系统服务:named
– 默认端口:TCP/UDP 53

• 主配置文件:/etc/named.conf     设置本机负责解析的域名
• 地址库文件:/var/named/         主机名与IP地址对应关系


###################################################
构建基本的DNS服务器

虚拟机A:服务端
1.安装软件 bind  bind-chroot
2.修改配置文件/etc/named.conf
[root@svr7 ~]# cp /etc/named.conf   /root/

[root@svr7 ~]# vim /etc/named.conf   #命令模式  u可以撤销

 options {
 	directory 	"/var/named";    #指定地址库文件存放路径
 };

 zone "tedu.cn" IN {          #指定本机负责解析的域名
 	type master;             #指定本机为主DNS服务器(权威服务器)
 	file "tedu.cn.zone";     #指定地址库文件的名字
 };
 
3.建立地址库文件/var/named/tedu.cn.zone
# cp -p /var/named/named.localhost /var/named/tedu.cn.zone

# ls -l /var/named/tedu.cn.zone

# vim /var/named/tedu.cn.zone
......
  tedu.cn.   NS   svr7
  svr7       A    192.168.4.7
  www        A    1.2.3.4
  ftp        A    5.6.7.8

4.重起服务
# systemctl restart named

######################################################
客户端:虚拟机B

# echo nameserver  192.168.4.7 > /etc/resolv.conf 

# nslookup www.tedu.cn

######################################################
多区域的DNS服务器
虚拟机A:
1.修改配置文件/etc/named.conf   #追加写入
 ........
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
 };

2.建立地址库文件
# cp -p /var/named/tedu.cn.zone  /var/named/qq.com.zone
# vim /var/named/qq.com.zone
 ........
 qq.com.    NS   svr7
 svr7       A    192.168.4.7
 www        A    1.2.3.4
 ftp        A    5.6.7.8

3.重起named服务
######################################################
特殊的解析记录

1.重复解析记录,可以达到轮询
[root@svr7 ~]# vim /var/named/tedu.cn.zone 

	tedu.cn.   NS   svr7
	svr7       A    192.168.4.7
	www        A    192.168.4.10
	www        A    192.168.4.20
	www        A    192.168.4.25
	ftp        A    5.6.7.8

[root@svr7 ~]# systemctl restart named
客户端:多次ping测试



2.泛域名解析
[root@svr7 ~]# vim /var/named/tedu.cn.zone
 ........
 *          A    10.20.30.40
 tedu.cn.   A    50.60.70.80


[root@svr7 ~]# !sys
systemctl restart named

客户端验证
[root@pc207 ~]# nslookup haha.tedu.cn
[root@pc207 ~]# nslookup tedu.cn

3.有规律的泛域名解析
        
            stu1.tedu.cn -------> 192.168.10.1
            stu2.tedu.cn -------> 192.168.10.2
            stu3.tedu.cn -------> 192.168.10.3
                    ........
            stu50.tedu.cn -------> 192.168.10.50

  $GENERATE:产生连续的数字  


  $GENERATE 1-50  stu$    A  192.168.10.$ 
 

4.解析记录的别名

[root@svr7 ~]# vim /var/named/tedu.cn.zone 

   tts        CNAME    ftp

[root@svr7 ~]# systemctl restart named
###################################################
DNS子域授权

     父域: www.qq.com      虚拟机A的DNS服务

     子域: www.bj.qq.com   虚拟机B的DNS服务
 
    虚拟机A的DNS服务,可以解析qq.com 
    虚拟机B的DNS服务,可以解析bj.qq.com

    虚拟机A的DNS服务,可以解析bj.qq.com


虚拟机B操作:
1.安装软件bind  bind-chroot
2.修改配置文件/etc/named.conf
# vim /etc/named.conf 
 options {
 	directory 	"/var/named";    
 };
 zone "bj.qq.com" IN {          
 	type master;             
 	file "bj.qq.com.zone";     
 };
3.建立地址库文件/var/named/bj.qq.com.zone
# vim /var/named/bj.qq.com.zone
  bj.qq.com.   NS   pc207
  pc207        A    192.168.4.207
  www          A    192.168.20.1
4.重起服务
# systemctl  restart  named
5.验证
# nslookup www.bj.qq.com  192.168.4.207

###############################################

    虚拟机A的DNS服务,可以解析bj.qq.com

子域授权

虚拟机A:
1.修改地址库文件
[root@svr7 ~]# vim /var/named/qq.com.zone 
	qq.com.    NS   svr7
	bj.qq.com. NS   pc207
	svr7       A    192.168.4.7
	pc207      A    192.168.4.207
	www        A    1.2.3.4
	ftp        A    5.6.7.8
[root@svr7 ~]# systemctl restart named

[root@svr7 ~]# nslookup www.bj.qq.com  192.168.4.7
Server:		192.168.4.7
Address:	     192.168.4.7#53

Non-authoritative answer:  非权威解答
Name:	www.bj.qq.com
Address: 192.168.20.1

##################################################

递归解析: DNS服务器与其他DNS服务器交互,最终将答案带回来的过程
迭代解析: DNS服务器与其他DNS服务器交互

#################################################
补充: 主机名映射文件/etc/hosts(DNS解析的作用,只为本机提供解析)

[root@svr7 ~]# vim  /etc/hosts
192.168.4.230  www.360.com  
192.168.4.200  www.baidu.com

[root@svr7 ~]# ping  www.360.com
[root@svr7 ~]# ping  www.baidu.com

解析顺序:
  --->/etc/hosts------>/etc/resolv.conf----->DNS服务器

###################################################
缓存DNS,加快解析速度

• 方式1:全局转发
– 将请求转发给指定的公共DNS(其他缓存DNS),请求递归服务


• 方式2:根域迭代
– 依次向根、一级、二级......域的DNS服务器迭代




#############################################
• 方式1:全局转发
1.查看真机DNS服务器ip地址
[root@room9pc01 ~]# cat /etc/resolv.conf 

nameserver 172.40.1.10
[root@room9pc01 ~]# 

2.真机搭建Yum仓库
[root@room9pc01 ~]# mkdir /dvd/
[root@room9pc01 ~]# mount /iso/CentOS-7-x86_64-DVD-1708.iso /dvd/

[root@room9pc01 ~]# ls /dvd/
[root@room9pc01 ~]# cd /etc/yum.repos.d/
[root@room9pc01 yum.repos.d]# ls
[root@room9pc01 yum.repos.d]# mkdir  repo
[root@room9pc01 yum.repos.d]# mv  *.repo   repo

[root@room9pc01 yum.repos.d]# vim dvd.repo 
 [dvd]
 name=CentOS7.4
 baseurl=file:///dvd
 enabled=1
 gpgcheck=0
[root@room9pc01 ~]# yum -y install bind bind-chroot

3.真机搭建缓存DNS服务器,修改配置文件

# vim /etc/named.conf

 options {
    directory   "/var/named";
    forwarders   {  172.40.1.10;  };   #书写真机的DNS地址
  };

# systemctl  restart  named

4.虚拟机A:验证
# echo nameserver 192.168.4.254 > /etc/resolv.conf 
# nslookup www.taobao.com

#######################################################


options {
        directory       "/var/named";
};
view "nsd"  {                             #分类名称
 match-clients  {   192.168.4.7; };    #匹配客户机地址
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
zone "163.com" IN {
        type master;
        file "163.com.zone";
};
};
view "other"  {  
 match-clients  {  192.168.4.207;  };
zone "qq.com" IN {
        type master;
        file "qq.com.other";
};
zone "163.com" IN {
        type master;
        file "163.com.other";
};
};


cp33333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333
######################################################
检测虚拟机A与虚拟机B的Yum仓库
[root@svr7 ~]# yum clean all    #清空缓存
[root@svr7 ~]# yum repolist     #列出仓库信息

#####################################################
 
######################################################
搭建基本的DNS服务

服务端：虚拟机A
1.安装一个可以提供域名解析的软件
[root@svr7 ~]# yum -y install bind-chroot bind
2.修改主配置文件/etc/named.conf
[root@svr7 ~]# vim /etc/named.conf 
	options {
		directory 	"/var/named";    
	};
	zone  "sina.com"  IN  {         
		type master;               
		file "sina.com.zone";        
	};
3. 建立地址库文件/var/named/sina.com.zone   -p:权限不变进行拷贝
# cp -p /var/named/named.localhost /var/named/sina.com.zone
# vim  /var/named/sina.com.zone
	sina.com.      NS      svr7         #指定本区域DNS服务器
	svr7           A       192.168.4.7  #指定DNS服务器的IP地址
	www            A       19.18.16.17
# systemctl restart named   #重起服务
客户端：虚拟机B 验证DNS解析
 # echo nameserver 192.168.4.7 > /etc/resolv.conf 
 # nslookup   www.sina.com  #测试域名解析

######################################################
DNS分离解析

什么是分离解析
• 当收到客户机的DNS查询请求的时候
 – 能够区分客户机的来源地址
 – 为不同类别的客户机提供不同的解析结果(IP地址)
 – 根据客户端的不同，解析同一个域名，得到的解析结果不同

 – 目的：为客户端提供网络最近的服务器资源



   
案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:sina.com

– A记录分离解析 —— 以 www.sina.com 为例

客户机来自 解析结果
       192.168.4.207 --------》 192.168.4.100

       其他地址 --------》 1.2.3.4

 1.由上到下依次匹配，  匹配及停止
 2.使用view时，所有的客户端都必须在分类中
 3.所有的zone都必须在view中
 4.每一个view中的zone必须相同


 view "lan" {
	match-clients {  192.168.4.207; }；
	zone "sina.com" IN {
	...... sina.com.lan;
	};                                                                     192.168.4.100
 };
 view "other" {
	 match-clients { any; }；
	 zone "sina.com"  IN  {
	 ......  sina.com.other;
	 };
 };


  

虚拟机A：
1.修改配置文件/etc/named.conf
 view "nsd" {                                   #分类名称
  match-clients {   192.168.4.207;    };      #匹配客户机地址

  zone "sina.com" IN {
         type master;
         file "sina.com.nsd";
     };
   };

 view "other" {
  match-clients {    any;    };
  zone "sina.com" IN {
         type master;
         file "sina.com.other";
    };
  };
2.建立sina.com.nsd、sina.com.other 地址库文件 ， 写入不同的解析结果
   sina.com.nsd 解析结果为 192.168.4.100
   sina.com.other 解析结果为 1.2.3.4

3.修改/etc/named.conf

  补充：vim 可视模式 在命令模式下  按 ctrl+v 进入可视模式 可以选择列

    按 大写的  I 进入插入模式，然后输入内容 按Esc退回到命令模式

############################################################
acl地址列表  简化match-clients匹配

acl test { 192.168.4.207; 192.168.200; 192.168.4.250; 192.168.1.1; };

view "nsd" {
 match-clients {   test;    };
 zone "sina.com" IN {
        type master;
        file "sina.com.nsd";
  };
};

##########################################################
补充： vim 默认配置文件   ~/.vimrc  
         初始化vim操作，每次使用vim命令首先执行的内容


 [root@svr7 /]# vim /root/.vimrc 

  set nu          #开启行号
  set ai          #启用自动缩进
  set tabstop=2   #一个tab键等于 两个空格

##########################################################
RAID磁盘管理
• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks

– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘

– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率，无容错功能
– 至少由2块磁盘组成


• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少由2块磁盘组成

• RAID5,高性价比模式
 – 相当于RAID0和RAID1的折中方案
 – 需要至少一块磁盘的容量来存放校验数据
 – 至少由3块磁盘组成


• RAID6,高性价比/可靠模式
 – 相当于扩展的RAID5阵列,提供2份独立校验方案
 – 需要至少两块磁盘的容量来存放校验数据
 – 至少由4块磁盘组成


• RAID 0+1/RAID 1+0
 – 整合RAID 0、RAID 1的优势
 – 并行存取提高效率、镜像写入提高可靠性
 – 至少由4块磁盘组成


***主板 ---》 磁盘 ---》 操作系统 ---》 RAID软件 ----》数据


#################################################
进程管理

     程序：静态的代码，占用磁盘空间

     进程：动态的代码，会占用 CPU  内存
     进程的唯一标识：PID
     父进程与子进程   树形结构

###############################################

查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

  systemd是所有进程的父进程


[root@svr7 /]# pstree             #显示进程树

[root@svr7 /]# pstree  lisi       #显示用户lisi的进程

[root@svr7 /]# pstree -p lisi     #显示进程PID
 
[root@svr7 /]# pstree -ap lisi    #显示进程完整的信息


###############################################

• ps aux 操作
– 列出正在运行的所有进程

用户 进程ID %CPU %内存 虚拟内存 固定内存 终端 状态 起始时间 CPU时间 程序指令


• ps -elf 操作
– 列出正在运行的所有进程
PPID:父进程的PID号

################################################
进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

  按 大写的P  按cpu降序
  按 大写的M  按内存降序

[root@svr7 /]# top -d  1

[root@svr7 /]# ps aux
[root@svr7 /]# ps -elf
[root@svr7 /]# ps aux   |  wc  -l   #统计进程数  
[root@svr7 /]# ps -elf  |  wc  -l   #统计进程数  

##############################################
检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件

• 常用命令选项
 – -l:输出进程名,而不仅仅是 PID
 – -U:检索指定用户的进程
 – -t:检索指定终端的进程
 – -x:精确匹配完整的进程名
 
[root@svr7 /]# pgrep -l  atd
[root@svr7 /]# pgrep -l  cron

[root@svr7 /]# pgrep -lU lisi

[root@svr7 /]# pgrep -lU lisi | wc -l

[root@svr7 /]# pgrep -lx atd
################################################
控制进程


[root@svr7 /]# sleep 900 &   #正在运行放入后台
[root@svr7 /]# jobs          #查看后台进程信息
[root@svr7 /]# sleep 800
^Z                           #按Ctrl+z正在运行放入后台
[2]+  已停止               sleep 800
[root@svr7 /]# jobs 
[root@svr7 /]# bg 2       #将后台编号为2的进程继续运行
[root@svr7 /]# jobs 
[root@svr7 /]# fg 1       #将后台编号为1的进程恢复到前台
sleep 900
^C                    #按Ctrl+c结束
[root@svr7 /]# jobs 
[root@svr7 /]# fg 2       #将后台编号为2的进程恢复到前台
sleep 800
^C                    #按Ctrl+c结束
[root@svr7 /]# jobs 

杀死进程
 – Ctrl+c 组合键,中断当前命令程序
 – kill [-9] PID... 、kill [-9] %后台任务编号
 – killall [-9] 进程名...
 – pkill 查找条件

     -9：强制杀

 – killall  -9  -u  用户名    #杀死该用户开启的所有进程

          强制 踢出 一个用户

##################################################
日志管理

日志的功能
• 系统和程序的“日记本”
 – 记录系统、程序运行中发生的各种事件
 – 通过查看日志,了解及排除故障


• 常见的日志文件

 /var/log/messages   记录内核消息、各种服务的公共消息
 /var/log/dmesg 		记录系统启动过程的各种消息
 /var/log/cron       记录与cron计划任务相关的消息
 /var/log/maillog    记录邮件收发相关的消息
 /var/log/secure     记录与访问限制相关的安全消息


日志分析

    tailf  : 实时跟踪日志信息

   – awk、sed等格式化过滤工具


• users、who、w 命令
  – 查看已登录的用户信息,详细度不同

• last、lastb 命令
  – 查看最近登录成功/失败的用户信息

[root@svr7 /]# users
[root@svr7 /]# who
[root@svr7 /]# w

[root@svr7 /]# last  -2   #最近登陆成功2条记录
[root@svr7 /]# lastb  -2  #最近登陆失败2条记录


• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）	   会导致主机系统不可用的情况
  1  ALERT（警告）	   必须马上采取措施解决的问题
  2  CRIT（严重）	           比较严重的情况
  3  ERR（错误）	            运行出现错误
  4  WARNING（提醒）         可能会影响系统功能的事件
  5  NOTICE（注意）          不会影响系统但值得注意
  6  INFO（信息）	            一般信息
  7  DEBUG（调试）	    程序或系统调试信息等


444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444


DHCP服务构建

用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

DHCP概述及原理,整个过程通过广播进行,先到先得(一个网路中,不能有多台)
• DHCP地址分配的四次会话
– DISCOVERY --> OFFER --> REQUEST -->ACK


部署DHCP服务
1.安装软件包
[root@svr7 /]# yum -y install dhcp

2.修改配置文件/etc/dhcp/dhcpd.conf
[root@svr7 /]# vim  /etc/dhcp/dhcpd.conf
  末行模式 读入其他文件内容:   r  文件路径

  :r  /usr/share/doc/dhcp*/dhcpd.conf.example


 subnet 192.168.4.0 netmask 255.255.255.0 {  #分配的网段
  range 192.168.4.100   192.168.4.150;       #分配ip范围
  option domain-name-servers 192.168.4.7;   #分配DNS地址
  option routers 192.168.4.254;          #分配网关地址
  default-lease-time 600;              #默认组期时间
  max-lease-time 7200;                 #最大组期时间
 }

3.重起dhcpd服务

####################################################
PXE网络装机

• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

PXE组件及过程分析
• 需要哪些服务组件?
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务,提供yum安装源

##################################################
一  搭建DHCP服务,设置网络装机配置

1.修改配置文件/etc/dhcp/dhcpd.conf
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100   192.168.4.150;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server  192.168.4.7;  #指定下一个服务器地址
  filename  "pxelinux.0";    #指定网卡引导文件名称
}

2.重起dhcpd服务

  pxelinux.0:网卡引导文件(安装说明书) 二进制文件
                      安装一个软件可以自动生成

#######################################################
二 部署TFTP服务

   tftp: 简单的文件传输协议    端口:69
     默认共享的位置:/var/lib/tftpboot

1.安装tftp-server软件包
2.重起tftp服务
3.部署pxelinux.0文件
# yum  provides */pxelinux.0   #查询仓库中那个软件包产生该文件

# yum -y install syslinux

# rpm -ql syslinux | grep pxelinux.0  #查询安装清单

# cp /usr/share/syslinux/pxelinux.0     /var/lib/tftpboot/

# ls /var/lib/tftpboot/

 
   dhcp---------->IP地址   next-server  filename 
   tftp---------->pxelinux.0
   pxelinux.0---->读取菜单文件
               /var/lib/tftpboot/pxelinux.cfg/default

4.部署菜单文件
[root@svr7 /]# mkdir  /var/lib/tftpboot/pxelinux.cfg
[root@svr7 /]# mount /dev/cdrom  /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 /]# ls /mnt/
[root@svr7 /]# ls /mnt/isolinux/

[root@svr7 /]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

# chmod u+w /var/lib/tftpboot/pxelinux.cfg/default

# ls -l /var/lib/tftpboot/pxelinux.cfg/default

5.部署 图形模块 与  背景图片

  vesamenu.c32( 图形模块)
  splash.png(背景图片)

[root@svr7 /]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png   /var/lib/tftpboot/

[root@svr7 /]# ls /var/lib/tftpboot/

6.部署 启动内核 与  驱动程序
 
 vmlinuz(启动内核)
 initrd.img(驱动程序)

[root@svr7 /]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img  /var/lib/tftpboot/

[root@svr7 /]# ls /var/lib/tftpboot/
 initrd.img  pxelinux.cfg  vesamenu.c32
 pxelinux.0  splash.png    vmlinuz

7.修改菜单文件内容
# vim /var/lib/tftpboot/pxelinux.cfg/default 
补充内容vim末行模式  : set nu  #开启行号

  1 default vesamenu.c32    #默认加载vesamenu.c32
  2 timeout 600             #超时的时间
   ......
 10 menu background splash.png     #背景图片
 11 menu title NSD1805 PXE Server  #显示的标题
   .......
 61 label linux
 62   menu label  Install RHEL7   #菜单显示内容
 63   menu  default               #读秒结束默认选择
 64   kernel vmlinuz              #加载启动内核
 65   append initrd=initrd.img    #解压驱动程序

#################################################
总结:
  dhcp---------->IP地址   next-server  filename 
  tftp---------->pxelinux.0
  pxelinux.0---->读取菜单文件
               /var/lib/tftpboot/pxelinux.cfg/default

  default---->vesamenu.c32 vmlinuz initrd.img  

#################################################
验证:   新建一个全新的虚拟机
          选则PXE网络安装
          网络类型选择为private1
################################################
三 搭建Web服务,共享光盘所有内容

1.安装httpd软件
2.重起httpd服务
3.建立目录/var/www/html/rhel7
[root@svr7 /]# mkdir /var/www/html/rhel7

4.挂载光驱设备
[root@svr7 /]# mount /dev/cdrom  /var/www/html/rhel7

5.测试访问
[root@svr7 /]# ls /var/www/html/rhel7

[root@svr7 /]# firefox http://192.168.4.7/rhel7

##################################################
四  生成应答文件,实现无人值守安装

1.安装一个图形system-config-kickstart的工具,生成应答文件

2.运行system-config-kickstart
[root@svr7 /]# system-config-kickstart

  首先查看  软件包选择    是否可用
  
  需要Yum的支持: 必须将Yum仓库标识修改 [development]
[root@svr7 /]# vim /etc/yum.repos.d/rhel7.repo
 [development]
......

[root@svr7 /]# system-config-kickstart

  首先查看  软件包选择    是否可用

[root@svr7 /]# ls /root/ks.cfg 
/root/ks.cfg
[root@svr7 /]# vim /root/ks.cfg

3.共享ks.cfg文件

[root@svr7 /]# cp /root/ks.cfg   /var/www/html/
[root@svr7 /]# ls /var/www/html/

4.修改菜单文件,指定ks.cfg文件
# vim  /var/lib/tftpboot/pxelinux.cfg/default
......
label linux
  menu label  Install RHEL7
  menu  default
  kernel vmlinuz
  append initrd=initrd.img  ks=http://192.168.4.7/ks.cfg

#######################################################
总结:
  dhcp---------->IP地址   next-server  filename 
  tftp---------->pxelinux.0
  pxelinux.0---->读取菜单文件
               /var/lib/tftpboot/pxelinux.cfg/default

  default---->vesamenu.c32 vmlinuz initrd.img  ks.cfg

  ks.cfg-----> --url="http://192.168.4.7/rhel7"

######################################################



55555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555




rsync同步操作

• 命令用法
– rsync [选项...] 源目录 目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据


• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压

• 本地同步
– rsync [选项...] 本地目录1 本地目录2

– rsync [选项...] 本地目录1/ 本地目录2

[root@svr7 ~]# mkdir /todir
[root@svr7 ~]# rsync -a /boot /todir  //同步整个文件夹
[root@svr7 ~]# rsync -a /boot/ /todir/  //只同步目录下的数据



[root@svr7 ~]# mkdir /dir
[root@svr7 ~]# mkdir /test
[root@svr7 ~]# echo 123 > /dir/1.txt
[root@svr7 ~]# echo 123 > /dir/2.txt
[root@svr7 ~]# ls /dir/

[root@svr7 ~]# ls /test/

[root@svr7 ~]# rsync -avz /dir   /test
[root@svr7 ~]# ls /test/

[root@svr7 ~]# rsync -avz /dir/   /test
[root@svr7 ~]# ls /test/

[root@svr7 ~]# echo 123 > /dir/3.txt
[root@svr7 ~]# rsync -avz /dir/   /test
[root@svr7 ~]# ls /test/
#######################################################
[root@svr7 ~]# rsync -avz --delete  /dir/  /test/
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test

[root@svr7 ~]# touch /test/abc.txt
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test
[root@svr7 ~]# rsync -avz --delete  /dir/  /test/
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test

[root@svr7 ~]# touch /dir/4.txt
[root@svr7 ~]# rsync -avz --delete  /dir/  /test/
[root@svr7 ~]# ls /dir
[root@svr7 ~]# ls /test

######################################################
rsync+SSH远程同步
   
• 与远程的 SSH目录保持同步
– 下行:rsync [...]   user@host:远程目录    本地目录
– 上行:rsync [...]   本地目录    user@host:远程目录

虚拟机A:
# ls /opt
# rsync -avz --delete  /opt/   root@192.168.4.207:/opt/


虚拟机B:
# ls /opt

######################################################
实现实时同步

一  ssh无密码验证
虚拟机A:
1.生成公钥 私钥 
[root@svr7 ~]# ssh-keygen       #一路回车
[root@svr7 ~]# ls /root/.ssh/

2.传递公钥 到对方机器
[root@svr7 ~]# ssh-copy-id  root@192.168.4.207

3.验证
# rsync -avz --delete /opt/  root@192.168.4.207:/opt/
 

二 部署inotify-tools工具软件,监控目录内容变化

真机的操作:
# scp /root/桌面/tools.tar.gz       root@192.168.4.7:/root/

虚拟机A:

1.安装gcc与make开发工具
2.tar解包
# mkdir /nsd
# tar -xf /root/tools.tar.gz -C /nsd
# tar -xf /nsd/tools/inotify-tools-3.13.tar.gz -C  /

3.运行./configure进行配置
[root@svr7 ~]# cd /inotify-tools-3.13/
[root@svr7 inotify-tools-3.13]# ./configure
4.执行make 编译
5.执行make  install 安装
6.验证 
[root@svr7 /]# ls /usr/local/bin/inotifywait


inotifywait监控用法

– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib 等事件类别



三   书写监控的脚本

     死循环功能:持续不断做一件重复的事情

   for  i  in  {1..20}     #有次数的循环
    do
             重复的事情
    done


    while  [ 1 -eq 1 ]
    do
             重复的事情
    done



[root@svr7 /]# vim  /root/rsync.sh

 #!/bin/bash
 while inotifywait -rqq /opt 
 do
  rsync -az --delete /opt/  root@192.168.4.207:/opt/ 
 done

[root@svr7 /]# chmod +x  /root/rsync.sh

[root@svr7 /]# /root/rsync.sh

[root@svr7 /]# killall rsync.sh

######################################################



cobble       cobble      cobble  


Cobbler装机平台,不同版本的多系统的安装

一  安装一个CentOS虚拟机  

真机: 
[root@room9pc01 ~]# ls /iso/
CentOS-7-x86_64-DVD-1708.iso

虚拟机要求:
             1.硬盘大小50G
             2.网络类型private1
             3.软件包选择 "带GUI的服务器"
             4.分区选择 "自动分区"

             5.将CentOS放入光驱设备,搭建本地Yum仓库
             6.配置IP地址:192.168.4.168/24
             7.配置主机名:Cobbler.tedu.cn


二、虚拟机设置  
   1.设置防火墙为trusted
  # firewall-cmd  --set-default-zone=trusted 

   2.当前及永久设置SELinux状态为permissive
 [root@localhost ~]# setenforce 0    #当前临时关闭
 [root@localhost ~]# getenforce 
 [root@localhost ~]# vim /etc/selinux/config 
  SELINUX=permissive


三、利用scp真机传递Cobbler.zip包到虚拟机192.168.4.168中
 # scp /root/桌面/Cobbler.zip   root@192.168.4.168:/root/
 	


##################################################
重设root密码  

案例1:为虚拟机 server 重设管理密码
1)重启系统,进入 recovery 恢复模式(修复模式)
按e键，找到 linux16 行，末尾添加 rd.break console=tty0
按 ctrl + x 启动
2)以可写方式重新挂载 /sysroot,并切换到此环境
switch_root# mount  -o  remount,rw  /sysroot
switch_root# chroot  /sysroot    
sh-3.2#
3)将root用户的密码设置为 redhat
# echo  redhat  |  passwd  --stdin  root
4)重设SELinux安全标签(安全增强版Linux)
# touch  /.autorelable    #让  SElinux  失忆
5)先后执行 exit、reboot 完成修复
# exit
# reboot

##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压Cobbler.zip包
[root@cobbler /]# unzip /root/Cobbler.zip -d /
[root@cobbler /]# cd /Cobbler/
[root@cobbler Cobbler]# ls

[root@cobbler /]# unzip /Cobbler/cobbler.zip  -d  /opt/ 
[root@cobbler /]# ls /opt/cobbler

#####################################################
五、安装cobbler主程序、工具包等
[root@cobbler /]# yum -y install /opt/cobbler/*.rpm


#################################################################
cobbler网络装机部署

1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  tftp-server 

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务




2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.168    #设置下一个服务器还为本机
 server:   192.168.4.168         #设置本机为cobbler服务器
 manage_dhcp:   1                #设置cobbler管理dhcp服务
 pxe_just_once:   1              #防止客户端重复安装操作系统

 开机启动： 匹配及停止  
     1.硬盘启动     2.光驱设备     3.U盘     4.网络引导   


3.配置cobbler的dhcp
[root@svr7 /]# vim  /etc/cobbler/dhcp.template 


  :%s  /旧/新/g      #全文替换

  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   



4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件

# tar -tf  /Cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /Cobbler/cobbler_boot.tar.gz  #绝对路径释放

# ls  /var/lib/cobbler/loaders/

5.启动相关服务
[root@svr7 /]# systemctl restart cobblerd
[root@svr7 /]# systemctl enable cobblerd

[root@svr7 /]# systemctl restart httpd
[root@svr7 /]# systemctl enable httpd

[root@svr7 /]# systemctl restart tftp
[root@svr7 /]# systemctl enable tftp

[root@svr7 /]# systemctl restart rsyncd   #同步服务
[root@svr7 /]# systemctl enable rsyncd


6.同步刷新cobbler配置
[root@svr7 /]# cobbler sync
[root@svr7 /]# firefox https://192.168.4.168/cobbler_web

   用户名：cobbler
   密码：cobbler


##########################################################################################################
  cobbler import  --path=挂载点   --name=导入系统命名（随意起）
导入安装镜像数据

# mount /dev/cdrom  /dvd

# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror

[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64
###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler


##########################################
############################################################################################################
[root@cobbler ~]# system-config-kickstart  #生成ks文件

默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7.4-A  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

############################################################################################################





     
         : windows     linux    apple系统    手机系统

 工作内容	服务的架构    shell语言、html语言、python语言
   九大服务：
        http:    80   超文本传输协议           
        FTP：    21   文件传输协议           
	  https:  443  安全超文本传输协议  
        DNS:     53   域名解析               
        tftp：   69   简单文件传输协议 
        telnet： 23   远程管理  （不加密，路由器交换机） 我们用ssh    
        SMTP：   25   邮件协议，发邮件     
        pop3：   110  邮件协议，收邮件     
        SNMP：   161  简单网络管理协议     



一，  NTP时间同步
   1.安装同步时间软件chrony（与服务端去沟通，确保时间的同步）
   2.修改主配置文件/etc/chrony.conf
   3.重起服务刷新配置    服务名：chronyd


二， cron计划任务       编辑:crontab -e [-u 用户名]
    软件包:cronie、crontabs
    # crontab  -e  -u  root   #编写计划任务 
    # crontab  -l  -u  root   #查看计划任务


三， LDAP服务器： 网络用户认证
         本地用户：  /etc/passwd
       LDAP服务器：classroom.example.com

 1.安装sssd软件包  与LDAP服务器沟通        sssd软件包 
    图形的配置工具authconfig-gtk软件    authconfig-gtk软件
 3.运行图形的工具进行配置    # authconfig-gtk 
 4.重起sssd服务验证


四， NFS共享           NFS服务器：classroom.example.com
  
   1.查看服务端共享
  # showmount -e classroom.example.com
   2.访问共享,挂载到本地
  # mount classroom.example.com:/home/guests/  /home/guests/

二十，搭建基本的NFS共享      Linux与Linux之间的共享
      1.安装nfs-utils包
      2.修改配置文件/etc/exports        ..   *(ro)
      3.重起nfs-server服务
虚拟机desktop0
     1.查看服务端NFS共享     showmount -e ....
     2.挂载访问    mkdir  mount    df -h
     3.实现开机自动挂载  /etc/fstab  ..  .  nfs defaults,_netdev . .
     umount        df -h      mount -a



$五， MBR/msdos    传统的分区
   1,分区lsblk    fdisk  
   2，格式化 mkfs.ext4(.xfs -f)       blkid
   3，挂载使用  mount   df -h
   4，开机自动挂载    /etc/fstab
  5，综合分区  fdisk  partprobe  lsblk

  (五，LVM逻辑卷的管理
  1，创建逻辑卷  vgcreate    lvcreate     pvs   vgs    
     mkfs.ext4(.xfs)  vim  /etc/fstab    mount -a  df -h

  2,逻辑卷的扩展  lvextend   resize2fs (xfs_growfs)  df -h
    vgextend  lvextend   resize2fs (xfs_growfs)  df -h
      
  3,逻辑卷的缩减  e2fsck -f 、、   resize2fs 、、 10G
     lvreduce -L 10G 、、        lvs

  4，PE：卷组划分空间的单位     -l :指定PE个数 
      vgdisplay      vgchange -s   lvcreate -l 50 -n lvtest02 

  5,逻辑卷的删除  ：先删除逻辑卷,再删除卷组，最后删除物理卷
                      否则会形成许多的扇形磁盘碎片，对硬盘造成损伤
	umount /lvm       lvremove /dev/nsd/mylv    


六，Shell脚本  ：一个可以执行的文件，可以实现某种功能
    .#！  .#  .      >  2> &>           &> /dev/null 
     引用变量值:$变量名  a=rhel  echo $a    echo ${a}7
     $[ ]        $( ) 、` `   RANDOM    USER
      $n,n为序号     read -p     $#  $*  $?
    [ -e,-d,-f,-r,-w,-x ] [ -gt,-ge,-eq,-ne,-lt,-le ]
    [ ==,!= ]  if [ ] ;then ..     else  ..  fi
    if [];then.. elif [ ];then.. elif [ ];then .else . fi
    for * in *** do .. done
     

七，SELinux安全机制
   enforcing   、permissive  、disabled
  setenforce 1|0   vim /etc/selinux/config


八，team,聚合连接(也称为链路聚合)
  1，创建虚拟网卡
 nmcli connection add type team con-name team0 ifname team0 autoconnect yes config '{"runner": {"name": "activebackup"}}'
 2,添加成员    add  type  team-slave    con-name   ifname master
 3,配置ip地质    team0
 4，激活所有配置   up


九，搭建基本Web服务
 1，安装 httpd   
 2，重起服务
 3，书写一个页面文件  /var/www/html  index.html
 

十，搭建基本FTP服务   vsftpd


十一，RHEL7的防火墙体系
  #查看默认区域   get  #修改默认区域 set  #服务的添加   add-service
  permanent     reload      list-all
   -从客户机访问 端口1 的请求,自动映射到本机 端口2
 # firewall-cmd --permanent --zone=public 
--add-forward-port=port=5423:proto=tcp:toport=80
 --remove-  删除                --reload  --list-all


十二，Samba服务基础
    用途:为客户机提供共享使用的文件夹 (跨平台的共享,Windows与Linux）
   1,安装samba软件
   2，建立samba共享帐号    useradd -s /sbin/nologin  pdbedit -a
   3,修改 /etc/samba/smb.conf主配置文件
   4，重起smb服务
   5， SELinux策略修改，布尔值功能的开关 getsebool -a   setsebool

虚拟机desktop0
    	通过挂载，更加科学方便的访问Samba共享
	1.安装cifs-utils软件包（支持cifs协议）
	2.进行挂载    mkdir      mount -o user=,pass= //172.25.0.11/common  /mnt/nsd01      df -h
	3.开机自动挂载samba共享/etc/fstab      }

搭建读写的Samba共享     服务端：虚拟机Server0
  1.修改配置文件/etc/samba/smb.conf        write list = .
  3.修改SELinux策略    # setsebool samba_export_all_rw on
  4.赋予chihiro本地目录权限  setfacl


$十三，iSCSI网络磁盘   虚拟机server0，构建iSCSI共享存储服务端
  $，进行分区
  1.安装软件包:targetcli
  2,运行 targetcli
  3.建立后端存储  backstores/block  create  name=  dev=
  4,建立target,磁盘组 iscsi/ create  iqn.yyyy-mm.倒序域名:自定义标识
  5,lun,关联    tpg1  luns create  /backstores/block/nsd 
  6.开启服务监听的端口，开启监听的本机IP地址  portals  本机IP
  7.配置访问控制ACL，设置客户端声称名字  acls   iqn...:客户端声称名字
  8.重起服务   restart   enable

客户端：虚拟机desktop0
1.安装软件包  iscsi-initiator-utils     #iscsi启动软件包
2.修改配置文件，指定客户端声称的名字  InitiatorName=
3.重起iscsid服务，仅仅就是刷新iqn名称   daemon-reload
4.发现服务端共享存储 参考：man  iscsiadm
5.重起iscsi服务,将共享存储加载到本机    lsblk   #可以看到sda


十四，数据库服务基础
    1.安装mariadb-server     启动mariadb服务
    2，使用数据库mysql  show databases; creat database .;  drop .;
    3,为数据库管理员 账号修改密码  mysqladmin -u .  password .
    # mysql -u root -p        # mysql -u root -p123   #非交互式 
    4,导入数据库的数据  # wget
    # mysql -u root -p123 nsd < users.sql 
      将users.sql的数据导入到nsd库中
    5,表格操作   增(insert)    删(delete)      改(update)     查(select)
    6,数据库授权   除了root用户,授权用户**查询，用户密码
     – GRANT 权限列表  ON 数据库名.表名 TO 用户名@客户机地址
       IDENTIFIED BY '密码';
    7，多表查询，有条件的查询，表记录的删出及增加   base
                   flush privileges;   #刷新user表记录 


十五，HTTP服务基础      WEB
   1.安装httpd软件     书写网页文件  /var/www/html/index.html 重起
  2，ServerName:本站点注册的DNS名称 (空缺)  Server0.example.com
     修改配置文件  /etc/httpd/conf/httpd.conf     重起httpd服务
  3，DocumentRoot:网页文件根目录(默认为/var/www/html
    创建目录   书写文件  修改配置文件  /var/www/myweb   重起
   4,重起
 #虚拟Web主机       基于‘域名    端口   IP’ 的虚拟主机（区分方式）
     vim   /etc/httpd/conf.d/*.conf     #调用配置文件
 为每个虚拟站点添加配置,容器类型的配置
	<VirtualHost  IP地址:端口>
	  ServerName  此站点的DNS名称
	  DocumentRoot  此站点的网页根目录
      </VirtualHost>
   
 #访问控制
	<Directory 目录的绝对路径>
	.. ..
	Require all denied|granted
	Require ip IP或网段地址 .. ..
	</Directory>
   5)修改SELinux策略,安全上下文值(标签值:标识作用)
      ls -Zd ..       chcon -R --reference=..  ..
 
 *客户端访问服务端: 需‘防火墙  服务本身  本地目录  SElinux’ 的访问控制权限
   
 #部署动态网站         由Web服务软件接受请求,动态程序转后端模块处理
1.部署Python的网页文件   cd    wget      ..../webinfo.wsgi
2.方便用户访问webinfo.wsgi网页文件     Alias / 
3.翻译Python页面    mod_wsgi       WsgiScriptAlias  /
4.此虚拟webapp0.example.com主机侦听在端口8909      listen
5.SELinux限制所有非默认的端口开放 (布尔值   安全上下文值)
  semanage port -l ...       semanage port -a -t .. -p .  .
6.重起httpd服务 


*十六，部署安全的Web服务器,端口默认:443
1.安装软件包,支持安全Web服务器          mod_ssl
2.部署网站证书(营业执照)      cd    wget  certs/server0.crt
3.部署根证书(公安局信息)      certs/example-ca.crt
4.部署解密的私钥       private/server0.key
5.修改配置文件/etc/httpd/conf.d/ssl.conf
      :set nu   59  60  100  107  122  
6.重起httpd服务
7.验证:


十七，基础邮件服务          DNS服务器: classroom.example.com
     1.创建两个邮箱帐号     useradd
     2.安装邮件功能的软件    postfix
     3.修改配置文件/etc/postfix/main.cf    :set nu 99  116  164
     4.重起服务
     *收发邮件 mail -s .. -r . .      mail -u .       quit
 

十八，GPT分区模式  parted分区命令,可以划分
    GPT分区模式:    128个主分区       18EB容量 1EB=1000PB 1PB=1000TB 
   parted    mktable gpt    print     mkpart    unit GB  quit

*十九，交换空间，虚拟内存
     1.格式化, 交换文件系统      mkswap
     2.启用交换分区      swapon 
     3.查看交换空间组成的成员      swapon -s    swapoff
     5.开机自动启用交换分区    /etc/fstab     swapon -a


二十， 源码编译安装    源码包:非常的灵活,可以指定安装的位置及功能
     1，安装开发工具gcc与make
    2.tar进行解包
     3，配置 ./configure ,进行指定可以指定安装的位置及功能
     4，编译  make
     5，安装 make install


二十一，DNS解析            根据注册的域名查找其对应的IP地址systemctl 
       1.安装软件 bind  bind-chroot
       2.修改配置文件/etc/named.conf
       3.建立地址库文件/var/named/tedu.cn.zone
       4.重起服务
 
   多区域的DNS服务器     zone

    特殊的解析记录
        1.重复解析记录,可以达到轮询
        2.泛域名解析        *
        3.有规律的泛域名解析       $GENERATE:产生连续的数字
        4.解析记录的别名     CNAME

    DNS子域授权
         1.安装软件bind  bind-chroot
         2.修改配置文件/etc/named.conf
         3.建立地址库文件/var/named/bj.qq.com.zone
         4.重起服务
         5.验证          nslookup

递归解析: DNS服务器与其他DNS服务器交互,最终将答案带回来的过程
迭代解析: DNS服务器与其他DNS服务器交互

缓存DNS,加快解析速度
            方式1:全局转发
                1.查看真机DNS服务器ip地址       /etc/resolv.conf
                2.真机搭建Yum仓库     mount   /iso/CentOS-.
                3.真机搭建缓存DNS服务器,修改配置文件   书写真机的DNS地址
                4.虚拟机A:验证    echo nameserver ..      nslookup
       虚拟机A
             1.安装一个可以提供域名解析的软件  bind-chroot    bind
             2.修改主配置文件/etc/named.conf    
             3. 建立地址库文件/var/named/sina.com.zone   -p:权限不变进行拷贝
             4,客户端：虚拟机B 验证DNS解析

    方式2:根域迭代

DNS分离解析
	   1.由上到下依次匹配，  匹配即停止
           2.使用view时，所有的客户端都必须在分类中
 	   3.所有的zone都必须在view中
 	   4.每一个view中的zone必须相同


  #二十一，DHCP服务构建      用来简化主机地址分配管理
   DHCP概述及原理,整个过程通过广播进行,先到先得(一个网路中,不能有多台)
   	1.安装软件包          dhcp
        2.修改配置文件/etc/dhcp/dhcpd.conf 
             :r  /usr/share/doc/dhcp*/dhcpd.conf.example
        3.重起dhcpd服务

二十二，PXE网络装机
  PXE组件及过程分析
  • 需要哪些服务组件?
  – DHCP服务,分配IP地址、定位引导程序
  – TFTP服务,提供引导程序下载
  – HTTP服务,提供yum安装源
	
	A搭建DHCP服务,设置网络装机配置
	1.修改配置文件     2.重起dhcpd服务

   	B部署TFTP服          
       tftp    重起     3.部署pxelinux.0文件   /var/lib/tftpboot/
       4.部署菜单文件       5.部署 图形模块 与  背景图片
       6.部署 启动内核 与  驱动程序  vmlinuz(启动内核)  initrd.img(驱动程序)
       7.修改菜单文件内容

       C搭建Web服务,共享光盘所有内容
      1安装httpd软件        2.重起httpd服务    3建立目录/var/www/html/rhel7
      4.挂载光驱设备        5.测试访问

       D生成应答文件,实现无人值守安装
 	1.安装一个图形system-config-kickstart的工具,生成应答文件
	2.运行system-config-kickstar
	3.共享ks.cfg文件
	4.修改菜单文件,指定ks.cfg文件


二十三，rsync+SSH远程同步
	ssh无密码验证
	1.生成公钥 私钥     ssh-keygen
	2.传递公钥 到对方机器  ssh-copy-id ..
	3.验证    rsync -avz --delete /opt/ ..

	部署inotify-tools工具软件,监控目录内容变化
真机的操作:  # scp /root/桌面/tools.tar.gz  ..
虚拟机A: 1.安装gcc与make开发工具    2.tar解包
	3.运行./configure进行配置  4.执行make 编译
	5.执行make  install 安装
	6.验证   ls /usr/local/bin/inotifywait










ADMIN  ##########################################

# ping 127.0.0.1  测试目标ip是否可连同
# whoami   显示当前用户
# hostname         # hostname  -s   显示主机名
#  su  ..   切换用户
# ls ..     列出文件或目录List
           – -l :以长格式显示,显示详细属性
           – -h:提供易读的容量单位(K、M等)
           – -d:显示目录本身(而不是内容)的属性
           – -A:包括名称以 . 开头的隐藏文档  
# ls  -l .. 查看..下详细信息  指定了别名，叫ll
# ls  --help 查看ls的帮助
# ls -Z(查看文件的标识) ls -Zd '目录'   selinux 安全上下文标识
# mkdir ..  创建目录
        -p:建立父目录，建立多级目录

# cd ...    切换工作目录
     cd  ..  :返回上一层
     ~user  :用户家目录                    相对路径：不以/开始的路径 
      /root : 管理员root用户的家目录    绝对路径：以/开始的路径

# pwd       显示当前工作目录
# touch ..  创建空文件
# cat ..  # cat  -n .. 在终端屏幕上显示文件内容
# more ..  # less  ..  分屏显示文件内容
# head .. # head  -3  # tail ..  # tail  -2 
 head/tail默认查看文件头部/尾部10行，也可以自行指定
# grep  adm ..【文件 】  查看包含adm的行
# mount /dev/cdrom /nsd  #进行挂载,让/nsd成为/dev/cdrom的访问点
#  umount  ..   卸载
# du -sh  ..    统计目录文件大小
# alias  别名='实际运行的命令'   命令的别名：简化复杂的命令
# rm 删除 — Remove
      – -r、-f:递归删除(含目录)、强制删除
# mv 移动/改名— Move        
       – 格式:mv   [选项]...   原文件...     目标路径
        2重命名:路径不变的移动  原文件（目录） 命名为 目标文件（目录）
# cp 复制  
      —cp  [选项]...   原文件...      目标路径
       – -r:递归,复制目录时必须有此选项
    # \cp  -r  ..  ..  #取消覆盖的提示(复制过再复制时会提示是否覆盖)


# uname  -r  查看内核版本号
# cat  /etc/redhat-release 查看操作系统的版本号
# lscpu      查看CPU
# cat  /proc/meminfo   或 # free  -m 查看内存信息
# ifconfig   查看网卡信息
# cat /etc/sysconfig/network-scripts/ifcfg-eth0

# shutdown  -h  now             关机
# reboot 或 # shutdown  -r  now  重起
# ssh  root@..   远程管理服务器：以root身份登陆..




• Tab键自动补全
- Ctrl + c :结束正在运行的命令
– Ctrl + l :清空整个屏幕
– Esc + . 或 Alt  + . :粘贴上一个命令的参数
– Ctrl + c :结束正在运行的命令
– Ctrl + u : 清空至行首
– Ctrl + w : 往回删除一个单词(以空格界定)

• 针对不确定的文档名称,以特殊字符表示
  – *:任意多个任意字符
  – ?:单个字符
  – [a-z]:多个字符或连续范围中的一个,若无则忽略
  – {a,min,xy}:多组不同的字符串,全匹配




• vim文本编辑器
  – 格式:vim [[/目录/]文件名]
– 若目标文件不存在,则新建空文件并编辑
– 若目标文件已存在,则打开此文件并编辑      
三个模式：命令模式     输入模式(插入模式)       末行模式

# rht-vmctl reset ...  真机：还原虚拟机
# ping ...          1.真机上操作：测试真机能否通信
# ssh   root@  .    2.真机上操作：远程管理
# ssh -X root@ .     3.远城管理打开对方的图形程序
# firewall-config    #防火墙图形配置程序

# rpm  -q  .  软件名（程序名） #检测程序是否安装
# rpm -ivh .    #安装软件包
# rpm -e  ..     #卸载软件包
了解：系统导入红帽签名信息
# rpm --import /dvd/RPM-GPG-KEY-redhat-release 

# yum -y      ..   #安装软件包
# yum clean all .  #清空Yum缓存
# yum  remove ..   #卸载软件包
# yum  search ..    #查询软件包信息

wget下载工具
– wget  软件包的URL网址
– wget  软件包的URL网址    -O  /目录路径/新文件名


配置网络
• 查看nmcli connection 识别网卡的名字
# nmcli connection show
• 配置IP地址、子网掩码、网关地址
# nmcli   connection   modify   'System eth0'    
 ipv4.method   manual  
 ipv4.addresses  '172.25.0.100/24    172.25.0.254'
 connection.autoconnect   yes
# cat /etc/sysconfig/network-scripts/ifcfg-eth0
             #查看网卡配置文件
# nmcli connection up 'System eth0'     激活配置
# route   #查看网关的指令          gateway(网关)  
# vim /etc/resolv.conf       永久DNS服务器地址
nameserver  172.25.254.254
# nslookup server0.example.com    #测试解析


  > :覆盖重定向
  >> :追加重定向
# echo nameserver 172.25.254.254  > /etc/resolv.conf 非交互式

管道操作：将前面命令的输出结果,交由后面命令继续处理,作为后面命令的参数
# ifconfig | head -2     显示第一张网卡的IP地址

# bc    交互式计算器   加 +  减  -   乘 *   除 /     取余运算  %


用户基本信息存放在 /etc/passwd 文件（户口本）
# head  -1  /etc/passwd
        root:x:0:0:root:/root:/bin/bash
用户名:密码占位符:UID:基本组GID:用户描述信息:用户家目录:解器程序
– useradd [选项]... 用户名
– -u 用户id、-d 家目录路径、-s 解释器程序（登录Shell）、-G 附加组
/sbin/nologin : 禁止用户登陆系统
# grep          # id
– passwd [用户名]
– echo '密码'    |    passwd --stdin 用户名     非交互式设置密码
– usermod   修改用户属性
– userdel  [-r]  用户名   #连同家目录一并删除

组基本信息存放在 /etc/group 文件
# grep stugrp /etc/group
 stugrp:x:1303:
组名:组密码占位符:GID:组成员列表
– groupadd [-g 组ID] 组名       
– gpasswd -a 用户名  组名     添加组员
– gpasswd -d 用户名  组名     删除
– groupdel 组名

• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理
– -t:显示归档中的文件清单
– -C:指定释放的位置
打包：
   tar  选项       /路径/压缩包的名字       /路径/被归档及压缩的源文件
解包:
   tar  选项       /路径/压缩包的名字     -C  /路径


– chmod [-R] 归属关系+-=权限类别    文档...
        [-R] 递归设置权限             #ls -ld  

– chown [-R] 属主         文档...
– chown [-R] :属组       文档...
– chown [-R] 属主:属组  文档...
        [-R]  递归修改归属关系

Set GID   目录下新增的文档自动设置与父目录相同的属组
• 附加在属组的 x 位上    
– 属组的权限标识会变为 s     # chmod g+s /nsd06
Set UID     • 附加在属主的 x 位上   变为 s
Sticky Bit  • 附加在其他人的 x 位上  会变为 t


ACL   
– getfacl 文档....
– setfacl [-R] -m  u:用户名:权限类别   文档...
– setfacl [-R] -m  g:组名:权限类别   文档...
– setfacl [-R] -b  文档...      #清空所有的ACL策略
– setfacl [-R] -x  文档...      #删除指定的ACL策略

 grep  '字符串'    /路径/文本文件
        -i 忽略大小写
        -v 取反
          特殊的过滤条件
         ^root   必须以root开头
         root$   必须以root结尾
                 ^$           匹配空行

find 查找文档所在位置
     find   查询路径     条件
      -type 类型(f 文件   d 目录   l 快捷方式)
      -name  "名字
       多条件的查找  -a   且and，可以不写，默认-a   -O(或)
       -size +-大小   k M G     按大小查找
       -user     按照所有者查找
       -iname   • 根据名称查找,忽略大小写
       -group   • 根据所属组查找
       -maxdepth  限制目录查找的深度(最大层数)
       -mtime +-天数 • 根据文件修改时间，所有时间都是过去时间

   查找完了以后，查找的结果～直接执行处理
           find .. .. -exec  处理命令 {}    \;



– 引用变量值:$变量名
– 查看变量值:echo  $变量名、echo  ${变量名}
  $[ ] :代表运算   
   $( )与反撇号  ` ` ： 将命令的输出结果，作为命令的参数
  储存随机数的变量：RANDOM
  USER=当前登陆的用户名
位置变量
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. 
 read -p  :  可以在脚本运行的时候，从命令行传递变量的值

	$#  已加载的位置变量的个数
	$*  所有位置变量的值,再重新输出一遍
	$?  程序退出后的状态值,0表示正常,其他值异常

条件测试
   [  测试表达式  ]      #每一部分都要有空格
    • 检查文件状态
	-e：判断文档是否存在，存在为真
	-d：存在并且为目录为真
	-f：存在并且为文件为真
	-r：存在并且对其有读取权限为真
	-w：存在并且对其有写入权限为真
	-x：存在并且对其有执行权限为真
  • 比较整数大小( 带e字母的都有等于二字)
	-gt:大于
	-ge:大于等于   
	-eq:等于         
	-ne:不等于
	-lt:小于
	-le:小于等于
  • 字符串比对
   ==: 字符串相等为真
   !=:字符串不相等为真
 
  · 组和判断  &&   ||
















网络、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、网络







  

		练       看      想        记



show running-config
查看当前运行的配置
show ip route
查看路由表
show access-list
查看访问控制列表
show ip nat tranlation
查看nat的缓存表（路由）
show ip interface brief
查看接口模式
特权模式：show  interface  f0/5  switchport



show vlan brief
查看路由表
show mac-address-table
查看mac地址表


11111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111


物理层——网卡、中继器             比特流
*RJ - 45 网络接口                 RJ-11  电话的接口
*光纤接口    FC  ST  SC  LC  MT-RJ  各类接口，用的时候具体挑选
*双绞线 ～TP平常使用的网线，非屏蔽双绞线UTP、屏蔽双绞线STP
双绞线的标准，速率  cat6  1000Mbps（1Gbps）   cat7 （10Gbps
 cat5   cat5e 100Mbps  普通家用，公司基本都是千兆
线缆的连接   T568A :白绿,绿, 白橙, 蓝,白蓝, 橙, 白棕,棕
          T568B : 白橙,橙, 白绿, 蓝,白蓝, 绿, 白棕,棕
线缆的连接    标准网线    交叉网线      全反线
物理层的设备    网络接口卡    10/100M   100/1000M   USB . PCI 网卡
            中继器      放大信号   延长网络传输距离
#Invalid input(无效的输入)
*write    或   copy running-config  startup-config  (保存配置
*enable   #进入特权模式
*config terminal  #进入全剧配置模式
*interface fastethernet f0/1  #进入端口
*enable password 123      #修改进入特权模式的密码
*erase startup-config    #清空设备配置
*reload        #重起
*show running-config  #查看交换机配置信息
*hostname  ..   # 修改交换机主机名
*no ip domain-lookup  #禁用DNS查询(输错信息时,会进入查询.ctrl+shift+6
                           退出,禁用DNS后就不会发生再查询了)
*line console 0
#exec-timeout 0 0     配置控制台会话时间用不超时
*line console 0
#logging synchronous   #配置输出日志同步


222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222



数据链路层——交换机——      数据帧
MAC地址（十六进制）
十六进制，一位=四位，二进制位
MAC 地址的第8位为0时表示该MAC地址为单播地址（物理地址），为1时表示组播地址（逻辑地址）。48位都为1表示广播地址。
广播——向除了接受数据的端口外的所有端口发送数据
Ipconfig  /all  查看MAC地址
一字节=八比特，48位的mac地址，占用六字节
交换机，24个网络接口+2个上层网络接口（用于和外部、网络连接）
广播域——接受同样广播消息的节点的集合。、vlan，分割广播域
交换机的所有端口默认属于同一个广播域
vlan（虚拟局域网） -- 广播控制   安全性  带宽利用  延迟
最多可以创建4096个vlan，0～4095。根据交换机的性能，或许只能创建一千多个
Trunk  中继链路  交换机给每个去往其他交换机的·数据帧·打上vlan标识
Access 接入链路（接入模式）一个   Trunk 中继链路（中继模式）多个
ISL Cisco私有的（外部标记·30）   IEEE 802.1Q 公有的标记方式（内部·4）
dynamic auto动态自动（默认的接口状态）  
EtherChannel-以太通道（多条链路捆绑到一起）


*show mac-address-table   #查看mac地址表     -交换机
*ipconfig /all    #查看主机的ip      —客户机上
*vlan vlan-id     #创建vanl+号    #vlan 5
*name land-name   #给创建好的vlan命名   #name caiwu
*show vlan brief  #查看vlan配置
*no vlan vlan-id  #删除vlan       #no land 2
*switchport access vlan vlan-id #将端口加入vlan 
*no switchport access vlan 2
*interface range f0/1-9   #进入多个端口（将多个端口加入vlan）
----switchport access vlan 2
*show vlan id vlan-id  #精确查看某个vlan的信息，#show vlan id 2
*switchport mode trunk  #配置交换机之间互联的端口为Trunk
*show interfaces f0/1 switchport  #查看接口模式 dynamic auto动态自动
*channel-group 1 mode on  #先进入要捆绑的端口号 range 捆绑成以太通道、号
     以太通道     组号  启用
*interface port-channel 1   #switchport mode trunk 
*show etherchannel summary   #查看捆绑端口信息




33333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333

网络层——路由   网关 ——   数据包
ip地址分、5类 1- 127、128-191、  192-223 、  224-239  、240-254
网络段、是否相同
网络位 ——255.    主机位  ——.0
路由器：识别数据包的目标ip地址、源ip、在路由表中发现可能的路径、
         选择路由表中到达目标最好的路径、维护和检查路由信息
 --每个路由器都维护着一张路由表，这是路由器转发数据包的关键；*指路
路由表：静态、缺省路由‘由管理员手工配置’  分支机构、家居等小型；
    动态路由‘通过路由协议自动设置’  isp服务商、广域网、园区等大型
路由器端口默认是关闭的，需要手动打开
网关地址，默认是该网段的最后一位
·C  直连路由 S 静态路由     S*默认路由
三层交换机——虚接口 、在三层交换机上配置的VLAN接口为虚接口
            • 使用SVI(交换虚拟端口)实现VLAN间路由
              – 虚接口的引入使得应用更加灵活
三层交换机的配置
• 确定哪些VLAN需要配置网关
• 如果三层交换机上没有该VLAN则创建它
• 为每个VLAN创建相关的SVI
• 给每个SVI配置IP地址
• 启用SVI端口
• 启用三层交换机的IP路由功能
• 如果需要,配置三层交换机的劢态或静态路由
OSPF  路由表的数据存放在一个链路数据库中
～邻居列表+链路数据库——计算后的得到路由表（？路由表
OSPF区域    先有区域-0  再有其他的   进程-1    进程号比区域号大-1

路由器只需要宣告内网网段，外网不需要宣告



*ip address ip地址  子网掩码     #给网关配ip
*no shutdown   #打开端口
*show ip route   #查看路由表
*no ip address    #删除端口配的ip，后面不需要再接ip 地址
*ip route 目标网络ID 子网掩码 下一跳   #指定到达ip目的网络“静态路由
                    目标网络ID ，目标ip所在的网段，不是具体的ip *.0
*ip routing      #在三层交换机启用路由功能
# interface vlan vlan-id    三层交换机、虚接口的引入，配置ip
# ip address ip_address netmask
# no shutdown

# no switchport        – 配置路由接口
#interface fastEthernet 0/24           #在三层交换机上配置
#switchport trunk encapsulation dot1q  -Trunk并指定接口封装为802.1q
#switchport mode trunk
*route ospf process-id  #启动OSPF路由进程
*network address inverse-mask area area-id  #inverse-mask:反掩码
                                 #指定OSPF协议运行的接口和所在的区域
*clear ip ospf process   #重起ospf进程（？）

#route ospf 1
#default-information originate  ·宣告自身有默认路由
#network 0.0.0.0  0.0.0.0 area 0 


4444444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444444




传输层         TCP/IP  定义端口号—服务
 TCP  传输控制  可靠、连接 效率低   UDP 用户数据报 不可靠、无连接 效率高 
TCP：源端口号、目标端口号 ACK  SYN  FIN，标志位，经典的三次握手、四断开
SYN：请求建立连接  ACK：同意建立连接  FIN：请求断开连接
TCP: FTP 21 SMTP 25 DNS 53 HTTP 80 Telent 23 ssh 22 . .
UDP: TFTP 69 DNS 53 NTP 123 ..
• 访问控制列表(ACL)
– 读取第三层、第四层 头部信息   ip 端口 
– 根据预先定义好的规则对数据进行过滤
类型 • 标准访问控制列表
     – 基于源IP地址过滤数据包
     – 标准访问控制列表的访问控制列表号是  1~99
   • 扩展访问控制列表
      – 基于源IP地址、目的IP地址、指定协议、端口来过滤数据包
      – 扩展访问控制列表的访问控制列表号是  100~199
access-list 一个列表可以写多个条目——permit|deny  源  反掩码  匹配

私有ip地址分类
• A类 10.0.0.0~10.255.255.255
• B类 172.16.0.0~172.31.255.255
• C类 192.168.0.0~192.168.255.255

NAT作用      网络地址转换
– 通过将内部网络的私有IP地址翻译成全球唯一的
公网IP地址,使内部网络可以连接到互联网等外
部网络上。

*access-list  access-list-number {permint|deny} source [source-wildcard]  #创建ACL 允许or拒绝 ip 子网掩码用  反掩码 （匹配或不匹配）
# access-list 1 deny 0.0.0.0 255.255.255.255  • 隐含的拒绝语句
    或 access-list 1 deny any 任意，所有   —host 只对应一个ip
#ip access-list 1 deny 192.168.1.1  0.0.0.0
或#ip access-list 1 deny host 192.168.1.1

*ip access-group access-list-number {in|out} • 将ACL应用于接口
# no ip access-group access-list-number {in |out} ·取消接口ACL

# Show access-lists   • 查看访问控制列表
# no access-list access-list-number   • 删除ACL
# access-list 101 deny tcp 192.168.1.0 0.0.0.255
host 192.168.2.2 eq 80                 • 应用实例
# access-list 101 permit ip any any

#ip nat inside source static local-ip global-ip  • 静态NAT配置
                    *设置内部和外部的IP地址，然后添加静态地址转换
#ip nat inside source static 192.168.1.1 100.0.0.2
                                            • 建立静态地址转换
#interface g0/1      #ip nat outside   #ip nat inside
                                  • 在内部和外部端口上启用NAT
#ip nat inside source static tcp 192.168.1.6 80
61.159.62.133 80    • 建立NAT端口映射关系     tcp协议  80 * 端口号

• PAT(端口多路复用)
#access-list 1 permit any   • 定义内部ip地址
#ip nat inside source list 1 interface g 0/1 overload
                                      • 设置复用动态IP地址转换
#debug ip nat   • debug ip nat命令跟踪NAT操作
#undebug ip nat





5555555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555555




STP  生成树协议   防止广播风暴、备份线路
根网桥  • 网桥ID（BID） 
     网桥--之前交换机就叫做网桥，随着功能增加，改为交换机的名字了
– 网桥ID是唯一的,交换机之间选择BID值最小的交换机作为网络中的根网桥  
     缺省值：32768  +-4096（整数倍）     主根网桥  次根网桥
  FWD正常转发    BLK阻塞端口、临时断开
• PVST+配置的意义
– 配置网络中比较稳定的交换机为根网桥
– 利用PVST+实现网络的负载分担
HSRP    • 热备份路由选择协议   -HSRP -Cisco私有协议  -VRRP 共有协议
HSRP组成员   -活跃路由器  -备份路由器 -虚拟路由器 -其他路由器
     路由器：优先级100 +  越大越优先



*show version    #查看版本
#spanning-tree vlan vlan-list  ·启用生成树命令
#spanning-tree vlan vlan-list priority Bridge-priority
*spanning-tree vlan vlan-list root {primary|secondary}
                                         ·指定根网桥    主   次 
#show spanning-tree     ·查看生成树的配置
#show spanning-tree vlan vlan-id  ·查看某个vlan的生成树详细信息
            HSRP备份组号（最好用所在vlan的号）
#standby group-number ip virtual-ip-address
                              备份组虚拟ip地址   ·配置为HSRP的成员
#standby group-number priority priority-value  范围0～255，默认100
                                                   ·配置HSRP的优先级
#show standby brief    ·查看HSRP摘要信息
#standby group-number track fastethernet 0/*
                        • HSRP端口跟踪配置
#standby group-number preempt    • HSRP占先权配置



























$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
##########################################################
*****************************************************************



                   shell shell shell






  vim  莫行模式
    :nohl   取消高亮






vnc  172.40.50.188:8


shell      逻辑思维   现实的问题---代码（命令）
·在linux内核与用户之间的解释器程序
·通常指 /bin/bash
·负责向内核翻译及传达用户/程序指令
·相当于操作系统的“外壳”

公式----------------------应用题


常见的脚本语言  Bash Shell  , Python/Perl/Ruby
		JSP/PHP/ASP/CGI,  JavaScript


理解    自己的逻辑思维能力

shell  就像是汽车的总称      bash  像是某种车（宝马，奔驰）
解释器程序的概述                     某种解释器程序


bash    sh  tcsh  csh    cat /etc/shells



at 21:00    设定时间计划任务

yum -y install ksh    安装ksh包

cat /etc/shells     查看有哪些解释器程序

ksh               进入ksh环境            redhat使用的bash，人性功能全

useradd -s  /bin/ksh  zhangsan   执行修改执行环境操作
usermod  -s  /bin/bash  zhangsan

grep  HISTSIZE  /etc/profile      检查历史命令的容量
vim  /etc/profile        修改历史命令的容量
history | wc -l   查看当前用户记录的历史命令条数
history | tail    最近十条   history | head
!1028   调用第1028条历史命令     !cat  调用最近一条以cat开头的命令
history -c   清空自己的历史命令   cat  ~/.bash_history
 > ~/.bash_history     清空历史命令保存文件

交互式硬件设备
·标准输入  /dev/stdin  键盘
·标准输出 /dev/stdout  显示器
·标准错误输出 /dev/stderr 显示器

alias   产看已经定义的命令别名列表
grep '^alias' ~/.bashrc   别名的设置一般存放在用户的.bashrc文件内
alias lh='ls -lh'     自定义新的命令别名  alias lh  确认结果
lh  /etc/fstab   验证别名命令的效果
unalias lh   取消别名     alias lh

>   2>   &>  <       重定型标准输入/输出/错误输出   >>  2>>  &>>  

mail -s '..'  root  <  /etc/passwd   发送文件内容多的邮件
echo ‘..’  | mail -s '..' root    内容小的邮件     
echo '..' > a.txt   +  mail -s  '..' root  < a.txt
   |   一条命令可以实现复杂的功能      管道
yum list | grep samba | wc -l    一条命令行支持多个管道


1，屏幕显示hello world
2，自动配置yum源
3，自动安装vsftpd软件；自动启动服务；自动设置开机自启

** sh -x 开启脚本调试模式
    set -x 跟踪脚本的莫一部分   set -x 开始  set +x 结束

*env   查看有哪些环境变量（系统定义好的）   
*set  列出所有的变量
*unset 撤销自定义的变量

PWD USER HOME UID SHELL HOSTNAME   MAIL  RANDOM
 
PS1=''                  PS2=''

环境变量   位置变量   预定义变量   自定义变量
/etc/profile  ~/.bash_profile   

$$ 执行脚本的PID(进程号)   $0  $1  $2     $?    $#    $*   $$   

双引号可以界定一个完整字符串                     "echo $x"
单引号界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能。  'echo $x'


变量的扩张应用    ""   ''  ` `    read -p       stty -echo  stty echo
  
export xx="123"    使用export命令将xx发布为全剧变量



******shell 语言，解释程序
	交互式----命令行   非交互式 ----脚本
	usermod   chsh 	历史命令
	重定向 
	变量分类    扩张





2222222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222222
2222222222222222222222222222222222222222222222222222222222222222





expr  整数运算工具    \*   乘法加上 \ ，取消*的预定shell
       +       -      *      /        %

$[]   或  $(())  乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号

let命令
expr或$[]、$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值   let运算操作并不显示结果，但是可以结合echo命令来查看：
let x++ ；x++(x=x+1) let x--;(x=x-1) let x+=3;(x=x+3) let x-=3;
(x=x-3) let x*=2;(x=x*2)  let x/=2;(x=x/2) let x%=2;(x=x%2)

bc交互式运算      可以运算非整数，小数位的长度可采用scale=N限制
bc非交互式运算   将需要运算的表达式通过管道操作交给bc运算
                    echo 'scale=4;12.34+5.678' | bc

echo "2==2" | bc    ;  echo "2>3"  | bc  ;  echo "3<4" | bc
bc可以用来做判断   0 错  1 对

shell 脚本的智能化，为命令的执行提供识别依据
	文件或目录的读写等状态
	数值的大小
	字符串的比较
	多条件组合  逻辑关系 
	

条件测试的基本用法
“test 表达式”          [ 表达式 ]      == (相等)  != （不相等）

 一行执行多条命令的情况
   # A && B     and     //仅当A命令执行成功，才执行B命令
   # A || B     or     //仅当A命令执行失败，才执行B命令
   # A ;  B           //执行A命令后执行B命令，两者没有逻辑关系
   # A && B || C     //思考？

-z 检查变量的值是否未设置（空值）  [ -z $NB ]      -n=! -z 不为空


1,字串判断   ==  ！=  -z  !-z
2.数值判断   -eq   -ne   -gt  -ge  -lt  -le
  [ 3 -eq 3 ]  && echo y  || echo n
3.文件/目录的判断     -e  -f  -d  -r  -w  -x
4，多条件组合 [ $USER == "root" ] && [ $PWD == "/root" ]
		[ -d "/opt/testdir" ] || mkdir -p /opt/testdir


if  单分支    双分支     多分支

ping 192.168.4.254 -c 2   ping两次   -c 几次   -i 指定ping的间隔时间
                  -W 等待反馈的超时秒数



******整数运算expr  $[ ]		小数运算 bc
	变量的自增减 i echo $[i+=2]    let i++ 
	条件判断的分类  字串  数值  文件/目录   多条件组合（逻辑
	if  单   双   多分支
	



333333333333333333333333333333333333333333333333333333333333
333333333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333333333




for  i in {1..5}   `seq 5`   `cat /etc/passwd` 
do
..
done
  

while :      判断是真       [  $i -le 100 ]
do
..                        let i++
done

case  变量  in          简化的if判断
1)
   命令;;
2)
   命令;;
*)
   命令;;
esac

funcation  函数名 {
  命令
}
                                     脚本，上面先定义函数； 下面再调用
  函数名（）  {
     命令
}

#  ·Shell版fork炸弹
#    — 仅13个字符：    .(){ .|.& };.
#    — 递归死循环，可迅速耗尽系统资源


*echo {1...5}    {}里面不能有变量
*seq 5      可以是变量, 作用和{}相同，但是在shell里。要用``括起来
`ls /etc/*.conf`   可以是一个有输出的命令

bash -x /root/user.sh   #-x 可以看到脚本执行的过程，方便排错

echo -n ..    # -n 输出完不要换行

sar -P ALL 1 100 #-P 看我的cpu信息  ALL 全部的 1 1秒看一次  100看100次

case 分支属于匹配执行的方式     

while 循环   匹配条件  无心的死循环   ！

for 循环   指定次数，范围

if  选择判断

echo -e "\033[34mOK\\033[0m"       #34字体大小  OK输出什么字颜色
                                              带颜色的echo
shell函数

     halt  reboot=shutdown -h now  


tmp 临时密码 


 break   跳出当前所在的循环体，执行循环体后的语句块
continue 跳过循环体内余下的语句，重新判断条件以决定是否需要执行下一个循环
 exit    退出脚本，默认的返回值是0

	
*******for		while		case

44444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444




字串截取的三种用法：
 ·    ${变量名:起始位置:长度}
 ·   expr substr "$变量名"   起始位置   长度    # 字串截取的一种格式
  ·   echo $变量名 | cut -b 起始位置—结束位置
字串替换的两种用法：
 ·  只替换第一个匹配结果： ${变量名/old/new}
 ·  替换全部匹配结果 ： ${变量名//old/new}
字符串掐头去尾：
  · 从左向右，最短匹配删除 ： ${变量名#*关键字}
  ·              长          ： ${变量名##*关键字}
  · 从右向左，   短         ： ${变量名%关键字*}
  ·               长          ：${变量名%%关键字*}

#phone="15684649976468"     
#echo ${#phone}    #变量phone包括多少 个字符
#echo ${phone:6:2}  #从左侧第七个开始，截取两位～起始位置从0开始


mv  $i  ${i%.*}.txt




数组  （是一个变量，一个变量可以存多个值）
	x=(11   22   33   44)
	echo ${x[0]}  自0开始
	echo ${x[1]}
	echo ${x[2]}
	echo ${x[3]}
	echo ${x[*]}   全部显示    ${x[*]}=${x[@]}  显示所有
	echo ${#x[*]}   统计变量的个数

追加数组——内容
echo ${#x[*]}   显示变量的个数 
x[5]=55         变量个数+，内容
echo ${x[*]}     查看全部的变量


mail -s "test"  root   <<  EOF  #EOF往下的内容一直到下一个EOF，
  xxx                               都是邮件的内容
  yyy
  zzz
EOF


yum -y install expect   #expect 是自动交互软件,帮人自动交互

字符串初值的处理
一，字符串初值的最常见处理方法   1）只取值  ${var:-word}
  #xx=11
  #echo ${xx:-123}  //因xx已存在，输出变量xx的值
       #unset xx
   #echo ${xx:-123}   //xx不存在，所以会输出 123
二，编写脚本...
   3）expect 预期交互 

expect <<EOF
spawn  命令
expect ""   {send "..\n"}
EOF  #结尾

expect脚本的最后一行默认不执行
如果不希望ssh时出现yes/no的提示，远程时使用如下选项:
# ssh -o StrictHostKeyChecking=no server0



什么是正则表达式？
 — 使用“一串符号” 来描述有共同属性的数据

正则表达式                  grep -E  / egrep  过滤工具
基本：
   ^   匹配行首
   $    匹配行尾
   [ ]    集合，匹配集合中的任意单个字符
   [ ^ ]    对集合取反
    .       匹配任意单个字符    "\.""\ "屏蔽"."的特殊含义，只是作为普通的.
     *      匹配前一个字符任意次数 [ *不允许单独使用 ]
   \{n,m\}   匹配前一个字符n到m次
                 \{n\}  匹配n次   \{n,\} 匹配n次以上    

egrep  -n 内容+行号  -i 忽略大小  -v 反  -c 行数     -q 静默  --color



过滤开头不是英文字母
小数点结尾


扩张正则列表

   +       1+
   ？      0-1
  {n,m}   n-m
    ()      整体
    |       或者
   \b    单词边界



***  echo ${变量}
     echo ${变量::}    截取
     echo ${变量///}   替换        ${变量//old/new/} 全替换
     echo ${变量#*:}    掐头       ${变量##*:}   最长匹配
     echo ${变量%:*}    去尾       ${变量%%:*}   最长匹配
     echo  ${变量:-1234}    变量付初值
*** 数组 （一个可以存多个值的变量）
        x[0]=12
        x[1]=12
        x[2]=12
      x=(12  12  12)        echo ${x[0]}
***  expect << EOF
     spawn 命令
     expect 看屏幕输出 { send "输入键盘指令\n"}
     EOF
***  正则表达式
      ^     开始
      $    结尾
      [ ]  集合，集合中的任意单个字符
      [^]   对集合取反
      .     任意单个字符
      *     前一个字符出现了任意次，包括0次
      \{n,m\}    \{n,\}   \{n\}  前一个字符 n-m n+ n  次


*** 扩张正则列表

	   +         1+
	   ？        0-1
	  {n,m}     n-m
	    ()         整体
	    |          或者
	   \b      单词边界



******* 字串截取/替换/掐头去尾
	shell数组	 expect 预期交互
	正则表达式 




55555555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555555555
555555555555555555555555555555555555555555555555555555555555


/etc/sysconfig/network-scripts/ifcfg-eth0
ip 改了后，写到这个文件里了


 #wait 等后台进程结束后，命令行才结束。返回
 #clear 清屏


*#$
sed ·Stream EDitor ,流式编辑器
 — 非交互，基于模式匹配过滤及修改文本
 — 逐行处理，并将结果输出到屏幕
 — 可实现对文本的输出、删除、替换、复制、剪切、导入、导出等各种操作

sed -n  屏蔽默认输出，默认sed会输出读取文档的全部内容
    -r  让sed支持扩展正则
    -i  sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响
  
  *sed 工具的条件，
   1） 行号 
    #sed -n '3p' '3,5p' '3p;5p' '3,+10p' '1~2p' '2~2p'
 
    #sed -n '1~2p' ..  从第一行开始，每隔2行打印以下  俗称步长,步长2

   2) 正则                                        '/bash$/p' 结尾
     打印包含root的行
     #sed  -n '/root/p'  /etc/passwd  '/^root/p' '5p' 'p'
            '/root/!p' 不包括
   

   3)   p 、打印行    d  、删除行     s  、字符替换  
         a  追加（后    i  插入（前     c 全行都更换掉
         正则  运用到命令里
      #sed -n 'p' /etc/passwd   #没有条件，则表示匹配所有行
	#sed -n '4p' a.txt    #输出第4行
	#sed -n '4,7p' a.txt   #输出第4～7行
	#sed -n '4,+10p' a.txt  #输出第4及其后的十行
	#sed -n '/^bin/p' a.txt #输出以bin开头的行
	#sed -n '$+' a.txt   #输出文件的行数

	#sed  '3,5d' a.txt  //删除第3～5行  
	#sed  '/xml/d' a.txt  #删除所有包含xml的行
	#sed  '/xml/!d' a.txt  #删除所有不包含xml的行
	#sed  '/^install/d' a.txt #删除以install开头的行
	#sed  '$d' a.txt  #删除文件的最后一行
	#sed  '/^$/d' a.txt  #删除所有空行

	#sed  's/xml/XML/' a.txt  #将每行中的第一个xml替换XML
	#sed  's/xml/XML/3' a.txt  #将每行中的第三个xml替换XML
	#sed  's/xml/XML/g'  a.txt #  所有的
	#sed  's/xml//g'  a.txt   #  所有的xml替换成空（删除）
	#sed  's#/bin/bash#/sbin/sh#'   #/bin/bash替换为/sbin/sh
    **替换操作的分隔“/”可改用其他字符，如#、$等，便于修改文件路径
	#sed  '4,s/^/#/'  a.txt  #将第4～7行注释掉（行首加#）
	sed  's/^#an/an/' a.txt  #解除以an开头行的注释（行首去掉#

	#sed 's/.//2'  a.txt   # .所有的  2 替换第二个字符

	# sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt

	# sed 's/[0-9]//' nssw.txt
	# sed -r 's/[0-9]//g;s/^( )+//' nssw2.txt

	# sed 's/([A-Z])/[\1]/g' nssw.txt

	#sed  's/$/***/' a.txt  #在每行末尾添加***
   *cat -A a.txt  #可以看到，每行末尾都默认以$结尾，$替换为*** 

    a=append 追加  （后   在某一行下面写入
    i=insert  插入 （前   在某一行前面写入，
     #sed  '2a  xxx'  a.txt
     #sed  '2i xxx'   a.txt
     #sed  '/root/a xxx'  a.txt  后        '/xa/i xxx'前    
     #sed  '2c  xxx'  a.txt



linux:/etc/hosts
windows:/windows/systemc32/drivers/etc/hosts



sed 文本编辑器，增  删  改 查
    总结知识点： 
   #sed [选项] '条件指令' 文件
    选项:
	-n 屏蔽默认输出
	-r 支持扩展正则
	-i 修改源文件
	条件：
	行号 4 4,5 4~2 4,+10
	/正则/
	指令：
	p 打印
	d 删除
	s 替换s/旧/新/g
	a 追加
	i 插入
	c 替换行


#sed  '2h,5g' a.txt
#sed  '2H,5G' a.txt


**** cat -A /etc/fstab    #末尾行都默认的是 $ 结尾



****** sed


6666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666
6




*sed  文本编辑器，修改文件  增  删  改   查

*awk  数据过滤，查数据       = grep


* awk 选项 'BEGIN{指令}  条件{指令}  END{指令}'
   print "常量字符串"
   print $0 $1 $2 .. NR NF
  过滤条件：
  1，正则
      /正则/  $1~/正则/  $2~/正则/  $1!~/正则/
  2，数字或字符比较
  NR==3   $3>=1000  $3<1000 $4<10  $5<1000
   $1="root"  $1!="root"
   df -h  挂载使用清空      free 空闲内存
  3，逻辑判断
        && 并且    ||  或者
  4，运算
    awk 'BEGIN{print x++}'
    awk 'BEGIN{print x=x+8}'
* 流程控制  if  分支
  if($3>=1000){x++}else{y++}





过滤  统计      == grep   |  wc    

 ·  awk 编程语言 （不学）/数据处理引擎（主要学习的方面

awk 基本操作方法
 ·  awk 选项  '条件{指令}'    文件     print  ; 分隔
         {print $1，$3}     $ 表示列    默认空格，Tab空  分隔列

#free   看内存，交换分区
    #awk -F:  '{print $1}'  /etc/passwd  *-F  指定分隔符 ：
    #awk -F"[:/]" '{print $1,$10}'  /etc/passwd   *[:/] 正则
    #awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
  "" 可以打印长量，有引号   中间有逗号，有空格。没逗号，也可以，就没空格了
   #awk -F: '{print $NF}' /etc/passwd #输出每行最后一个字段  
  **awk常用内置变量：
	  $0 文本当前行的全部内容
	  $1	文本的第1列
	  $2	文件的第2列
	  $3	文件的第3列，依此类推
	  NR	文件当前行的行号
	  NF	文件当前行的列数（有几列）

   #ifconfig eth0 | awk '/RX p/{print $5}'  //过滤接受数据的流量
            #RX p..接受数据流量的行   第五列      * TX p 发送数据
   # df -h | awk '/\/$/{print $4}'   提取根分区剩余流量
          #根分区  末尾以 /  结尾，第四列   “  \/  屏蔽 /”

# tailf /var/log/secure  动态看..文件的后十行
# tailf /var/log/secure | awk '/Accepted/{print $11}'   成功
# tailf /var/log/secure | awk '/Failed/{print $11}'   失败
     #其他机器远程ssh本机， 查看访问成功/失败 的主机ip


F5 刷新

#awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件
   BEGIN{ }	 行前处理，读取文件内容前执行，指令执行1次    初始化
    { }	  逐行处理，读取文件过程中执行，指令执行n次    指令
   END{ }	 行后处理，读取文件结束后执行，指令执行1次     总结

#awk 'BEGIN{A=24;print A*2}'   #awk 里，A不用加$.默认的就是变量
#awk 'BEGIN{print x+1}'   #任何字母可以不需要定义，直接用，默认的是0
                              a-Z
#awk 'BEGIN{x=0}/bash$/{x++}END{print x}' /etc/passwd

# awk -F: 'BEGIN{print "用户名","UID","家目录"}{print $1,$3,$6}
END{print "总用户量："NR}' /etc/passwd  | column -t  
                                 | column -t 列、纵，对齐

***awk 处理条件：
  1) 使用正则设置条件
    awk -F: '/bash$/{print}' /etc/passwd
    awk -F: '/bash$/' /etc/passwd
    awk -F: '$1~/root/' /etc/passwd       ~ 正则匹配  模糊查找
    awk -F: '/^root/'  /etc/passwd       包含就匹配  区别  =  no
                ~ 包含    !~ 不包含
       awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd
   **  条件
     /正则/  全行匹配（包含即可） /root/
     $1~/正则/   第一列匹配 （包含即可）
    $1!~/root/    不包含      缺点，模糊   不精确

  2) 使用数值/字符串比较设置条件
        比较符号：==(等于) !=（不等于） >（大于）
        >=（大于等于） <（小于） <=（小于等于）
     awk  'NR==3{print $1}'  /etc/passwd
        awk -F: '$3>=1000{print $1}' /etc/passwd   非系统用户
     awk -F: '$1=="root"' /etc/passwd  #awk下，字符串必须加“”
   3) 逻辑测试条件    &&    ||
   awk -F: '$3>1000&&$3<1003' /etc/passwd
   awk -F: '$3>10000||$3<10'  /etc/passwd    
    awk -F: '$3>1000&&$3<10'  /etc/passwd
    awk -F: '$3>1000||$3<1003' /etc/passwd
    # awk 语法没问题就不出错， $  > && || < 之间对空格没要求
 

***** 
   awk  处理条件的设置：
    /正则/    数字/字符串       逻辑 &&  ||      数字运算

   # i=root     # -v 调用shell设定的变量
   # awk -F: -v x=$i '$1==x' /etc/shadow      
   #grep "^$i" /etc/shadow  | awk -F: '{print $1,$2}'

 *** awk 流程控制  一，if分支结构
awk  选项      '条件{指令}'  文件
# awk -F: '$3<=1000{x++}END{print x}' /etc/passwd

awk  选项      '{if ($3<=1000){x++}}END{print x}'    文件
                                      #系统用户有多少个
if($3<=1000){
x++
}                     if 的单分支判断，同上

if ($3<=1000){x++}else{y++}

# awk -F: '{if($3<=1000){x++}else{y++}}END{print x,y}' /etc/passwd         if 的双分支判断


  ***二，awk 数组  (面试里的经典，比较难，但是有用。必须熟记)
  #awk 'BEGIN{x[0]=11;x[1]=22;print a[0],a[2]}'
           #注意  定义数组用 ； 分隔， ;print  调用 用 ， 分隔
  #awk 'BEGIN{a["a"]=11;a["b"]=22;print a["a"],a["b"]}'
            #字母 加 ""
  #awk 'BEGIN{a[0]=1;a[1]=2;a[2]=3;for(i in a){print i,a[i]}}'
             #数组在输出所有变量时    a[i]   加i，加上变量号，好区分


#ll -h /var/log/httpd/access_log     5列$5 能看到文本大小，
                        增加用户访问量，会在日志里记录。所以文件大小会变化
# wc -l /var/log/httpd/access_log   访问量增加，行数会变化

#ab -c100 -n100000 http://192.168.4.254/
   -c 模拟有100人   -n 访问次数

 ** deny of service   #dos 攻击

#awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}'   | sort -n
    #统计每个ip访问的次数  ip 变量     # sort -n  从小到大排序

# who | awk '{root[$1]++}END{for(i in root){print root[i],i}}'
       # 扩展   统计 用户root 开启的终端  只有 $1 会变，其他都可固定不变









 *** awk 扩展应用
 



  #echo -n   横向输出，不要回车  
  #column -t   按列排版，纵  
  #sort -n     从小到大排序   -n 比较整串数字
                没有 -n 只会比较一串数字的第一个，然后第次






77777777777777777777777777777777777777777777777777777777777
7777777777777777777777777777777777777777777777777777777777777
777777777777777777777777777777777777777777777777777777777777




源码包不支持  systemctl start stop  status  ..
    /usr/local/nginx/sbin/ngix
    /usr/



  ps aux | grep httpd  | grep -v grep



  netstat -nutlp   可以看到所有启动的服务 

  uptime   看 cpu

  invalid user  无效的用户

   $!   最后一个进程号



  \n== 回车 Enter






shell 


******shell 语言，解释程序
	交互式----命令行   非交互式 ----脚本
	usermod   chsh 	历史命令
	重定向 
	变量分类    扩张


******整数运算expr  $[ ]		小数运算 bc
	变量的自增减 i echo $[i+=2]    let i++ 
	条件判断的分类
	if  单   双   多分支
	

*******for		while		case


******* 字串截取/替换/掐头去尾
	shell数组	 expect 预期交互
	正则表达式 


****** sed


 *** awk 扩展应用
 








#######################################################
#########################################################
################################################







			operation   operation 

firefox https://github.com/redhatedu/course


    网络          F12

Nginx  ——  engin X

Nginx 简介
Nginx（"engine x")
 俄罗斯人编写的十分轻量级的HTTP服务器
 是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器
  官方网站：http://nginx.org/


root   ——linux
rwx
  vsftpd,httpd,nginx服务 [共享]


administrator 禁用   微软
tom(管理员组)
      QQ程序（读哪些文件）
谁启动的这个程序


xx-devel    -devel  依赖包


ps aux  | grep nginx     


netstat  | wc -l       netstat   网络连接状态
netstat  -a  -n       -a  看所有   -n  以数字显示端口



nginx.conf
 全局设置：用户，日志，

html   ~ /usr/local/nginx/html

index  客户访问时，设定默认访问的首页  index 指出首页

htpasswd -c /usr/local/nginx/pass tom  # -c create 创建文件 用户
     #没 有 -c   # 追加用户


    -s reload    #不关服务的情况下，配置文件重新加在一遍




seo.chinaz.com/   站长工具  
www.51.cto.com




光表放到第一个# 上，ctrl + v    下 键     x  批量去注释



DNS(域名- - -IP)   所有人

/etc/hosts    本地解析     


加密算法     ： 对称算法    非对称算法   信息摘要
    对称算法   AES   DES  单机，自己设自己用
    非对称     RSA    DSA    网络数据访问，访问网络


/usr/local/nginx/conf      默认私钥生成路径
openssl genrsa         生成私钥
                   > cert.key    私钥的名称，可以随便写
                              教程里用cert  网页已经做好了

openssl req -new -x509 -key cert.key > cert.pem  生成证书（公钥





*****
# yum -y install gcc pcre-devel openssl-devel 
]# ./configure   \
> --prefix=/usr/local/nginx   \                //指定安装路径
> --user=nginx   \                            //指定用户
> --group=nginx  \                            //指定组
> --with-http_ssl_modul

# ln -s /usr/local/nginx/sbin/nginx /sbin/
# netstat  -anptu  |  grep nginx
#ps -aux    | grep nginx

# vim  /usr/local/nginx/conf/nginx.conf
	server { 
		...
        auth_basic "Input password:";      //认证提示符
        auth_basic_user_file "/usr/local/nginx/pass"; 密码文件

# yum -y install httpd-tools
#htpasswd -c /usr/local/nginx/pass tom  #创建密码文件 增加 不要-c
#cat /usr/local/nginx/pass   查看用户，密码 

* 基于域名的虚拟主机  
	server {			----定义虚拟机
		listen 80;
		server_name www.b.com;     #域名
	location / {		-----发布目录
		root www;
		index index.html index.html;
	}
	}
	#mkdir /usr/local/nginx/www
	#echo "www" > /usr/local/nginx/www/index.html

   端口  server { listen 8080;  ..
   IP   server { listen 192.168.4.11:80;  ..

* SSL 加密虚拟主机
	# cd /usr/local/nginx/conf
	# openssl genrsa > cert.key    生成私钥
	# openssl req -new -x509 -key cert.key > cert.pem /生成证书



*****nginx 非常轻量级的http服务器
	Unix和Linux #Apache ,Nginx ,Tomcat     
		     ？？？“Tengine,Lighttpd,IBM WebSphere,Jboss”
	微软 IIS（Internet Informatiion Server）
	*nginx -V -s  stop  reload
	--prefix=/usr/local/nginx  --with-http_ssl_module
	http{ .. server{ ..  location / { ..
	user nginx;  进程所有者
	worker_processes 1;  启动进程数量
	error_log  /var/log/nginx/error.log;  日志文件
	pid    /var/run/nginx.pid;    PID 文件
	events {  worker_connections 1024; } 单个进程最大并发量 
	auth_basic    auth_basic_user_file
	*httpd-tools   htpasswd  -c  
	基于域名  server_name www.a.com;   server_name www.b.com;
	基于端口  listen 8080; 		listen 8000; 
	基于IP   listen 192.168.0.1:80; listen 192.168.0.2:80;
	https  加密网站 
	 AES   DES  应用案例  RAR、ZIP压缩加密 （单机加密）
	 RSA   DSA  、、、    网络加密 （https、ssh） 
	Hash 值
	openssl genrsa > cert.key
	openssl req -new -x509 -key cert.key > cert,pem
	php-pcre-devel
	--without-http_rewrite_module



****** nginx   认证加密
	htpasswd ..  创建密码文件
	SSL 加密虚拟主机   openssl ..
	



2222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222
222222222222222222222222222222222222222222222222222222222222222

构建LNMP  平台   准备的东西

LNMP (Linux   Nginx   MySQL   PHP )
                             · 主流的企业网站平台之一

静态，动态     ？   ？
无论访问多少次，内容一直都是一样 的
动态  无需人为更改，不同的访问内容会变化， 需要脚本执行  动态网站

PHP   典型的网页制作语言  ，专用的，只能做网页   
         Java 可以制作网页，写小软件..

   Nginx  只能制作静态的网页    不做任何解释，只是将网页展示出来

linux  系统  nginx 接受数据，处理静态网页 mysql 存数据  php 动态网页


nginx
mariadb  mariadb-server mariadb-devel
php     php-fpm   php-mysql

rpm包   下载包网址 www.centos.org    or 百度 centos 镜像源

nginx   :80     mariadb  :3306      php  :9000


动静分离网站的实验   步骤

动静分离
                    nginx         php

nginx 实现：
如果用户访问的是静态页面，则自己直接找到页面，直接返回
如果用户访问的是动态php，则转发给9000 端口，解释后，再返回

       location   匹配用户的地址栏
	 location  /  {      匹配地址栏  /
		allow all;
	}
	firefox http://www.a.com/   地址栏
	location  /test  {     匹配地址栏   /test
		allow all;
		deny 1.1.1.1;
	}
	firefox  http://www.a.com/test/   地址栏
	location  /abc  {      匹配地址栏  /abc
		deny all;
	}
	firefox  http://www.a.com/abc/    地址栏

	#不论location  / 的位置前后，优先级都是最低的。默认匹配一切

～ 匹配                     *动静分离
      * location / {    #静态        /   除.php 结尾其他的所有
		root html;
	}
	location  ~ \.php$ {   #动态
		fastcgi_pass  127.0.0.1:9000;  #转发给9000端口处理
					*php-fpm的IP与端口
		include fastcgi.conf;   *加载fast_cgi参数文件
	}
       *firefox  http://192.168.4.5/a.html
	  firefox  http://192.168.4.5/a.php        .php 结尾
  *FastCGI  转发
#
#FastCGI 原理：
 #1、Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache    
     Module)
 #2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-
     cgi)并等待来自Web Server的连接。
  #3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个
     CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程
     php-cgi。
  #4、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回
      Web Server。



 #注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约30M的内存。

 #tailf /usr/local/nginx/logs/error.log         nginx 日志文件
             /usr/local/nginx/logs/access.log   nginx 错误日志
		/var/log/php-fpm/www-error.log     php 错误日志
			*?? 错误日志文件不会自己生成吗？ 怎么没有？
    ·  rewrite  regex  replacement flag  #regex 正则表达式 
    · rewrite  旧地址  新地址  [ 选项 ]
         rewrite /a.html  /b.html;


用电脑输入www.sina.com: 宽屏 pc
用手机输入www.sina.com: 窄屏 phone
  /usr/local/nginx/html/pc/
  /usr/local/nginx/html/phone/

   $http_user_agent

# yum -y install   mariadb   mariadb-server   mariadb-devel
# yum -y  install  php   php-mysql
# yum -y  install php-fpm-5.4.16-42.el7.x86_64.rpm



 **grant select on *.* to tom@1.1.1.1 identified by '123';





%%%%%%%%%  LNMP

   *fastcgi.conf;
   
   lnmp_soft/php_scripts/mysql.php
   *cp php_scripts/mysql.php    /usr/local/nginx/html/


   rewrite /a.html  /b.html;
   rewrite /a.html  /b.html  redirect; 

    rewrite ^/(.*)$ http://www.tmooc.cn/$1;


	if ($http_user_agent ~* firefox) {  //识别客户端firefox
	rewrite ^/(.*)$ /firefox/$1;
	}

	地址重写：获得一个来访的URL请求，然后改写成服务器可以处理的另一个
		   URL的过程
	好处：缩短URL，隐藏实际路径提高安全性   易于记忆、键入 易于被搜索

	）地址重写格式【总结】
	rewrite 旧地址 新地址 [选项];
	  last  不再读其他rewrite
	  break 不再读其他语句，结束请求    （location  /b.txt {..
	  redirect 临时重定向                      不再匹配  比last级别高）
	  permament 永久重定向



网络蜘蛛     百度   谷歌 
蜘蛛-----------------------爬--------------------->网站
                           /shoes.html, xiezi.html
       rewrite /shoes.html   /xiezi.html  redirect;
                                         permanent
                           premanent --在数据库直接更改

SEO search engine op？？       搜索引擎优化
SEM  花钱  标签，广告


****
  LNMP  环境 nginx mariadb mariadb-server mariadb-devel
		php php-fpm  php-mysql
	php-fmp 配置文件  /etc/php-fpm.d/www.conf
	nginx ..	/usr/local/nginx/conf/nginx.conf
	
	动静分离   location ~ \.php$ {     # ..  fastcgi.conf

	地址重写   rewrite /a.html  /b.html;     .. redirect;
	rewrite ^/  http://www.tmooc.cn/;   写在 localtion 外面
	rewrite ^/(.*) http://www.tmooc.cn/$1;    /下的目录..
	if($http_user_agent ~* firefox){
	rewrite ^/(.*)$ /firefox/$1；
	}

	正则匹配  ~ 区分大小写   ~*  不区分大小写
		  ! ~ 区分大小写不匹配  ! ~ 不区分大小写不匹配

	rewrite 旧地址 新地址 [选项];
	last 不再读其他rewrite
	break 不再读其他语句，结束请求
	redirect 临时重定向
	permament 永久重定向




****** nginx      LNMP    
	动静分离     地址重写


33333333333333333333333333333333333333333333333333333333
333333333333333333333333333333333333333333333333333333333
3333333333333333333333333333333333333333333333333333333333



Nginx 反向代理架构    HTTP   TCP/UDP

1)修改/usr/local/nginx/conf/nginx.conf配置文件

**配置upstream服务器集群池
   #使用upstream定义后端服务器集群，集群名称任意(如webserver)
   #使用server定义集群中的具体服务器和端口
	upstream webserver {
                server 192.168.2.100:80;
                server 192.168.2.200:80;
        }

   #通过proxy_pass将用户的请求转发给webserver集群
            proxy_pass http://webserver;

*server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
  #weight    设置服务器权重值，访问轮询几率，默认值为1
  #max_fails 设置最大失败次数
  #fail_timeout 设置失败超时时间，单位为秒
  #down   标记服务器已关机，不参与集群调度


# ./configure   \
> --with-http_ssl_module     //开启SSL加密功能
> --with-stream        //开启4层反向代理功能


   nginx.org    官网


stream {
            upstream backend {
            server 192.168.2.100:22;   //后端SSH服务器的IP和端口
            server 192.168.2.200:22;
	    }
            server {
            listen 12345;          //Nginx监听的端口
                proxy_connect_timeout 1s;
                proxy_timeout 3s;
             proxy_pass backend;
             }
}
http {





用户认证
虚拟主机
https加密网站
LNMP
地址重写
代理服务（http,tcp,udp,ip）


ss  等同于 netstat  在rhel7里面，用 ss

1）优化前使用ab高并发测试                     //提示打开文件数量过多
# ab -n 2000 -c 2000 http://192.168.4.5/   #失败了，改200就正常


2）修改Nginx配置文件，增加并发量   自身文件
    worker_processes  2;    //与CPU核心数量一致

    	events { 		          #EVENT 模块优化
	worker_connections 65535;    //每个worker最大并发连接数
      use epoll;
	}

3）优化Linux内核参数（最大文件数量）   selinux
# ulimit -a                        //查看所有属性值
# ulimit -Hn 100000                //设置硬限制（临时规则）
# ulimit -Sn 100000                //设置软限制（临时规则）

# vim /etc/security/limits.conf
    #用户或组    硬限制或软限制    需要限制的项目   限制的值

优化Nginx数据包头缓存

client_header_buffer_size    1k;     //默认请求包头信息的缓存    
large_client_header_buffers 4 4k; //大请求包头部信息的缓存个数与容量

浏览器本地缓存静态数据
firefox  about:cache
                                        不长修改的东西，缓存
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天
}

自定义报错页面
error_page   404  /40x.html;    //自定义错误页面  
                       页面内容自定意，叫什么都可以    公司平常是找人作的页面
4）常见http状态码   F12
    200  一切正常
    301   永久重定向
    302   临时重定向
    401   用户或密码错误
    403   禁止访问
    404   文件不存在
    414   请求URI头部过长
    500   服务器内部错误
   502   Bad Gateway







echo "aa"  | md5sum      以 二进制 模式 读入 文件
                               对 给定 的 文件 检验 MD5 效验码


6)  如何查看服务器状态信息

./configure  --help | grep status

--with-http_stub_status_module 


location /status {
                stub_status on;
        }

七：对页面进行压缩处理           gzip a.txt   gzip 压缩


gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //对特定文件压缩，类型参考mime.types

jpg,mp4,mp3,png,gif 多媒体文件
   不压缩      修改文件格式             

   *nginx  压缩
    *浏览器解压  ----------------> 所有浏览器都支持 gzip解压


八：服务器内存缓存

	http { 
	open_file_cache          max=2000  inactive=20s;
	        open_file_cache_valid    60s;
	        open_file_cache_min_uses 5;
	        open_file_cache_errors   off;
	//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
	//文件句柄的有效时间是60秒，60秒后过期
	//只有访问次数超过5次会被缓存
	} 



****    添加服务器池   反向代理    upstream 服务器集群池属性
	proxy [http]
	proxy [tcp]    --with-stream 支持4层TCP/UDP代理的Nginx服务器
	stream {		
	upstream xyz {	#定义后端服务集群
	   server ip1:22;        #ip_hash;
	   server ip2:80;		weight=2;    max_fails;
	}				fail_timeout;  down; 
	server {				属性
	  listen 12345;
	  proxy_pass xyz;        proxy_pass http://xyz;
	}   }
	http { 	..
*** ** 优化----  参考官网、案例
	# ab -n 2000 -c 2000 http://192.168.4.5/ 
	  worker_processes 2;   与cpu核心数量一致
	  worker_connections 65535;
	error_log /var/log/nginx.error_log info;  定义日志级别
	
	#ulimit -a   #ulimit -Hn 100000  #ulimit -Sn 100000
	#vim /etc/security/limits.conf
	优化Nginx数据包头缓存   cat lnmp_soft/buffer.sh  测试脚本
	修改Nginx配置文件，增加数据包头部缓存大小
	  client_header_buffer_size  1k;    默认请求包头信息的缓存
	  large_client_header_buffers 4 4k;  包头 缓存个数与容量

	location ~* \.(jpg|png)${
	   expires  30d;  }        缓存时间
	
	error_page  404  /40x.html;    自定错误页面


	> --with-http_ssl_module      //开启SSL加密功能
	> --with-stream              //开启TCP/UDP代理模块
	> --with-http_stub_status_module  //开启status状态页面

	gzip on;               //开启压缩
	gzip_min_length 1000;       //小文件不压缩
	gzip_comp_level 4;     //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;     //对特定文件压缩，类型参考mime.types

	http { 
	open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
	//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
	//文件句柄的有效时间是60秒，60秒后过期
	//只有访问次数超过5次会被缓存
	} 


***** HTTP 代理   Nginx 反向代理
	upstream     
	weight
	ip_hash
	max_fails
	fail_timeout
	--with-stream  --> TCP/UDP	开启 ngx_stream_core_module
	EVENT模块优化   events {
	HTTP 模块优化   http { 
	ab  -c ..  -n .. URL     压力测试
	其他常见压力测试软件 http_load,webbench,siege
	
	http { fastcgi_intercept_errors on;  错误页面重定向
	server { error_page 404  /40x.html;   自定义错误页面

	status  --with-http_stub_status_module 开启模块功能
	            可以查看Nginx 连接数等信息
	location /status {  stub_status on;   }
 	状态信息  
	Axtive connections 当前活动的连接数量
	Accepts   已经接受客户端的连接总数量
	Handled   已经处理的客户端的连接总数量
	Requests   客户端发送的请求数量
	reading   当前服务器正在读取客户端请求头的数量
	Writing   当前服务器正在响应信息的数量
	Waiting   当前多少客户端在等待服务器的响应




****Nginx 反向代理   模块优化   status 模块
	ab 压力测试工具




44444444444444444444444444444444444444444444444444444444444444444
4444444444444444444444444444444444444444444444444444444444444444444
44444444444444444444444444444444444444444444444444444444444444



*MySQL      *Oracle     *Microsoft SQL Server     前三的数据库


*MariaDB     第 14  位

mysql   , mariadb

数据库---->数据表1
name   age  sex  address  ...
tom     23  male   ip      ..

数据库----->数据表2

           Relational DBMS
传统数据库---------------------------------->  网站里最慢的，网站打开速度的一个瓶颈
    ·性能   CPU缓存>内存>磁盘>数据库
    ·价格   、、、、、、、、、、、、、

Key-value store   ,缓存数据库   数据存放在内存里的  缺点，重起数据就没了
*Redis    

注册tom，123------>内存--->硬盘

*memcached 是高性能的分布式缓存服务器
*Memcached   功能简单，数据会丢失    读写速度快  奇快

if   先查memcached内存；then
     从内存取，给用户
else
     从硬盘mysql查，给用户
     写入到memcached内存
fi     



environment  环境变量

/usr/lib/systemd/system/memcached.service
/etc/sysconfig/memcached 



yum list | grep memcache


ctrl +v  下键  shift+i （大写i） # esc #批量加注释
ctrl +v  下键  x   #批量注销注释


/var/lib/php/session/


tailf /usr/local/nginx/logs/error.log  #查看报错信息


*******
一：构建memcached服务 
          # yum -y  install   memcached
     配置文件（查看即可，不需要修改）
        # vim /usr/lib/systemd/system/memcached.service
        # vim /etc/sysconfig/memcached
     启动服务并查看网络连接状态验证是否开启成功：
   	# systemctl  start  memcached
	# systemctl  status  memcached
	# netstat  -anptu  |  grep memcached
		#使用ss命令可以替代netstat，功能与选项一样

二：使用telnet访问memcached服务器                 ***了解即可
	使用yum安装telnet
	# yum -y install telnet
   使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
	# telnet  192.168.4.5  11211
	set name 0 180 3      //定义变量，变量名称为name
	plj                     //输入变量的值，值为plj
	get name                        //获取变量的值
	
	add myname 0 180 10      //新建，myname不存在则添加，存在则报错
	set myname 0 180 10       //添加或替换变量
	replace myname 0 180 10   //替换，如果myname不存在则报错
	get myname              //读取变量
	append myname 0 180 10    //向变量中追加数据
	delete myname              //删除变量
	stats                   //查看状态
	flush_all                //清空所有
	quit                    //退出登陆
                      
LNMP+memcached
     
    gcc openssl-devel pcre-devel nginx mariadb 
	mariadb-server mariadb-devel php php-mysql php-fpm
       #修改Nginx配置文件        服务重起
       selinux  、 防火墙

三：创建PHP页面，使用PHP语言测试memcached服务
 	测试页面可以参考lnmp_soft/php_scripts/mem.php

注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
3）为PHP添加memcache扩展
	# yum -y install  php-pecl-memcache
	# systemctl restart php-fpm


****** session 存储在服务器端，保存用户名、密码等信息
	 cookies  由服务器下发给客户端 ，保存在客户端的一个文件里。
	保存的内容主要包括：sessionID 、帐号名，过期时间，路径和域

案例3：PHP的本地Session信息 
	  *php用session 来保存用户登陆信息  /var/lib/php/session/
	一，部署后端LNMP   #  ./configure   \
				> --with-http_ssl_module 
	二：启动LNMP服务器相关的服务
		nginx  mariadb  php-fpm
	三：部署前端Nginx调度服务器
		pcre-devel openssl-devel nginx  upstream 
	四：测试环境是否配置成功
		curl http://192.168.4.5   查看是否有数据
	五：部署测试页面      不需要自己创建，复制过去
		# cd lnmp_soft/php_scripts/php-memcached-demo
		cp -a  *  /usr/local/nginx/html/
		firefox http://192.168.2.100
		* ls /var/lib/php/session	

	google-chrome http://192.168.4.5 
		#不同后端服务器session不一致 ，推荐使用google浏览器测试

案例4：PHP实现session共享
	1)# yum -y install memcached
	  # systemctl restart memcached

	2)# yum -y install  php-pecl-memcache 
	注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，
		所以两台主机都需要安装PHP扩展模块		
	  # vim  /etc/php-fpm.d/www.conf   
	php_value[session.save_handler] = memcache
	php_value[session.save_path] = "tcp://192.168.2.5:11211"
	//定义Session信息存储在公共的memcached服务器上，
	  主机参数中为memcache（没有d）
	//通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）

	# systemctl  restart  php-fpm




**** memcached    telnet  PHP+memcached    session & cookies
     
LNMP (执行环境）  yum list |grep memcache    * php-pecl-memcache

	  web1(动态）/var/lib/php/session[SID]
proxy 						memcached(信息
	  web2


#for i in 100 200 
> do 
> scp -r lnmp_soft  192.168.2.$i:/root/
> done


# for i in 100 200 
> do 
> ssh 192.168.2.$i "yum -y install gcc pcre-devel openssl-devel mariadb mariadb-server php php-mysql "
> done


******memcached   telnet   PHP+memcached
	Session 共享   & cookies




55555555555555555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555555555555555555



  ·JDK 是Sun针对Java开发者推出的Java语言的软件开发工具包
  · JDK 是整个Java的核心
    —包括了 Java 运行环境  工具 基础的类库
	Java SE  标准版, Java EE 企业版 , Java ME 移动版

open-jdk

java[sun] --->oracle 收购，告   addriod[java,jdk]  goole  open-jdk

[rhel7]open-jdk 

sun[openoffice]--oracle  ---> apache
		libreoffice 开放的，office 开发的人员研究的免费公开版 
sun[mysql]------>
		mariadb
sun[java]------>jdk		sun 最牛的公司
		open-jdk

JRE  JDK的子集，Java的运行环境，精简版  没有开发工具

· 常见Servlet容器
	—IBM   	websphere
	—Oracle 	weblogic
	—Apache	tomcat ------->公开，免费     赚取人工的服务费
	—RedHat	Jboss      #其他的都是收费的


Tomcat    Apache 用java语言写的服务器 脚本
   支持XML格式的配置

** 1：安装部署Tomcat服务器
	# yum –y install  java-1.8.0-openjdk      //安装JDK
	# yum -y install java-1.8.0-openjdk-headless  //安装JDK
	# java -version          //查看JAVA版本
		#配置环境时默认已经安装过了，查看下版本号，不需要再安装
	# tar -xf  apache-tomcat-8.0.30.tar.gz  解包
	# mv apache-tomcat-8.0.30  /usr/local/tomcat 移动，重命名
	# ls /usr/local/tomcat

	bin/               //主程序目录
	lib/               //库文件目录
	logs/              //日志目录  
	temp/              //临时目录
	work/       	//自动编译目录jsp代码转换servlet
	conf/		      //配置文件目录
	webapps/          //页面目录

	# /usr/local/tomcat/bin/startup.sh   #启动
	# netstat -nutlp |grep java    //查看java监听的端口  #ss
	（提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用
	urandom替换random（非必须操作）。
		# mv /dev/random  /dev/random.bak
		# ln -s /dev/urandom  /dev/random）

    ：修改Tomcat配置文件
   # vim  /usr/local/tomcat/webapps/ROOT/test.jsp 创建测试JSP页面
	# /usr/local/tomcat/bin/shutdown.sh
	# /usr/local/tomcat/bin/startup.sh  #重启服务
	# netstat -nutlp |grep java    //查看java监听的端口
	# firefox http://192.168.2.100:8080     #测试页面
	# firefox http://192.168.2.100:8080/test.jsp

   2：使用Tomcat部署虚拟主机
	# vim /usr/local/tomcat/conf/server.xml 
			#修改server.xml配置文件，创建虚拟主机
	# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
	    */usr/local/tomcat/ */ROOT  #网页路径

	# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
	# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html
			#创建虚拟主机对应的页面根路径
	# /usr/local/tomcat/bin/shutdown.sh
	# /usr/local/tomcat/bin/startup.sh
			#重启Tomcat服务器
	# vim /etc/hosts  #客户端设置host文件，并浏览测试页面进行测试
	# firefox http://www.a.com:8080/    //注意访问的端口为8080

       使用docBase参数可以修改默认网站首页路径
	# vim /usr/local/tomcat/conf/server.xml
	<Host name="www.b.com" appBase="b" unpackWARS="true"
	 autoDeploy="true">
	<Context path="" docBase="base" reloadable="true"/>
	</Host>
	# mkdir  /usr/local/tomcat/b/base
	# echo "BASE" > /usr/local/tomcat/b/base/index.html
	# /usr/local/tomcat/bin/shutdown.sh
	# /usr/local/tomcat/bin/startup.sh
	# firefox http://www.b.com:8080/ //结果为base目录下的页面内容

	跳转
	# vim /usr/local/tomcat/conf/server.xml
	<Host name="www.a.com" appBase="a" unpackWARS="true"
	 autoDeploy="true">
	<Context path="/test" docBase="/var/www/html/" />
	</Host>
	# echo "Test" > /var/www/html/index.html
			...重起  访问页面测试

	配置Tomcat支持SSL加密网站    *keytool --help
	# keytool -genkeypair -alias tomcat -keyalg RSA \
	-keystore /usr/local/tomcat/keystore 
				#创建加密用的私钥和证书文件
	//提示输入密码为:123456
	//-genkeypair     生成密钥对
	//-alias tomcat     密钥别名
	//-keyalg RSA     定义密钥算法为RSA算法
	//-keystore  定义密钥文件存储在:/usr/local/tomcat/keystore
	# vim /usr/local/tomcat/conf/server.xml
		#修改配置文件 ，创建支持加密连接的Connector
	<Connector port="8443" .... 
	keystoreFile="/usr/local/tomcat/keystore"
      keystorePass="123456"   #添加，路径  密码
	//备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
		#重起  进入页面测试 https

	/prot="8443"      dd  "<!--      -->" #java的注释


** Varnish 缓存服务器   高性能  更快  管理更方便  优点

	一：构建Web服务器    httpd  nginx  都可以
                    #提供一个访问页面
	二：部署Varnish缓存服务器
	   gcc  readline-devel ncurses-devel pcre-devel 
	  python-docutils-0.11-0.2.20130715svn7687.el7.noarch.rpm
	# cp  etc/example.vcl   /usr/local/etc/default.vcl
	# vim  /usr/local/etc/default.vcl
	# varnishd  -f /usr/local/etc/default.vcl  启动服务
	# curl http://192.168.4.5
	# varnishlog 	//varnish日志
	# varnishncsa	 //访问日志
	# varnishadm   更新缓存数据
	varnish> ban req.url ~ .*
	//清空缓存数据，支持正则表达式





******  Tomcat
	appBase	docBase
	keytool -genkeypair -alias tomcat -keyalg RSA -keystore
	/usr/local/tomcat/keystore
	
	varnish    cache 池的复用
	varnishd -f /usr/local/etc/default.vcl 启动服务
	varnishadm ban req.url ~ .*  清除缓存内容的命令格式
	varnishlog [-w file] 共享内存的日志
	varnishncsa [-w file]  类Apache日志
	varnishstat     varnish 状态有？？



******open-JDK  java  tomcat

	Varnish  缓存代理




66666666666666666666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666666666666666



subversion   svn       检测版本        允许和他人协作 并跟踪文档
是一个自由/开源的版本控制系统

·记录每一次改变

SVN 版本控制
代码[模块]

运维：shell代码、配置文件[100]、标准化





ftp[common]  test.sh

A   B   C    D


一：安装Subversion服务器   svn
 yum -y install subversion

mkdir /var/svn
svnadmin create /var/svn/project    创建版本库
du -sh project/    空仓库的大小，

/usr/lib/systemd/system    决定了systemctl 可以启动 的文件
ls -R | wc -l  

# svn import . file:///var/svn/project/ -m "Init Data"
		 当前    #本地导入初始化数据


SecureCRT,putty  金山  输入ip，用户名，密码   远程服务器 
官方没有汉语，在公司的时候就不要用   非官方版 尽量少用 有bag 漏洞




版本控制	svn ,git
rpm -ivh   安装
rpm -qa	all
rpm -qf	哪个软件包提供的命令   rpm -qf /usr/bin/ls
rpm -ql	列出
rpm -qi	软件包信息
rpm -e    删



源码----->RPM
1，光盘没有
2，光盘有，但是 rpm -ivh #########


源码----安装--->  （createrepo/



****** 一：安装Subversion服务器
	#yum -y install subversion
	# mkdir /var/svn/
	# svnadmin create /var/svn/project   )创建版本库
	# cd /usr/lib/systemd/system/ 
	# svn import . file:///var/svn/project/ -m "Init Data"
			本地导入初始化数据
	# vim /var/svn/project/conf/svnserve.conf
	修改配置文件，创建账户与密码
	anon-access = none
	auth-access = write
	password-db = passwd
	authz-db = authz
	# vim /var/svn/project/conf/passwd 
	[users]
	harry = 123456
	//用户名和密码
	tom = 123456
	//用户名和密码
	# vim /var/svn/project/conf/authz 
	[/]                    //定义ACL访问控制
	harry = rw       //用户对项目根路径可读可写
	tom = rw
	# svnserve -d  -r /var/svn/project    #-r 指出绝对路径
	启动服务也可以使用svnserve -d启动，但客户端访问时需要指定绝对路径
	（svn://服务器IP/var/svn/project）。
	# netstat -nutlp |grep svnserve
		启动服务
	# cd /tmp
	# svn --username harry --password 123456 \
	co svn://192.168.2.100/ code    将服务器上的代码下载到本地
	
	Store password unencrypted (yes/no)? yes  //提示是否保存密码

	# svn ci -m "modify user"        //将本地修改的数据同步到服务器
	# svn add 			//添加到svn
	# svn update        //将服务器上新的数据同步到本地
	# svn info     svn://192.168.2.100    //查看版本仓库基本信息
	# svn log     svn://192.168.2.100    //查看版本仓库的日志
	# svn mkdir subdir                //创建子目录
	# svn rm timers.target            //使用svn删除文
	# svn diff                     //查看所有文件的差异
	# svn diff umount.target        //仅查看某一个文件的差异
	# svn cat svn://192.168.2.100/reboot.target    //查看服务器文件的内容
	 sed -i 'd' tmp.mount   //删除文件所有内容，但未提交
	# svn revert tmp.mount   //还原tmp.mount文件
	# svn update        //还原
	# svn ci  -m  "xxx"	/提交代码
	# svn merge -r7:2    tuned.service //将文件从版本7还原到版本2


***git
	git clone  下载所有文件
	git add	添加
	git commit -m "xx"    提交 
	git push    清空
	git pull    更新


		svn help

	使用Subversion协同工作
	# svn --username tom --password 123456  co 	
	svn://192.168.2.100/ code
	修改不同的文件   # svn update
	修改相同文件的不同行   
	修改相同文件的相同行
	
	# svnadmin dump /var/svn/project > project.bak  //备份
	# svnadmin create /var/svn/project2     //新建空仓库
	# svnadmin load /var/svn/project2 < project.bak   //还原


*** 制作nginx的RPM包
	# yum -y install  rpm-build   安装rpm-build软件包
	# rpmbuild -ba nginx.spec     //会报错，没有文件或目录
	# ls /root/rpmbuild         //自动生成的目录结构
	# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/
	   ）准备工作，将源码软件复制到SOURCES目录
	# vim /root/rpmbuild/SPECS/nginx.spec
		创建并修改SPEC配置文件
	Name:nginx        
	Version:1.12.2
	Source0:nginx-1.12.2.tar.gz
	./configure
	%doc
	/usr/local/nginx/*      //对哪些文件与目录打包

	：使用配置文件创建RPM包
	# yum -y install  gcc  pcre-devel zlib-devel openssl-devel
	安装依赖软件包
	# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
		rpmbuild创建RPM软件包
	# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
	# rpm -qpi RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
	# rpm -qpl nginx-1.12.2-10.x86_64.rpm 

	安装、卸载软件
	# rpm -ivh RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
	# rpm -qa |grep nginx
	

******版本控制
	svn ,git
	yum -y install subversiong
	mkdir /var/svn
	svnadmin create /var/svn/project
	cd 需要的目录
	svn import . file:///var/svn/project
	cd /var/svn/project/conf
	svnserver.conf 19  20  27   34
	passwd
	authz
	svnserve -d 
	svnserve -d -r  /var/svn/project

	svn --username tom --password 123456   checkout 
	svn://192.168.2.100  code
	>yes
	svn ci
	svn add
	svn mkdir
	svn mv
	svn cp
	svn rm
	svn info
	svn log
	svn cat
	svn revert
	svn merge
	svn update
	不同文件
	相同文件不同行 update
	相同文件的相同行update，手动删除多余文件
	git
	git clone
	git add
	git commit -m "xx"
	git push
	git pull
	
	源码----->RPM
	yum py install rpm-build
	rpmbuild -ba xx.spec
	cd /root/rpmbuild
	BUILD BUILDROOT SOURCES  RPMS SRPMS  SPECS
	cp  源码  SOURCES
	vim SPECS/xx.spec
	软件基本信息（填空）
	name:nginx
	version:1.12.2
	source0:nginx-1.12.2.tar.gz
	%post
	....     写想要的脚本
	%pre
	%setup -q
	./configure
	make
	make install DESTDIR={%buildroot}
	%file
	/usr/local/nginx/*

	rpm -------createrepo[/test]

	yum -y install nginx


*****svnadmin help 帮助
	svnadmin create 创建一个新的版本库

	svn import 执行导入操作
	   	-m  选项设置注释性的字符串
	 修改文件../svnserve.conf   ../passwd   ../authz
	svnserve -d  以守护进程方式运行svnserver
		--listen-port=port  监听的端口，默认端口号 3690
	-r root   设置一个虚拟路径，默认客户端要指定绝对路径访问库
	commit 提交修改
	update 将服务器上其他人的修改的代码更行到本地
	info 查看版本仓库信息
	log  查看版本修改历史
	add  list  del rm  mkdir  diff  cat  
	revert  merge    
	svnadmin  dump  ...
			load      create
	rpm-build   ....





****** svnadmin  svn   svnseve
	 git
	 RPM  rpm-build包  rpmbuild



7777777777777777777777777777777777777777777777777777777777777
777777777777777777777777777777777777777777777777777777777777
777777777777777777777777777777777777777777777777777777777777



VPN   Virtual Private Network (虚拟专用网络）
在公网里打一个私有的隧道，在公网之间连接就像是  私网之间连通
  加密通讯   各地子公司建立连接   像局域网一样通讯   企业网络广泛应用
  偶尔可以用于翻墙    主流VNP（GRE，PPTP，L2TP+IPSec,SSL

云技术   互联
物理（3虚拟机                        物流（3虚拟机
		  虚拟机之间互联---VPN
vlan  交换机   VPN  任何地方，区域

电脑 （北京    	互联网           上海）电脑
ping 192.168.4.5		ping 192.168.4.8


google facebook  youtube  都访问不了 <——VPN


*****	1：配置GRE VPN
	# lsmod                  //显示模块列表
	# lsmod  | grep ip_gre     //确定是否加载了gre模块
	# modprobe  ip_gre	   加载模块ip_gre
	# modinfo ip_gre		    查看模块信息
	filename:  /lib/modules/3.10.0-693.el7.x86_64/kernel/net/
	ipv4/ip_gre.ko.xz     路径

	# ip tunnel add tun0  mode gre \ 
	>  remote 201.1.2.5 local 201.1.2.10
	//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查
	看帮助
	//mode设置隧道使用gre模式
   //local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址

	# ip link show		启用该隧道（类似与设置网卡up）
	# ip link set tun0 up      //设置UP
	# ip link show

	# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
	>  dev tun0
	//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
	//隧道对面的主机IP的隧道IP为10.10.10.5/24
	# ip a s      //查看IP地址

	  *echo "1" > /proc/sys/net/ipv4/ip_forward
		1 开 0 关	#开启路由转发、关闭防火墙
	# firewall-cmd --set-default-zone=trusted
	ping 10.10.10.10


	同上，为proxy主机创建VPN隧道     *ip的位置 注意本地和对方
	
	2：创建PPTP VPN
	cd lnmp_soft/vpn
	yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
	rpm -qc pptpd

	# vim /etc/pptpd.conf   修改配置文件
	localip 201.1.2.5           //服务器本地IP
	remoteip 192.168.3.1-50     //分配给客户端的IP池
	# vim /etc/ppp/options.pptpd
	require-mppe-128       //使用MPPE加密数据
	ms-dns 8.8.8.8       //DNS服务器
	# vim /etc/ppp/chap-secrets        //修改账户配置文件
	jacob           *               123456      *
	//用户名    服务器标记    密码    客户端
	
	# systemctl start pptpd
	# systemctl enable pptpd   启动服务

	# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
	>  -j SNAT --to-source 201.1.2.5
	翻墙设置（非必需操作）

	：客户端设置
	启动一台Windows虚拟机，将虚拟机网卡桥接到public2，
	配置IP地址为201.1.2.20
	新建网络连接，输入VPN服务器账户与密码，连接VNP并测试网络
	  具体操作，参考案例

	
	3：创建L2TP+IPSec VPN
	本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通
	讯，具体要求如下：
	使用L2TP协议创建一个支持身份验证与加密的隧道连接
	使用IPSec对数据进行加密
	为客户端分配192.168.3.0/24的地址池
	客户端连接的用户名为：jacob，密码为：123456
	预共享密钥为：randpass

	部署IPSec服务
	# yum -y install libreswan   安装软件包
	# cat  /etc/ipsec.conf      //仅查看一下该主配置文件
	*include /etc/ipsec.d/*.conf   //加载该目录下的所有配置文件
	# vim /etc/ipsec.d/myipsec.conf 
	//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
	 rightsubnet=vhost:%priv      //允许建立的VPN虚拟网络
	authby=secret            //加密认证
	 ike=3des-sha1;modp1024           //算法
	phase2alg=aes256-sha1;modp2048      //算法
	left=201.1.2.200        //重要，服务器本机的外网IP
	 right=%any    //允许任何客户端连接
	
	创建IPSec预定义共享密钥
	# cat /etc/ipsec.secrets      //仅查看，不要修改该文件
	include /etc/ipsec.d/*.secrets
	# vim /etc/ipsec.d/mypass.secrets        //新建该文件
	201.1.2.200   %any: PSK  "randpass"    //randpass为密钥
                                                //201.1.2.200是VPN服务器的IP
	# systemctl start ipsec     
      # netstat -ntulp |grep pluto     )启动IPSec服务

	
	：部署XL2TP服务     
	cd lnmp_soft/vpn
	# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
	#  vim  /etc/xl2tpd/xl2tpd.conf      //修改主配置文件
	ip range = 192.168.3.128-192.168.3.254   //分配给客户端的IP池
	local ip = 201.1.2.200     //VPN服务器的IP地址
	# vim /etc/ppp/options.xl2tpd   //认证配置
	require-mschap-v2     //添加一行，强制要求认证
	#crtscts    //注释或删除该行
	#lock    //注释或删除该行
	# vim /etc/ppp/chap-secrets   //修改密码文件
	jacob  *   123456  *  //账户名称   服务器标记   密码   客户端IP
	# systemctl start xl2tpd
	# netstat  -ntulp |grep xl2tpd        启动服务

  
	# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
	>  -j SNAT --to-source 201.1.2.200
	翻墙设置（非必需操作）

	

	启动一台Windows虚拟机，将虚拟机网卡桥接到public2，
	配置IP地址为201.1.2.20。
	新建网络连接（参考案例2），

	设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass，
	具体操作如图-7所示。
	
	2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），
	具体操作如下：
	单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
	找到下面的注册表子项，然后单击它：
	HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services
	\Rasman\Parameters
	在"编辑"菜单上，单击"新建"->"DWORD值"
	在"名称"框中，键入"ProhibitIpSec"
	在"数值数据"框中，键入"1"，然后单击"确定"
	退出注册表编辑器，然后重新启动计算机




	4：NTP时间同步
	本案例要求搭建一个NTP服务器，为整个网络环境中的所有主机提供时间
	校准服务，具体要求如下：
	部署一台NTP时间服务器
	设置时间服务器上层与0.centos.pool.ntp.org同步
	设置本地服务器层级数量为10
	允许192.168.4.0/24网络的主机同步时间
	客户端验证时间是否同步


	部署NTP服务
	# yum -y install chrony
	# rpm -qc chrony    //查看配置文件列表
	
	# vim /etc/chrony.conf   修改配置文件
	server 0.centos.pool.ntp.org iburst  
			 //server用户客户端指向上层NTP服务器
	allow 192.168.4.0/24     //允许那个IP或网络访问NTP
	#deny  192.168.4.1      //拒绝那个IP或网络访问NTP
	local stratum 10      //设置NTP服务器的层数量

	# systemctl  restart  chronyd
	# systemctl  enable  chronyd  启动NTP服务

	：配置客户端
	# yum –y install chrony
	# vim /etc/chrony.conf
	server 192.168.4.5 iburst     //设置与哪台服务器同步数据
                    //iburst参数设置重启服务后尽快同步时间
	#  date  -s  "hour:minute"   //调整时间（小时：分钟）
	#  date          //查看修改后的时间
	# systemctl  restart  chronyd   重启chrony与服务器同步时间

 	5：pssh远程套件工具
	本案例要求使用pssh套件工具并发远程其他主机，具体要求如下：
	使用密码批量、多并发远程其他主机
	使用密钥批量、多并发远程其他主机
	批量、多并发拷贝数据到其他主机
	批量、多并发从其他主机下载数据到本机
	批量、多并发杀死其他主机的进程

	cd lnmp_soft/			准备工作
	# rpm -ivh  pssh-2.3.1-5.el7.noarch.rpm
	vim /etc/hosts     修改/etc/hosts本地解析文件
	192.168.2.100  host1
	192.168.2.200  host2
	192.168.4.100  host3
	… …
	# vim /root/host.txt   //每行一个用户名、IP或域名
	 root@host1
	host2
	host3

	使用密码批量、多并发远程其他主机
	# man pssh        //通过man帮助查看工具选项的作用
	pssh提供并发远程连接功能
	-A                使用密码远程其他主机（默认使用密钥）
	-i                将输出显示在屏幕
	-H                设置需要连接的主机
	-h                设置主机列表文件
	-p                设置并发数量
	-t                设置超时时间
	-o dir            设置标准输出信息保存的目录
	-e dir            设置错误输出信息保存的目录
	-x                传递参数给ssh

	# pssh -i  -A -H  'host1 host2 host3'   \
	>  -x '-o StrictHostKeyChecking=no'   echo hello
	使用密码远程多台主机执行命令，屏幕显示标准和错误输出信息
	
	# pssh -A -h host.txt   echo hello
	使用密码远程多台主机执行命令，不显示标准和错误输出信息，通过读取	
	host.txt读取主机信息

	：使用密钥批量、多并发远程其他主机
	# ssh-keygen -N  ''   -f /root/.ssh/id_rsa   
					  //非交互生成密钥文件
	# ssh-copy-id  host1
			host2    host3  ...
	 #pssh -h host.txt  echo hello
	使用密钥远程其他主机
	# pssh -h host.txt -o /tmp/  echo hello
	使用密钥远程其他主机，将标准输出信息写入到/tmp目录

	：批量、多并发拷贝数据到其他主机
	# man pscp.pssh      //通过man帮助查看工具选项的作用
	pscp.pssh提供并发拷贝文件功能
	-r    递归拷贝目录
	其他选项基本与pssh一致

	# pscp.pssh -h host.txt  /etc/hosts  / tmp
	将本地的/etc/hosts拷贝到远程主机的/tmp目录下
	# pscp.pssh -r -h host.txt   /etc/   /tmp 
	
	：批量、多并发从其他主机下载数据到本机
	# man pslurp       //通过man帮助查看工具选项的作用
	pslurp提供远程下载功能
	# pslurp  -h host.txt  /etc/passwd  /pass
  	 将远程主机的/etc/passwd，拷贝到当前目录下，
	 存放在对应IP下的pass文件中         注意：最后的pass是文件名
 	
	# pslurp -h host.txt -L  /media   /etc/passwd   /pass
	将远程主机的/etc/passwd目录，拷贝到media下，存放在对应
	IP下的pass文件

	：批量、多并发杀死其他主机的进程
	# man pnuke             //通过man帮助查看工具选项的作用
	pnuke提供远程杀死进程的功能
	
	# pnuke  -h host.txt  sleep
	将远程主机上的sleep进程杀死
	# pnuke  -h host.txt  test
	将远程主机上的test相关脚本都杀死（如：test1,testtt,test2等等）
	    chmod +x test1.sh   ...    #注意 加 chmod
	# pnuke  -h host.txt  test.sh
	将远程主机上的test.sh脚本杀死




	cal 1752	查看日历，闰秒？   1752 年，有一个月少了十一天



*****GRE,PPTP,L2TP+IPSec
       lsmod |grep ip_gre
	modprobe ip_gre
	modinfo ip_gre
	tunnel   	 link 	 peer

	ipsec.secrets
	systemctl start ipsec
	xl2tpd.conf   options.xl2tpd   chap-secrets
	
	NTP  Stratum 协议
	ntp  chrony

	PSSH   pscp.pssh  pslurp  pnuke
	



#################################################
################################################
################################################


operation

****** nginx   认证加密
	htpasswd ..  创建密码文件
	SSL 加密虚拟主机   openssl ..
	

****** nginx      LNMP    
	动静分离     地址重写

****Nginx 反向代理   模块优化   status 模块
	ab 压力测试工具


******memcached   telnet   PHP+memcached
	Session 共享   & cookies

******open-JDK  java  tomcat

	Varnish  缓存代理


****** svnadmin  svn   svnseve
	 git
	 RPM  rpm-build包  rpmbuild

*****GRE,PPTP,L2TP+IPSec
       lsmod |grep ip_gre
	modprobe ip_gre
	modinfo ip_gre
	tunnel   	 link 	 peer

	ipsec.secrets
	systemctl start ipsec
	xl2tpd.conf   options.xl2tpd   chap-secrets
	
	NTP  Stratum
	ntp  chrony

	PSSH   pscp.pssh  pslurp  pnuke
	

##################################################
###################################################
######################################################

		security




	1：Linux基本防护措施
	chage命令的语法格式：
	chage –l    账户名称          //查看账户信息
	chage –E 时间 账户名称       //修改账户有效期
	# useradd zhangsan
	#echo "1" | passwd --stdin zhangsan
	# chage -E 2015-05-15 zhangsan
     使用chage命令将用户zhangsan的账户设为当前已失效（过去的某个时间）：
	# chage -E 2019-12-31 zhangsan              //修改失效日期
	# chage -l zhangsan                        //查看账户年龄信息
	# cat /etc/login.defs    定义默认有效期
	PASS_MAX_DAYS    99999         //密码最长有效期
	PASS_MIN_DAYS    0        //密码最短有效期
	PASS_MIN_LEN    5           //密码最短长度
	PASS_WARN_AGE    7        //密码过期前几天提示警告信息
	UID_MIN        1000      //UID最小值
	UID_MAX        60000  //UID最大值
	# passwd -l zhangsan      //锁定用户账号lock
	# passwd -S zhangsan      //查看状态status
	# passwd -u zhangsan      //解锁用户账号
	修改tty登录的提示信息，隐藏系统版本
	# cat /etc/issue      //确认原始文件
	# vim /etc/issue         //修改文件内容
	Windows Server 2012 Enterprise R2
	NT 6.2 Hybrid
	：对于操作系统来说，文件系统也可以通过添加额外属性来提高性能与安全性。
	/dev/vda1   /boot    xfs   defaults,noexec   0  0
	noexec属性可以让分区下的所有程序都不可执行，包括病毒与木马
	dev/vda3   /home    xfs   defaults,noatime  0  0
	noatime让分区下的所有文件都不再更新atime时间，
	atime时间为文件的访问时间
	nomtime   m---modify     ll --mtime
	noatime   a---access	ll --atime
	noctime   c---status     ll --ctime

	# chattr +i  文件名     //锁定文件（无法修改、删除等）
	# chattr -i  文件名     //解锁文件
	# chattr +a  文件名      //锁定后文件仅可追加
	# chattr -a  文件名      //解锁文件
	# lsattr 文件名         //查看文件特殊属性

	sudo机制分配管理操作权限
	# su - zhangsan  -c "touch /tmp/test.txt"   
	     //管理员切换普通用户  -c  非交互，直接执行  创建

	# vim /etc/sudoers       //修改文件后，需要使用wq强制保存
	softadm    ALL=(ALL)   /usr/bin/systemctl         
	//授权softadm以root身份执行systemctl命令（ALL包括root）
	$ sudo -l
	[sudo] password for softadm:     //输入softadm的口令
	$ systemctl start httpd     //不用sudo时启动服务失败
	$ sudo systemctl restart httpd   //通过sudo启动服务成功
	useradm ALL=(ALL)  /usr/bin/passwd,!/usr/bin/passwd root,
	/usr/sbin/user*,!/usr/sbin/user* * root
	允许用户useradm通过sudo方式添加/删除/修改除root以外的用户账号
	# usermod -a -G wheel zengye
	允许wheel组成员以特权执行所有命令
	%wheel ALL=(ALL)  ALL
	用户 zengye 可以在该主机上运行以下命令：
	(root) /bin/*
	Defaults  logfile="/var/log/sudo"
	为sudo机制启用日志记录，以便跟踪sudo执行操作
	# vim /etc/ssh/sshd_config
	Protocol 2        //SSH协议
	PermitRootLogin no   //禁止root用户登录
	PermitEmptyPasswords no  //禁止密码为空的用户登录
	UseDNS  no    //不解析客户机地址
	LoginGraceTime  1m       //登录限时
	MaxAuthTries  3       //每连接最多认证次数
	# systemctl restart sshd
	# passwd -d kate   //清空用户口令

	针对SSH访问采用仅允许的策略，未明确列出的用户一概拒绝登录
	# vim /etc/ssh/sshd_config
	AllowUsers zhangsan tom useradm@192.168.4.0/24    
	        		//定义账户白名单
	##DenyUsers  USER1  USER2           //定义账户黑名单
	##DenyGroups  GROUP1 GROUP2          //定义组黑名单
	##AllowGroups  GROUP1 GROUP2       //定义组白名单

	实现密钥对验证登录（私钥口令）、免密码登入
	$ ssh-keygen
	Enter passphrase (empty for no passphrase):  
							//直接回车将口令设为空
	Enter same passphrase again:      //再次回车确认
	$ ls -lh ~/.ssh/id_rsa*    //确认密钥对文件
	$ ssh-copy-id root@192.168.4.5
	以用户root登入客户机，使用ssh-copy-id命令将自己的公钥部署到服务器：
	*authorized_keys  传送到对方机器的公钥
	*id_rsa.pub   密钥生成时自动生成的公钥，=authorized_keys重命名
	*id_rsa 	密钥
	 ～/.ssh/	对应用户家目录下/.ssh/    公、密钥位置
	没有ssh-copy-id  命令时，传递公钥就scp 然后重命名就可以了
	
	# vim /etc/ssh/sshd_config   确定密钥使用正常后，禁用密码验证
	PasswordAuthentication no   //将此行yes改成no

	：SELinux安全防护
	vim /etc/selinux/config
	enforcing  强制模式
	permissive  警告模式，宽松
	disable     禁用 selinux  不启用
	
	targeted   //保护策略为保护主要的网络服务安全
	（mls     多层安全机制 须修改安全上下文....
	minimum  修改有针对性的政策，只有选定的进程受到保护）
	
	yum -y install vsftpd  
	vim /etc/vsftpd/vsftpd.conf   仅仅看一下
	anonymous_enable=YES          //开启匿名访问
	anon_upload_enable=YES          //允许上传文件
	anon_mkdir_write_enable=YES        //允许上传目录
	# systemctl start vsftpd     //启动服务
	由root用户创建两个测试压缩包，一个直接建立到/var/ftp/目录下，
	另一个先在/root/下建立，然后移动至/var/ftp/目录。
	 ls -Z	查看，安全标签不一样   cp 会继承安全标签， 用mv
	# chcon -t public_content_t /var/ftp/d2.tar.gz
		修改上下文值，实现可以访问    selinux  enforcing
	上例中的chcon操作可替换为（效果相同）：
	# restorecon /var/ftp/log2.tar.gz
	或者
# chcon --reference=/var/ftp/log1.tar.gz /var/ftp/log2.tar.gz


	#visodu   =  vim /etc/sudoers  强制保存






****** chage   账户
	passwd 
	chattr 、lsatter
	su   sudo     visudo =vim /etc/sudoers
	ssh  sshd 黑白名单，远程权限  密钥验证
	ssh-keygen     whoami
	selinux   sestatus   chcon  




22222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222
22222222222222222222222222222222222222222222222222222222222222






斯诺登事件   ------> 加密与解密   -----> 事件的典型示例

hash值 哈希值是一段数据唯一且极其紧凑的数值表示形式
作用  确保数据完整性算法

md5sum  计算一个文件的哈希值  SHA256  SHA512
  #文件内容一致，则校验和不变  移动，重命名都不影响


vimdiff  校验文件.打开两份文件


reset 重置


	
	：检查文件的MD5校验和
	#md5sum  a.txt         
	
	yum -y install gnupg2  安装软件
	GnuPG是非常流行的加密软件，支持所有常见加密算法，并且开源免费使用。

	gpg -c a.txt   对称加密
	gpg -d a.txt.gpg > b.txt  解密
	
	gpg --gen-key    创建密钥对   默认算法RSA

	gpg --list-keys   查看公钥环

	gpg -a --export tommy >tom.pub  #导出
	--export的作用是导出密钥，-a的作用是导出的密钥存储为ASCII格式
	ASCII 加密格式，键盘可以敲出来的字符，看起来整齐一些
	
	gpg --import /tmp/tom.pub   导入接受的公钥信息

	y# gpg -e -r tommy love.txt #使用公钥 tommy 加密数据 love.txt
			# -e 使用密钥加密  -r 跟密钥
	x# gpg -d love.txt.gpg >love.txt  #tommy 以自己的密钥解密文件
			
**** gpg  -c -e -d    -a   -r
	--gen-key  --list-keys  --import  --export 


	
	*GPG的签名机制 ，私钥签名  公钥验证
	tar -zcf log.tar  /var/log/   建立测试文件
	gpg -b log.tar       #创建分离式数字签名
	scp log.tar*  ip:/root/  将签名文件和签名传给proxy

	gpg --verify log.tar.sig log.tar   验证签名
	
	
	*AIDE做入侵检测
	yum -y install aide
	cat /etc/aide.conf
	@@define DBDIR /var/lib/aide     //数据库目录
	@@define LOGDIR /var/log/aide     //日志目录
	database_out=file:@@{DBDIR}/aide.db.new.gz  //数据库文件名

	sed -i "98,1000 s/^/#/" /etc/aide.conf   #98行以后加注释
	sed -i "98a  /root/ DATAONLY"    仅保留/root目录 ，做检验
	
	aide  --init   # 入侵前对数据进行校验，生成初始化数据库
	cd /var/lib/aide/
	mv aide.db.new.gz aide.db.gz   对生成的数据文件，改名
	aide --check   #检查哪些数据发生了变化

	
	：扫描与抓包分析       NMAP 扫描器
	yum -y install nmap
	nmap -sP 防火墙开着，也可以扫描   mac地址  网段
	   -n  不执行DNS解析
	# nmap  -n  -sP  192.168.4.0/24    可以ping网段
	//常用的扫描类型
	// -sS，TCP SYN扫描（半开）
	// -sT，TCP 连接扫描（全开）
	// -sU，UDP扫描
	// -sP，ICMP扫描
	// -A，目标系统全面分析

	# nmap -p 21-22 192.168.4.0/24
	检查192.168.4.0/24网段内哪些主机开启了FTP、SSH服务
	# nmap   -sU  192.168.4.10
	检查目标主机所开启的UDP服务
	
	使用tcpdump分析FTP访问中的明文交换信息
	# yum -y install vsftpd
	# systemctl restart vsftpd
	# tcpdump -A host 192.168.4.5 and tcp port 21
	执行tcpdump命令行，添加适当的过滤条件，只抓取访问主机192.168.4.5
	的21端口的数据通信 ，并转换为ASCII码格式的易读文本

	**监控选项如下：
	// -i，指定监控的网络接口（默认监听第一个网卡）
	// -A，转换为 ACSII 码，以方便阅读
	// -w，将数据包信息保存到指定文件
	// -r，从指定文件读取数据包信息
	//tcpdump的过滤条件：
	// 类型：host、net、port、portrange
	// 方向：src、dst
	// 协议：tcp、udp、ip、wlan、arp、……
	// 多个条件组合：and、or、not

	执行FTP访问，并观察tcpdump抓包结果
	从192.168.4.100访问主机192.168.4.5的vsftpd服务。
	yum -y install ftp
	ftp 192.168.4.5

	# tcpdump  -A  -w  ftp.cap  \
	> host 192.168.4.5  and  tcp  port 21  //抓包并保存
	再次使用tcpdump抓包，使用-w选项可以将抓取的数据包另存为文件，
	方便后期慢慢分析。
	# tcpdump  -A  -r  ftp.cap | egrep  '(USER|PASS)'  
				  //分析数据包
	tcpdump命令的-r选项，可以去读之前抓取的历史数据文件

	
	：扩展知识，使用tcpdump分析Nginx的明文账户认证信息信息
	# vim /usr/local/nginx/conf/nginx.conf
	auth_basic "xx";
	auth_basic_user_file "/usr/local/nignx/pass";
	# htpasswd -c /usr/local/nginx/pass jerry   //创建账户文件
	# nginx -s reload
	# tcpdump  -A  host 192.168.4.5  and  tcp  port  80

	在真实机使用浏览器访问192.168.4.5
	# firefox  http://192.168.4.5   //根据提示输入用户名与密码
	回到proxy查看抓包的数据结果
	# tcpdump -A host 192.168.4.5 and tcp port 80
	Authorization: Basic dG9tOjEyMzQ1Ng
	
	查看base64编码内容
	# echo "dG9tOjEyMzQ1Ng==" | base64 -d
	# echo "tom:123456" | base64 


*** #md5sum file?.txt
	#gpg --version
	# gpg --gen-key
	gpg --list-keys
	gpg -a --export tommy >tommy.pub
	gpg --import /tmp/a.pub
	gpg --verify log.tar.sig  log.tar
	aide --init
	aide --check
	nmap -...
	tcpdump -.. .



******  
	md5 校验工具  md5sum
	GnuPG  加解密工具 gpg --version
	AIDE 入侵监测系统  aide
	NMAP 扫描分析工具  nmap
	tcpdump 网络抓包工具 tcpdump 




33333333333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333333
33333333333333333333333333333333333333333333333333333333333333




audit 审计工具  每个公司都有审计工具，不一定是audit

jumpserver  国产的，开原图形 audit




./configure
make
make install

status

tcp/ip 簇[http]

ARPNET   全世界的第一个网，军队  --放弃，->学院继续研究 tcp/ip [企业]

GET   请求指定的页面信息
POST  向指定资源提交数据进行处理请求（上传）
实际生产用，其他的全拒绝   GET HEAD POST DELETE PUT ..

autindex on;
server_tokens off;

LVM  快照

mysql   .bash_history    .mysql_history



：部署audit监控文件
# yum -y  install  audit                //安装软件包
# cat /etc/audit/auditd.conf            //查看配置文件，确定日志位置
log_file = /var/log/audit/audit.log                //日志文件路径
# systemctl start auditd                //启动服务
# systemctl enable auditd            //设置开机自启
# auditctl  -s                        //查询状态
# auditctl  -l                        //查看规则
# auditctl  -D                        //删除所有规则
定义临时文件系统规则：
#语法格式：auditctl  -w  path  -p  permission  -k  key_name
# path为需要审计的文件或目录
# 权限可以是r,w,x,a(文件或目录的属性发生变化)
# Key_name为可选项，方便识别哪些规则生成特定的日志项
# auditctl  -w  /etc/passwd  -p wa  -k  passwd_change
//设置规则所有对passwd文件的写、属性修改操作都会被记录审计日志
 # auditctl  -w  /etc/selinux/  -p wa  -k  selinux_change
//设置规则，监控/etc/selinux目录
 # auditctl  -w  /usr/sbin/fdisk  -p x  -k  disk_partition
//设置规则，监控fdisk程序
# auditclt  -w  /etc/ssh/sshd_conf  -p warx  -k  sshd_config
//设置规则，监控sshd_conf文件
如果需要创建永久审计规则，则需要修改规则配置文件：
# vim  /etc/audit/rules.d/audit.rules
-w /etc/passwd -p wa -k passwd_changes
-w /usr/sbin/fdisk -p x -k partition_disks
查看audit日志信息：
# tailf  /var/log/audit/audit.lo
#内容分析
# type为类型
# msg为(time_stamp:ID)，时间是date +%s（1970-1-1至今的秒数）
# arch=c000003e，代表x86_64（16进制）
# success=yes/no，事件是否成功
# a0-a3是程序调用时前4个参数，16进制编码了
# ppid父进程ID，如bash，pid进程ID，如cat命令
# auid是审核用户的id，su - test, 依然可以追踪su前的账户
# uid，gid用户与组
# tty:从哪个终端执行的命令
# comm="cat"            用户在命令行执行的指令
# exe="/bin/cat"        实际程序的路径
# key="sshd_config"    管理员定义的策略关键字key
# type=CWD        用来记录当前工作目录
# cwd="/home/username"
# type=PATH
# ouid(owner's user id）    对象所有者id
# guid(owner's groupid）    对象所有者id
# ausearch -k sshd_config -i    
//根据key搜索日志，-i选项表示以交互式方式操作
默认该程序会搜索/var/log/audit/audit.log，ausearch options -if file_name可以指定文件名。

2：加固常见服务的安全

优化Nginx服务的安全配置
优化MySQL数据库的安全配置
优化Tomcat的安全配置

Nginx安全优化包括：删除不要的模块、修改版本信息、限制并发、拒绝非法请求、防止buffer溢出。
MySQL安全优化包括：初始化安全脚本、密码安全、备份与还原、数据安全。
Tomcat安全优化包括：隐藏版本信息、降权启动、删除默认测试页面.

# ./configure \
>--without-http_autoindex_module \            //禁用自动索引文件目录模块
>--without-http_ssi_module

# vim /usr/local/nginx/conf/nginx.conf
… …
http{
     server_tokens off;                            //在http下面手动添加这么一行
     … …
}
# nginx -s reload
# curl -I http://192.168.4.5          //查看服务器响应的头部信息


但服务器还是显示了使用的软件为nginx，通过如下方法可以修改该信息。
# vim +48 src/http/ngx_http_header_filter_module.c
//注意：vim这条命令必须在nginx-1.12源码包目录下执行！！！！！！
//该文件修改前效果如下：
static u_char ngx_http_server_string[] = "Server: nginx" CRLF;
static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;
//下面是我们修改后的效果：
static u_char ngx_http_server_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_full_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_build_string[] = "Server: Jacob" CRLF;
//修改完成后，再去编译安装Nignx，版本信息将不再显示为Nginx，而是Jacob
[root@proxy nginx-1.12]# ./configure
[root@proxy nginx-1.12]# make && make install
[root@proxy nginx-1.12]# killall nginx
[root@proxy nginx-1.12]# /usr/local/nginx/sbin/nginx            //启动服务
[root@proxy nginx-1.12]# curl -I http://192.168.4.5            //查看版本信息验证


3） 限制并发量
DDOS攻击者会发送大量的并发连接，占用服务器资源（包括连接数、带宽等），这样会导致正常用户处于等待或无法访问服务器的状态。
Nginx提供了一个ngx_http_limit_req_module模块，可以有效降低DDOS攻击的风险，操作方法如下：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        listen 80;
        server_name localhost;
        limit_req zone=one burst=5;
            }
}
//备注说明：
//limit_req_zone语法格式如下：
//limit_req_zone key zone=name:size rate=rate;
//上面案例中是将客户端IP信息存储名称为one的共享内存，内存空间为10M
//1M可以存储8千个IP信息，10M可以存储8万个主机连接的状态，容量可以根据需要任意调整
//每秒中仅接受1个请求，多余的放入漏斗
//漏斗超过5个则报错
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
客户端使用ab测试软件测试效果：
[root@client ~]# ab -c 100 -n 100  http://192.168.4.5/



4） 拒绝非法的请求
网站使用的是HTTP协议，该协议中定义了很多方法，可以让用户连接服务器，获得需要的资源。但实际应用中一般仅需要get和post。
具体HTTP请求方法的含义如表-1所示。
表-1 HTTP请求方法及含义
￼
未修改服务器配置前，客户端使用不同请求方法测试：
[root@client ~]# curl -i -X GET  http://192.168.4.5            //正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            //正常
//curl命令选项说明：
//-i选项：访问服务器页面时，显示HTTP的头部信息
//-X选项：指定请求服务器的方法
通过如下设置可以让Nginx拒绝非法的请求方法：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
       server {
                 listen 80;
#这里，!符号表示对正则取反，~符号是正则匹配符号
#如果用户使用非GET或POST方法访问网站，则retrun返回444的错误信息
              if ($request_method !~ ^(GET|POST)$ ) {
                     return 444;
               }    
        }
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
修改服务器配置后，客户端使用不同请求方法测试：
[root@client ~]# curl -i -X GET  http://192.168.4.5            //正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            //报错




4） 防止buffer溢出
当客户端连接服务器时，服务器会启用各种缓存，用来存放连接的状态信息。
如果攻击者发送大量的连接请求，而服务器不对缓存做限制的话，内存数据就有可能溢出（空间不足）。
修改Nginx配置文件，调整各种buffer参数，可以有效降低溢出风险。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
client_body_buffer_size  1K;
client_header_buffer_size 1k;
client_max_body_size 1k;
large_client_header_buffers 2 1k;
 … …
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
步骤二：数据库安全

1） 初始化安全脚本
安装完MariaDB或MySQL后，默认root没有密码，并且提供了一个任何人都可以操作的test测试数据库。有一个名称为mysql_secure_installation的脚本，该脚本可以帮助我们为root设置密码，并禁止root从远程其他主机登陆数据库，并删除测试性数据库test。
[root@proxy ~]# systemctl status mariadb
//确保服务已启动 
[root@proxy ~]# mysql_secure_installation
//执行初始化安全脚本
2）密码安全
手动修改MariaDB或MySQL数据库密码的方法：
[root@proxy ~]# mysqladmin -uroot -predhat password 'mysql'
//修改密码，旧密码为redhat，新密码为mysql
[root@proxy ~]# mysql -uroot -pmysql
MariaDB [(none)]>set password for root@'localhost'=password('redhat');
//使用账户登录数据库，修改密码
MariaDB [(none)]> select user,host,password from mysql.user;
+--------+---------+---------------------------------------------+
| user     | host     | password                                       |
+--------+---------+---------------------------------------------+
| root     | localhost     | *84BB5DF4823DA319BBF86C99624479A198E6EEE9 |
| root     | 127.0.0.1     | *84BB5DF4823DA319BBF86C99624479A198E6EEE9 |
| root     | ::1           | *84BB5DF4823DA319BBF86C99624479A198E6EEE9 |
+--------+-----------+--------------------------------------------+
修改密码成功，而且密码在数据库中是加密的，有什么问题吗？问题是你的密码被明文记录了，下面来看看明文密码：
[root@proxy ~]# cat .bash_history
mysqladmin -uroot -pxxx password 'redhat'
//通过命令行修改的密码，bash会自动记录历史，历史记录中记录了明文密码
[root@proxy ~]# cat .mysql_history 
set password for root@'localhost'=password('redhat');
select user,host,password from mysql.user;
flush privileges;
//通过mysql命令修改的密码，mysql也会有所有操作指令的记录，这里也记录了明文密码
另外数据库还有一个binlog日志里也有明文密码（5.6版本后修复了）。
怎么解决？
管理好自己的历史，不使用明文登录，选择合适的版本5.6以后的版本，
日志，行为审计（找到行为人），使用防火墙从TCP层设置ACL（禁止外网接触数据库）。
3）数据备份与还原
首先，备份数据库（注意用户名为root，密码为redhat）：
[root@proxy ~]# mysqldump -uroot -predhat mydb table > table.sql
//备份数据库中的某个数据表
[root@proxy ~]# mysqldump -uroot -predhat mydb > mydb.sql
//备份某个数据库
[root@proxy ~]# mysqldump -uroot -predhat --all-databases > all.sql
//备份所有数据库
接下来，还原数据库（注意用户名为root，密码为redhat）：
[root@proxy ~]# mysql -uroot -predhat mydb  < table.sql            //还原数据表
[root@proxy ~]# mysql -uroot -predhat mydb  < mydb.sql            //还原数据库
[root@proxy ~]# mysql -uroot -predhat < all.sql                    //还原所有数据库
4）数据安全
在服务器上（192.168.4.5），创建一个数据库账户：
[root@proxy ~]# mysql -uroot -predhat
//使用管理员，登陆数据库
MariaDB [(none)]> grant all on *.* to tom@'%' identified by '123';
//创建一个新账户tom
使用tcpdump抓包（192.168.4.5）
[root@proxy ~]# tcpdump -w log -i any src or dst port 3306
//抓取源或目标端口是3306的数据包，保存到log文件中
客户端（192.168.4.100）从远程登陆数据库服务器（192.168.4.5）
[root@client ~]# mysql -utom -p123 -h 192.168.4.5
//在192.168.4.100这台主机使用mysql命令登陆远程数据库服务器（192.168.4.5）
//用户名为tom，密码为123
MariaDB [(none)]> select * from mysql.user;
//登陆数据库后，任意执行一条查询语句
回到服务器查看抓取的数据包
[root@proxy ~]# tcpdump -A -r log
//使用tcpdump查看之前抓取的数据包，很多数据库的数据都明文显示出来
如何解决？
可以使用SSH远程连接服务器后，再从本地登陆数据库（避免在网络中传输数据，因为网络环境中不知道有没有抓包者）。
或者也可以使用SSL对MySQL服务器进行加密，类似与HTTP+SSL一样，MySQL也支持SSL加密（确保网络中传输的数据是被加密的）。
步骤三：Tomcat安全性

1） 隐藏版本信息、修改tomcat主配置文件（隐藏版本信息）
未修改版本信息前，使用命令查看服务器的版本信息
注意：proxy有192.168.2.5的IP地址，这里使用proxy作为客户端访问192.168.2.100服务器。
[root@proxy ~]# curl -I http://192.168.2.100:8080/xx        
//访问不存在的页面文件，查看头部信息
[root@proxy ~]# curl -I http://192.168.2.100:8080    
//访问存在的页面文件，查看头部信息
[root@proxy ~]# curl http://192.168.2.100:8080/xx
//访问不存在的页面文件，查看错误信息
修改tomcat配置文件，修改版本信息(在192.168.2.100操作)：
[root@web1 tomcat]# yum -y install java-1.8.0-openjdk-devel
[root@web1 tomcat]# cd /usr/local/tomcat/lib/
[root@web1 lib]# jar -xf catalina.jar
[root@web1 lib]# vim org/apache/catalina/util/ServerInfo.properties 
//根据自己的需要，修改版本信息的内容
[root@web1 lib]# /usr/local/tomcat/bin/shutdown.sh        //关闭服务
[root@web1 lib]# /usr/local/tomcat/bin/startup.sh        //启动服务
修改后，客户端再次查看版本信息（在192.168.2.5操作）：
[root@proxy ~]# curl -I http://192.168.2.100:8080/xx        
//访问不存在的页面文件，查看头部信息
[root@proxy ~]# curl -I http://192.168.2.100:8080    
//访问存在的页面文件，查看头部信息
[root@proxy ~]# curl http://192.168.2.100:8080/xx
//访问不存在的页面文件，查看错误信息
再次修改tomcat服务器配置文件，修改版本信息，手动添加server参数（在192.168.2.100操作）：
[root@web1 lib]# vim /usr/local/tomcat/conf/server.xml
<Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"  redirectPort="8443" server="jacob" />
[root@web1 lib]# /usr/local/tomcat/bin/shutdown.sh        //关闭服务
[root@web1 lib]# /usr/local/tomcat/bin/startup.sh        //启动服务
修改后,客户端再次查看版本信息（在192.168.2.5操作）：
[root@proxy ~]# curl -I http://192.168.2.100:8080/xx        
//访问不存在的页面文件，查看头部信息
[root@proxy ~]# curl -I http://192.168.2.100:8080    
//访问存在的页面文件，查看头部信息
[root@proxy ~]# curl http://192.168.2.100:8080/xx
//访问不存在的页面文件，查看错误信息
2）降级启动
默认tomcat使用系统高级管理员账户root启动服务，启动服务尽量使用普通用户。
[root@web1 ~]# useradd tomcat
[root@web1 ~]# chown -R tomcat:tomcat /usr/local/tomcat/
//修改tomcat目录的权限，让tomcat账户对该目录有操作权限
[root@web1 ~]# su -c /usr/local/tomcat/bin/startup.sh tomcat
//使用su命令切换为tomcat账户，以tomcat账户的身份启动tomcat服务
[root@web1 ~]# chmod +x /etc/rc.local                //该文件为开机启动文件
[root@web1 ~]# vim /etc/rc.local                     //修改文件，添加如下内容
su -c /usr/local/tomcat/bin/startup.sh tomcat
3）删除默认的测试页面
[root@web1 ~]# rm -rf  /usr/local/tomcat/webapps/*
3 案例3：使用diff和patch工具打补丁
3.1 问题

本案例要求优化提升常见网络服务的安全性，主要完成以下任务操作：
使用diff对比文件差异
使用diff生成补丁文件
使用patch命令为旧版本打补丁
3.2 方案

程序是人设计出来的，总是会有这样那样的问题与漏洞，目前的主流解决方法就是为有问题的程序打补丁，升级新版本。
在Linux系统中diff命令可以为我们生成补丁文件，然后使用patch命令为有问题的程序代码打补丁。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：对比单个文件差异

1） 编写两个版本的脚本，一个为v1版本，一个为v2版本。
[root@proxy ~]# cat test1.sh                                //v1版本脚本
#!/bin/bash
echo "hello wrld"
[root@proxy ~]# cat test2.sh                                //v2版本脚本
#!/bin/bash
echo "hello the world"
echo "test file"
2） 使用diff命令语法
使用diff命令查看不同版本文件的差异。
[root@proxy ~]# diff  test1.sh test2.sh                     //查看文件差异
@@ -1,3 +1,3 @@
 #!/bin/bash
-echo "hello world"
-echo "test"
+echo "hello the world"
+echo "test file"
[root@proxy ~]# diff -u test1.sh test2.sh                 //查看差异，包含头部信息
--- test1.sh    2018-02-07 22:20:02.723971251 +0800
+++ test2.sh    2018-02-07 22:20:13.358760687 +0800
@@ -1,3 +1,3 @@
 #!/bin/bash
-echo "hello world"
-echo "test"
+echo "hello the world"
+echo "test file"
diff制作补丁文件的原理：告诉我们怎么修改第一个文件后能得到第二个文件。
这样如果第一个版本的脚本有漏洞，我们不需要将整个脚本都替换，仅需要修改有问题的一小部分代码即可，diff刚好可以满足这个需求！
像Linux内核这样的大块头，一旦发现有一个小漏洞，我们不可能把整个内核都重新下载，全部替换一遍，而仅需要更新有问题的那一小部分代码即可！
diff命令常用选项：
-u	输出统一内容的头部信息（打补丁使用），计算机知道是哪个文件需要修改
-r	递归对比目录中的所有资源（可以对比目录）
-a	所有文件视为文本（包括二进制程序）
-N	无文件视为空文件（空文件怎么变成第二个文件）
-N选项备注说明：
A目录下没有txt文件，B目录下有txt文件
diff比较两个目录时，默认会提示txt仅在B目录有（无法对比差异，修复文件）
diff比较时使用N选项，则diff会拿B下的txt与A下的空文件对比，补丁信息会明确说明如何从空文件修改后变成txt文件，打补丁即可成功！
步骤二：使用patch命令对单文件代码打补丁

1）准备实验环境
[root@proxy ~]# cd demo
[root@proxy demo]# vim test1.sh
#!/bin/bash
echo "hello world"
echo "test"
[root@proxy demo]# vim test2.sh 
#!/bin/bash
echo "hello the world"
echo "test file"
2) 生成补丁文件
[root@proxy demo]# diff -u test1.sh test2.sh > test.patch
3）使用patch命令打补丁
在代码相同目录下为代码打补丁
[root@proxy demo]# yum -y install patch
[root@proxy demo]# patch -p0 < test.patch                    //打补丁
patching file test1.sh
//patch -pnum（其中num为数字，指定删除补丁文件中多少层路径前缀）
//如原始路径为/u/howard/src/blurfl/blurfl.c
//-p0则整个路径不变
//-p1则修改路径为u/howard/src/blurfl/blurfl.c
//-p4则修改路径为blurfl/blurfl.c
//-R(reverse)反向修复，-E修复后如果文件为空，则删除该文件
[root@proxy demo]# patch -RE < test.patch                     //还原旧版本，反向修复
步骤三：对比目录中所有文件的差异

1） 准备实验环境
[root@proxy ~]# mkdir demo
[root@proxy ~]# cd demo
[root@proxy demo]# mkdir {source1,source2}
[root@proxy demo]# echo "hello world"       > source1/test.sh
[root@proxy demo]# cp /bin/find source1/
[root@proxy demo]#  tree source1/                        //source1目录下2个文件
|-- find
`-- test.sh
[root@proxy demo]# echo "hello the world"  > source2/test.sh
[root@proxy demo]# echo "test" > source2/tmp.txt
[root@proxy demo]# cp /bin/find source2/
[root@proxy demo]# echo "1" >> source2/find 
[root@proxy demo]#  tree source2/                        //source1目录下3个文件
|-- find
|-- test.sh
`-- tmp.txt
//注意：两个目录下find和test.sh文件内容不同，source2有tmp.txt而source1没有该文件
2）制作补丁文件
[root@proxy demo]# diff -u source1/ source2/
//仅对比了文本文件test.sh；二进制文件、tmp都没有对比差异，仅提示，因为没有-a和-N选项
[root@proxy demo]# diff -Nu source1/ source2/
//对比了test.sh，并且使用source2目录的tmp.txt与source1的空文件对比差异。
[root@proxy demo]# diff -Nua source1/ source2/
//对比了test.sh、tmp.txt、find(程序)。
步骤四：使用patch命令对目录下的所有代码打补丁

1）使用前面创建的source1和source2目录下的代码为素材，生成补丁文件

root@proxy ~]# cd demo
[root@proxy demo]# diff -Nuar source1/ source2/ > source.patch
2）使用patch命令为代码打补丁
[root@proxy demo]# ls
source1  source2  source.patch
[root@proxy demo]# cat source.patch                //对比的文件有路径信息
--- source1/test.sh 2018-02-07 22:51:33.034879417 +0800
+++ source2/test.sh 2018-02-07 22:47:32.531754268 +0800
@@ -1 +1 @@
-hello world
+hello the world
[root@proxy demo]# cd source1
[root@proxy source1]# patch  -p1 < ../source.patch





***   auditctl -s  -l  - ..
	ausearch -k sshd_config -i
	mysqldump -u root -p123 --all-databases >all.sql
	mydql -uroot -p123 <all.sql   还原所有
	tcpdump -w log -i any src or dst port 3306
	mysql -utom -p123 -h 192.168.4.5
	tcpdump -A -r log
	diff test1.sh test2.sh
	diff -u test1.sh test2.sh >test.patch
	patch -p0 <test.patch
	patch -RE <test.patch




******audit  监控文件 审计
	常见服务的安全    优化   nginx   mysql  tomcat
	diff  和patch 工具打补丁

	





44444444444444444444444444444444444444444444444444444444444444444
444444444444444444444444444444444444444444444444444444444444444444
44444444444444444444444444444444444444444444444444444444444444444



RHEL7默认是使用firewalld作为防火墙
但是之前底层用的是--包过滤防火墙 iptables  .现在大多数企业用的都是这个

	yum -y install iptables-services 
		#记得要装包，否则配置也可以做。但是关机后所有的配置就都没了
	#traceroute www.sina.com  #访问外网地址经过了多少跳


***全部背下来
	iptables  四表五链  
	4表  nat    filter   raw   mangle
	5链  INPUT  OUTPUT  FORWARD  PREROUTING  POSTROUTING
	选项  -A -I     -L -n --line-numbers    -D -F   -P 	
	通用匹配  -p  -s,-d  -i,-o    --sport,--dport 
						 --icmp-type ICMP 类型	

	iptables [-t 表名] 选项 [链名] [条件] [-j 目标操作 ]
	#iptables -t filter -I INPUT -p icmp -j REJECT  #例子
	
	#iptables -p icmp --help

	扩张：# iptables  -A  INPUT  -p tcp --dport 22\
	> -m   mac --mac-source  52:54:00:00:00:0b  -j  DROP

	 -m iprange --src-range ..   -m multiport --dports ..


	SYN      SYN,ACK
	request   reply  
	#iptables -A INPUT -p icmp --icmp-type echo-request 
	-j  DROP

	SNAT 源地址转换
	# iptables  -t  nat  -A POSTROUTING  -s  192.168.4.0/24
	 -p tcp --dport 80  -j SNAT  --to-source 192.168.2.5

	#service iptables save  #永久保存所有iptables 规则


案例1：iptables基本管理
案例2：filter过滤和转发控制
案例3：防火墙扩展规则
案例4：配置SNAT实现共享上网
1 案例1：iptables基本管理
1.1 问题

本案例要求练习iptables命令的使用，按照要求完成以下任务：
关闭firewalld，开启iptables服务
查看防火墙规则
追加、插入防火墙规则
删除、清空防火墙规则
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：关闭firewalld，启动iptables服务

1）关闭firewalld服务器
[root@proxy ~]# systemctl stop firewalld.service 
[root@proxy ~]# systemctl disable firewalld.service
2）安装iptables-services并启动服务
[root@proxy ~]# yum -y install iptables-services
[root@proxy ~]# systemctl start iptables.service
步骤二：熟悉iptables框架

1）iptables的4个表（区分大小写）：
iptables默认有4个表，nat表（地址转换表）、filter表（数据过滤表）、raw表（状态跟踪表）、mangle表（包标记表）。
2）iptables的5个链（区分大小写）：
INPUT链（入站规则）
OUTPUT链（出站规则）
FORWARD链（转发规则）
PREROUTING链（路由前规则）
POSTROUTING链（路由后规则）
步骤三：iptables命令的基本使用方法
	#添加规则 -A 追加一条防火墙规则至链的末尾位置
		  -I 插入一条防火墙规则至链的开头
	查看规则   -L   查看iptables 所有规则
		  -n  以数字形式显示地址、端口等信息
		  --line-numbers 查看规则时，显示规则的行号
	删除规则   -D  删除链内指定序号（或内容）的一条规则
		  -F 清空所有的规则
	默认规则   -P  为指定的链设置默认规则

1）iptabels语法格式
[root@proxy ~]# iptables  [-t 表名]  选项  [链名]  [条件]  [-j 目标操作]
[root@proxy ~]# iptables  -t  filter  -I  INPUT -p  icmp  -j  REJECT
[root@proxy ~]# iptables -t filter -I  INPUT   -p  icmp  -j  ACCEPT
[root@proxy ~]# iptables  -I  INPUT  -p  icmp  -j  REJECT
//注意事项与规律：
//可以不指定表，默认为filter表
//可以不指定链，默认为对应表的所有链
//如果没有找到匹配条件，则执行防火墙默认规则
//选项/链名/目标操作用大写字母，其余都小写
########################################################################
//目标操作：
// ACCEPT：允许通过/放行
// DROP：直接丢弃，不给出任何回应
// REJECT：拒绝通过，必要时会给出提示
// LOG：记录日志，然后传给下一条规则
iptables命令的常用选项如表-1所示。
表-1 iptables常用选项
￼
2）iptables命令的使用案例
创建规则的案例：
[root@proxy ~]# iptables  -t  filter  -A  INPUT  -p tcp  -j  ACCEPT
//追加规则至filter表中的INPUT链的末尾，允许任何人使用TCP协议访问本机
[root@proxy ~]# iptables  -I  INPUT  -p  udp  -j  ACCEPT
//插入规则至filter表中的INPUT链的开头，允许任何人使用UDP协议访问本机
[root@proxy ~]# iptables  -I  INPUT 2  -p  icmp  -j  ACCEPT
//插入规则至filter表中的INPUT链的第2行，允许任何人使用ICMP协议访问本机
查看iptables防火墙规则
[root@proxy ~]# iptables  -nL  INPUT                    //仅查看INPUT链的规则
target     prot opt source               destination
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0
[root@proxy ~]# iptables  -L  INPUT  --line-numbers        //查看规则，显示行号
num  target     prot opt source         destination
1    ACCEPT     udp   --  anywhere     anywhere
2    ACCEPT     icmp --   anywhere     anywhere
3    ACCEPT     tcp  --   anywhere     anywhere
删除规则，清空所有规则
[root@proxy ~]# iptables  -D  INPUT  3
//删除filter表中INPUT链的第3条规则
[root@proxy ~]# iptables  -nL  INPUT                //查看规则，确认是否删除
[root@proxy ~]# iptables  -F
//清空filter表中所有链的防火墙规则
[root@proxy ~]# iptables  -t  nat  -F
//清空nat表中所有链的防火墙规则
[root@proxy ~]# iptables  -t  mangle  -F
//清空mangle表中所有链的防火墙规则
[root@proxy ~]# iptables  -t  raw  -F
//清空raw表中所有链的防火墙规则
设置防火墙默认规则
[root@proxy ~]# iptables  -t  filter  -P  INPUT  DROP
[root@proxy ~]# iptables  -nL
Chain INPUT (policy DROP)
… …
2 案例2：filter过滤和转发控制
2.1 问题

本案例要求创建常用主机防火墙规则以及网络防火墙规则：
针对Linux主机进行出站、入站控制
利用ip_forward机制实现Linux路由/网关功能
在Linux网关上实现数据包转发访问控制
2.2 方案

根据防火墙保护的对象不同，防火墙可以分为主机型防火墙与网络型防火墙，如图-1所示。
主机型防火墙，主要保护的是服务器本机（过滤威胁本机的数据包）。
网络防火墙，主要保护的是防火墙后面的其他服务器，如web服务器、FTP服务器等。
￼
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：iptables防火墙规则的条件

iptables防火墙可以根据很多很灵活的规则进行过滤行为，具体常用的过滤条件如表-2所示。
表-2 iptables过滤条件
	*通用匹配 协议匹配  -p 协议名称
		   地址匹配  -s 源地址，-d 目标地址
		   接口匹配  -i  接受数据的网卡、-o 发送数据的网卡
	 隐含匹配  端口匹配 --sport 源端口号  、--dport 目标端口号
		   ICMP 类型匹配  --icmp-type  ICMP 类型
￼
1）主机型防火墙案例
[root@proxy ~]# iptables -I INPUT -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables -I INPUT -s 192.168.2.100 -j REJECT
[root@proxy ~]# iptables -I INPUT -d 192.168.2.5 -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables -I INPUT -i eth0 -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables  -A  INPUT  -s 192.168.4.100  -j  DROP
//丢弃192.168.4.100发给本机的所有数据包
[root@proxy ~]# iptables  -A  INPUT -s  192.168.2.0/24  -j  DROP
//丢弃192.168.2.0/24网络中所有主机发送给本机的所有数据包
[root@proxy ~]# iptables -A  INPUT -s  114.212.33.12  -p tcp --dport 22 -j  REJECT
//拒绝114.212.33.12使用tcp协议远程连接本机ssh（22端口）
步骤二：开启Linux的路由转发功能

1）Linux内核默认支持软路由功能，通过修改内核参数即可开启或关闭路由转发功能。
[root@proxy ~]# echo 0 > /proc/sys/net/ipv4/ip_forward            //关闭路由转发
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward            //开启路由转发
//注意以上操作仅当前有效，计算机重启后无效
[root@proxy ~]# echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
//修改/etc/sysctl.conf配置文件，可以实现永久有效规则
步骤四：网络型防火墙案例
	client eth0:192.168.4.100
		网关: 192.168.4.5
	proxy  eth0 :192.168.4.5
		 eth1 :192.168.2.5
	web1  eth1 :192.168.2.100
		网关 : 192.168.2.5

1）网络型防火墙案例
部署如表-3所示的网络拓扑，一定要把proxy主机的路由转发功能打开。
表-3 实验拓扑
￼
添加网关的命令
[root@client ~]# nmcli connection modify eth0 ipv4.gateway 192.168.4.5
[root@client ~]# nmcli connection up eth0
[root@web1 ~]# nmcli connection modify eth1 ipv4.gateway 192.168.2.5
[root@web1 ~]# nmcli connection up eth1
确认不同网络的联通性
[root@client ~]# ping 192.168.2.100
[root@web1 ~]# ping 192.168.4.100
在web1主机上启动http服务
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "test page" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
没有防火墙的情况下client访问web服务
[root@client ~]# curl http://192.168.2.100                    //成功
设置proxy主机的防火墙规则，保护防火墙后面的Web服务器
[root@proxy ~]# iptables -I FORWARD -s 192.168.4.100 -p tcp --dport 80 -j DROP
设置完防火墙规则后，再次使用client客户端访问测试效果
[root@client ~]# curl http://192.168.2.100                    //失败
步骤三：禁ping的相关策略

1）默认直接禁ping的问题？
[root@proxy ~]# iptables -I INPUT -p icmp -j DROP
//设置完上面的规则后，其他主机确实无法ping本机，但本机也无法ping其他主机
//当本机ping其他主机，其他主机回应也是使用icmp，对方的回应被丢弃
2）禁止其他主机ping本机，允许本机ping其他主机
[root@proxy ~]# iptables  -A  INPUT  -p icmp  \
> --icmp-type echo-request  -j  DROP
//仅禁止入站的ping请求，不拒绝入站的ping回应包
注意：关于ICMP的类型，可以参考help帮助，参考命令如下：
[root@proxy ~]# iptables -p icmp --help
3 案例3：防火墙扩展规则
3.1 问题

本案例要求熟悉使用iptables的扩展规则，实现更丰富的过滤功能，完成以下任务：
根据MAC地址封锁主机
在一条规则中开放多个TCP服务
根据IP范围设置封锁规则
3.2 方案

iptables在基本过滤条件的基础上还扩展了很多其他条件，在使用时需要使用-m参数来启动这些扩展功能，语法如下：
iptables 选项 链名称 -m 扩展模块 --具体扩展条件 -j 动作
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：根据MAC地址过滤

1）根据IP过滤的规则，当对方修改IP后，防火墙会失效
[root@proxy ~]# iptables -F
[root@proxy ~]# iptables -I INPUT -s 192.168.4.100 -p tcp --dport 22 -j DROP
//设置规则禁止192.168.4.100使用ssh远程本机
但是，当client主机修改IP地址后，该规则就会失效，注意因为修改了IP，对client主机的远程连接会断开，需要使用virt-manager开启虚拟机操作：
[root@client ~]# ifconfig eth0  192.168.4.101
[root@client ~]# ssh 192.168.4.5                    //依然成功
根据MAC地址过滤，可以防止这种情况的发生
[root@client ~]# ip link show eth0                    //查看client的MAC地址
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff
[root@proxy ~]# iptables  -A  INPUT  -p tcp --dport 22\
> -m   mac --mac-source  52:54:00:00:00:0b  -j  DROP
//拒绝52:54:00:00:00:0b这台主机远程本机
步骤二：基于多端口设置过滤规则

1）一次需要过滤或放行很多端口时会比较方便
[root@proxy ~]# iptables  -A  INPUT  -p tcp   \
> -m  multiport --dports  20:22,25,80,110,143,16501:16800  -j  ACCEPT
//一次性开启20,21,22,25,80,110,143,16501到16800所有的端口
提示，多端口还可以限制多个源端口，但因为源端口不固定，一般不会使用，限制多个源端口的参数是--sports.
步骤三：根据IP地址范围设置规则

1）允许从 192.168.4.10-192.168.4.20 登录
[root@proxy ~]# iptables  -A  INPUT  -p tcp  --dport  22  \
> -m  iprange  --src-range  192.168.4.10-192.168.4.20   -j  ACCEPT
注意，这里也可以限制多个目标IP的范围，参数是--dst-range,用法与--src-range一致。
2）禁止从 192.168.4.0/24 网段其他的主机登录
[root@proxy ~]# iptables -A INPUT -p tcp --dport 22  -s 192.168.4.0/24  -j  DROP
4 案例4：配置SNAT实现共享上网
4.1 问题

本案例要求设置防火墙规则，允许位于局域网中的主机可以访问外网，主要包括下列服务：
搭建内外网案例环境
配置SNAT策略实现共享上网访问
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：搭建内外网案例环境

表-4 实验拓扑
￼
这里，我们设定192.168.2.0/24网络为外部网络，192.168.4.0/24为内部网络。
现在，在外部网络中有一台web服务器192.168.2.100，因为设置了网关，client已经可以访问此web服务器了。但，如果查看web1的日志就会发现，日志里记录的是192.168.4.100在访问网页。
我们需要实现的效果是，client可以访问web服务器，但要伪装为192.168.2.5后再访问web服务器(模拟所有位于公司内部的电脑都使用的是私有IP，希望访问外网，就需要伪装为公司的外网IP后才可以)。
步骤二：设置防火墙规则，实现IP地址的伪装（SNAT源地址转换）

1）确保proxy主机开启了路由转发功能
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward            //开启路由转发
2）设置防火墙规则，实现SNAT地址转换
[root@proxy ~]# iptables  -t  nat  -A POSTROUTING \
> -s  192.168.4.0/24 -p tcp --dport 80  -j SNAT  --to-source 192.168.2.5
3）登陆web主机查看日志
[root@proxy ~]# tail  /var/log/httpd/access_log
.. ..
192.168.2.5 - - [12/Aug/2018:17:57:10 +0800] "GET / HTTP/1.1" 200 27 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
通过日志会发现，客户端是先伪装为了192.168.2.5之后再访问的web服务器！
4）扩展知识，对于proxy外网IP不固定的情况可以执行下面的地址伪装，动态伪装IP。
[root@proxy ~]# iptables  -t  nat  -A POSTROUTING \
> -s  192.168.4.0/24 -p tcp --dport 80 -j MASQUERADE
最后，所有iptables规则都是临时规则，如果需要永久保留规则需要执行如下命令:
[root@proxy ~]# service  iptables save





55555555555555555555555555555555555555555555555555555555555555555555
5555555555555555555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555555555555555555555555555555555555


·Zabbix  基于多种监控机制，支持分布式监控     学
		 Cacti   Nagios   等，好多监控软件 


*** ps  uptime  free   swapon -s    df -h    ifconfig
      netstat,ss   ping  traceroute    iostat
***  部署监控服务器	
	fastcgi_buffers 8 16k;    //缓存php生成的页面内容，8个16k
    fastcgi_buffer_size 32k;     //缓存php生产的头部信息
    fastcgi_connect_timeout 300;  //连接PHP的超时时间
    fastcgi_send_timeout 300;   //发送请求的超时时间
    fastcgi_read_timeout 300;     //读取请求的超时时间
	
	]# yum -y install  net-snmp-devel  curl-devel 
	libevent-devel   
	./configure  --enable-server \
> --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config \
> --with-net-snmp --with-libcurl

	grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';
	 mysql -uzabbix -pzabbix zabbix < schema.sql

	
	# vim /usr/local/etc/zabbix_server.conf
		# zabbix_server        //启动服务
	# vim /usr/local/etc/zabbix_agentd.conf
		# zabbix_agentd    //启动监控agent

根据错误提示，修改PHP配置文件，满足Zabbix_server的Web环境要求
php-bcmath和php-mbstring都在lnmp_soft目录下有提供软件包。
	php-gd  php-xml   php-bcmatc  php-mbstring
	# vim /etc/php.ini
	  # systemctl restart php-fpm
	
*** 被监控 主机




Top
NSD SECURITY DAY05

案例1：常用系统监控命令
案例2：部署Zabbix监控平台
案例3：配置及使用Zabbix监控系统
案例4：自定义Zabbix监控项目
1 案例1：常用系统监控命令
1.1 问题

本案例要求熟悉查看Linux系统状态的常用命令，为进一步执行具体的监控任务做准备：
查看内存信息
查看交换分区信息
查看磁盘信息
查看CPU信息
查看网卡信息
查看端口信息
查看网络连接信息
1.2 方案

一般企业做监控的目的：实时报告系统状态，提前发现系统的问题。
监控的资源可以分为：共有数据（HTTP、FTP等）和私有数据（CPU、内存、进程数等）。
监控软件可以使用：系统自带的命令、Cacti监控系统、Nagios监控系统、Zabbix监控系统。
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用命令查看计算机状态数据

1）查看内存与交换分区信息
[root@proxy ~]# free        //查看内存信息
              total        used        free      shared  buff/cache   available
Mem:       16166888     8017696      720016      106504     7429176     7731740
Swap:       4194300      218268     3976032
[root@proxy ~]# free | awk '/Mem/{print $4}'   //查看剩余内存容量
720928
[root@proxy ~]# swapon -s   //查看交换分区信息
文件名                类型            大小        已用        权限
/dev/sda3             partition        4194300    218268    -1
步骤二：查看磁盘与CPU利用率

1）查看磁盘信息
[root@proxy ~]# df     //查看所有磁盘的使用率
文件系统           1K-块      已用      可用         已用% 挂载点
/dev/sda2      476254208 116879624 335159084   26%         /
/dev/sda1         198174    133897     49737   73%         /boot
[root@proxy ~]# df | awk '/\/$/{print $5}'  //查看根分区的利用率
2）查看CPU平均负载
[root@proxy ~]# uptime  //查看CPU负载（1，5，15分钟）
 23:54:12 up 38 days, 14:54,  9 users,  load average: 0.00, 0.04, 0.05
[root@proxy ~]# uptime |awk '{print $NF}'//仅查看CPU的15分钟平均负载
0.05
步骤二：查看网卡信息、端口信息、网络连接信息

1）查看网卡信息
[root@proxy ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.5  netmask 255.255.255.0  broadcast 172.25.0.255
        inet6 fe80::5054:ff:fe00:b  prefixlen 64  scopeid 0x20<link>
        ether 52:54:00:00:00:0b  txqueuelen 1000  (Ethernet)
        RX packets 62429  bytes 10612049 (10.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 5674  bytes 4121143 (3.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
[root@proxy ~]# ifconfig eth0 |awk '/inet /{print $2}'   //查看IP地址信息
192.168.4.5
[root@proxy ~]# ifconfig eth0 |awk '/RX p/{print $5}'  //网卡接受数据包流量
10625295
[root@proxy ~]# ifconfig eth0 |awk '/TX p/{print $5}'   //网卡发送数据包流量
4130821
2）查看端口信息
[root@proxy ~]# ss -ntulp  //查看本机监听的所有端口
//-n以数字显示端口号
//-t显示tcp连接
//-u显示udp连接
//-p显示监听端口对应的程序名称
3）查看网络连接信息
[root@proxy ~]# ss -antup   //查看所有的网络连接信息
//-a查看所有连接状态信息
2 案例2：部署Zabbix监控平台
2.1 问题

本案例要求部署一台Zabbix监控服务器，一台被监控主机，为进一步执行具体的监控任务做准备：
安装LNMP环境
源码安装Zabbix
安装监控端主机，修改基本配置
初始化Zabbix监控Web页面
修改PHP配置文件，满足Zabbix需求
安装被监控端主机，修改基本配置
2.2 方案

使用1台RHEL7虚拟机，安装部署LNMP环境、Zabbix及相关的依赖包，配置数据库并对Zabbix监控平台进行初始化操作。使用2台被监控端，源码安装Zabbix Agent。完成Zabbix实验需要我们搭建一个实验环境，拓扑结构如表-1所示。
表-1 实验拓扑结构

2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署监控服务器

1）安装LNMP环境
Zabbix监控管理控制台需要通过Web页面展示出来，并且还需要使用MySQL来存储数据，因此需要先为Zabbix准备基础LNMP环境。
[root@zabbixserver ~]# yum -y install gcc pcre-devel  openssl-devel
[root@zabbixserver ~]# tar -xf nginx-1.12.2.tar.gz
[root@zabbixserver ~]# cd nginx-1.12.2
[root@zabbixserver nginx-1.12.2]# ./configure --with-http_ssl_module
[root@zabbixserver nginx-1.12.2]# make && make install
[root@zabbixserver ~]# yum -y install php php-mysql \
> mariadb mariadb-devel mariadb-server
[root@zabbixserver ~]# yum -y  install  php-fpm-5.4.16-42.el7.x86_64.rpm
//注意，php-fpm这个软件包在lnmp_soft/目录下
2）修改Nginx配置文件
配置Nginx支持PHP动态网站，因为有大量PHP脚本需要执行，因此还需要开启Nginx的各种fastcgi缓存，加速PHP脚本的执行速度。
[root@zabbixserver ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
    fastcgi_buffers 8 16k;   //缓存php生成的页面内容，8个16k
    fastcgi_buffer_size 32k;   //缓存php生产的头部信息
    fastcgi_connect_timeout 300;   //连接PHP的超时时间
    fastcgi_send_timeout 300;     //发送请求的超时时间
    fastcgi_read_timeout 300;    //读取请求的超时时间
location ~ \.php$ {
                root           html;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
                include        fastcgi.conf;
        }
… …
3）启动服务
启动Nginx、PHP-FPM、MariaDB服务，关闭SELinux与防火墙。
[root@zabbixserver ~]# systemctl start  mariadb
[root@zabbixserver ~]# systemctl start  php-fpm
[root@zabbixserver ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/nginx
[root@zabbixserver ~]# nginx
[root@zabbixserver ~]# firewall-cmd --set-default-zone=trusted
[root@zabbixserver ~]# setenforce 0
4）客户端测试LNMP环境
服务器创建PHP测试页面，浏览器访问页面测试网页连通性。
[root@zabbixserver ~]# cat /usr/local/nginx/html/test.php
<?php
$i=33;
echo $i;
?>
[root@zabbixserver ~]# curl http://192.168.2.5/test.php
步骤二：部署监控服务器Zabbix Server

1）源码安装Zabbix Server
多数源码包都是需要依赖包的，zabbix也一样，源码编译前需要先安装相关依赖包。
[root@zabbixserver lnmp_soft]# yum -y install  net-snmp-devel \
> curl-devel 
//安装相关依赖包
[root@zabbixserver lnmp_soft]# yum -y install  \
> libevent-devel-2.0.21-4.el7.x86_64.rpm
//注意libevent-devel这个软件包在lnmp_soft目录下有提供
[root@zabbixserver lnmp_soft]# tar -xf zabbix-3.4.4.tar.gz
[root@zabbixserver lnmp_soft]# cd zabbix-3.4.4/
[root@zabbixserver zabbix-3.4.4]# ./configure  --enable-server \
> --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config \
> --with-net-snmp --with-libcurl
// --enable-server安装部署zabbix服务器端软件
// --enable-agent安装部署zabbix被监控端软件
// --enable-proxy安装部署zabbix代理相关软件
// --with-mysql配置mysql_config路径
// --with-net-snmp允许zabbix通过snmp协议监控其他设备
// --with-libcurl安装相关curl库文件，这样zabbix就可以通过curl连接http等服务，测试被监控主机服务的状态
[root@zabbixserver zabbix-3.4.4]# make && make install
2）初始化Zabbix
创建数据库，上线Zabbix的Web页面
[root@zabbixserver ~]# mysql
mysql> create database zabbix character set utf8;
//创建数据库，支持中文字符集
mysql> grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';
//创建可以访问数据库的账户与密码
[root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/database/mysql/
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < schema.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < images.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < data.sql
//刚刚创建是空数据库，zabbix源码包目录下，有提前准备好的数据
//使用mysql导入这些数据即可（注意导入顺序）
上线Zabbix的Web页面
[root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/frontends/php/
[root@zabbixserver php]# cp -r * /usr/local/nginx/html/
[root@zabbixserver php]# chmod -R 777 /usr/local/nginx/html/*
修改Zabbix_server配置文件，设置数据库相关参数，启动Zabbix_server服务
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_server.conf
DBHost=localhost
//数据库主机，默认该行被注释
DBName=zabbix
//设置数据库名称
DBUser=zabbix
//设置数据库账户
DBPassword=zabbix
//设置数据库密码，默认该行被注释
LogFile=/tmp/zabbix_server.log    
//设置日志，仅查看以下即可
[root@zabbixserver ~]# useradd -s /sbin/nologin zabbix
//不创建用户无法启动服务
[root@zabbixserver ~]# zabbix_server    //启动服务
[root@zabbixserver ~]# ss -ntulp |grep zabbix_server   //确认连接状态，端口10051
tcp LISTEN 0 128 *:10051 *:* users:(("zabbix_server",pid=23275,fd=4),("zabbix_server",pid=23274,fd=4)
提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_server，
一定要先使用killall zabbix_server关闭服务后，再重新启动一次。
修改Zabbix_agent配置文件，启动Zabbix_agent服务
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5       //允许哪些主机监控本机
ServerActive=127.0.0.1,192.168.2.5  //允许哪些主机通过主动模式监控本机
Hostname=zabbix_server         //设置本机主机名
LogFile=/tmp/zabbix_server.log        //设置日志文件
UnsafeUserParameters=1           //是否允许自定义key
[root@zabbixserver ~]# zabbix_agentd     //启动监控agent
[root@zabbixserver ~]# ss -ntulp |grep zabbix_agentd   //查看端口信息为10050
tcp    LISTEN     0      128       *:10050                 *:*                   users:(("zabbix_agentd",pid=23505,fd=4),("zabbix_agentd",pid=23504,fd=4)
提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_agentd，
一定要先使用killall zabbix_agentd关闭服务后，再重新启动一次。
浏览器访问Zabbix_server服务器的Web页面
[root@zabbixserver ~]# firefox http://192.168.2.5/index.php
//第一次访问，初始化PHP页面会检查计算机环境是否满足要求，如果不满足会给出修改建议
//默认会提示PHP的配置不满足环境要求，需要修改PHP配置文件
根据错误提示，修改PHP配置文件，满足Zabbix_server的Web环境要求
php-bcmath和php-mbstring都在lnmp_soft目录下有提供软件包。
[root@zabbixserver ~]# yum -y install  php-gd php-xml
[root@zabbixserver ~]# yum install php-bcmath-5.4.16-42.el7.x86_64.rpm  
[root@zabbixserver ~]# yum install php-mbstring-5.4.16-42.el7.x86_64.rpm
[root@zabbixserver ~]# vim /etc/php.ini
date.timezone = Asia/Shanghai     //设置时区
max_execution_time = 300      //最大执行时间，秒
post_max_size = 32M           //POST数据最大容量
max_input_time = 300      //服务器接收数据的时间限制
memory_limit = 128M        //内存容量限制
[root@zabbixserver ~]# systemctl restart php-fpm
修改完PHP配置文件后，再次使用浏览器访问服务器，则会提示如图-1和图-2所示的提示信息。

图-1

图-2
注意：这里有一个PHP LDAP是warning状态是没有问题的！
在初始化数据库页面，填写数据库相关参数，如图-3所示。

图-3
在登陆页面，使用用户(admin)和密码(zabbix)登陆，登陆后设置语言环境为中文，如图-4和图-5所示。

图-4

图-5
步骤三：部署被监控主机Zabbix Agent

1）源码安装Zabbix agent软件
在2.100和2.200做相同操作（以zabbixclient_web1为例）。
[root@zabbixclient_web1 ~]# useradd -s /sbin/nologin  zabbix
[root@zabbixclient_web1 ~]# yum -y install gcc pcre-devel
[root@zabbixclient_web1 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@zabbixclient_web1 ~]# cd zabbix-3.4.4/
[root@zabbixclient_web1 zabbix-3.4.4]# ./configure --enable-agent
[root@zabbixclient_web1 zabbix-3.4.4]# make && make install 
2）修改agent配置文件，启动Agent
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5    //谁可以监控本机（被动监控模式）
ServerActive=127.0.0.1,192.168.2.5  //谁可以监控本机（主动监控模式）
Hostname=zabbixclient_web1     //被监控端自己的主机名
EnableRemoteCommands=1    
//监控异常后，是否允许服务器远程过来执行命令，如重启某个服务
UnsafeUserParameters=1          //是否允许自定义key监控
[root@zabbixclient_web1 ~]# zabbix_agentd    //启动agent服务
3）拷贝启动脚本（非必须操作，可选做），有启动脚本可以方便管理服务，启动与关闭服务。启动脚本位于zabbix源码目录下。
[root@zabbixclient_web1 zabbix-3.4.4]# cd misc/init.d/fedora/core
[root@zabbixclient_web1 zabbix-3.4.4]# cp zabbix_agentd /etc/init.d/
[root@zabbixclient_web1 zabbix-3.4.4]# /etc/init.d/zabbix_agentd start
[root@zabbixclient_web1 zabbix-3.4.4]# /etc/init.d/zabbix_agentd stop
[root@zabbixclient_web1 zabbix-3.4.4]# /etc/init.d/zabbix_agentd status
[root@zabbixclient_web1 zabbix-3.4.4]# /etc/init.d/zabbix_agentd restart
3 案例3：配置及使用Zabbix监控系统
3.1 问题

沿用练习一，使用Zabbix监控平台监控Linux服务器，实现以下目标：
监控CPU
监控内存
监控进程
监控网络流量
监控硬盘
3.2 方案

通过Zabbix监控平台，添加被监控zabbixclient_web1主机（192.168.2.100）并链接监控模板即可，Zabbix默认模板就可以监控CPU、内存、进程、网络、磁盘等项目。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：添加监控主机

主机是Zabbix监控的基础，Zabbix所有监控都是基于Host主机。
使用火狐浏览器登录http://192.168.2.5，通过Configuration（配置）-->Hosts（主机）-->Create Host（创建主机）添加被监控Linux主机，如图-7所示。

图-7
添加被监控主机时，需要根据提示输入被监控Linux主机的主机名称（最好与电脑的主机名一致，但也允许不一致）、主机组、IP地址等参数，具体参考图-8所示。

图-8
步骤二：为被监控主机添加监控模板

Zabbix通过监控模板来对监控对象实施具体的监控功能，根据模板来定义需要监控哪些数据，对于Linux服务器的监控，Zabbix已经内置了相关的模板（Template OS Linux），选择模板并链接到主机即可，如图-9所示。

图-9
步骤三：查看监控数据

查看监控数据，登录Zabbix Web控制台，点击Monitoring(监控中)—> Latest data(最新数据)，正过滤器中填写过滤条件，根据监控组和监控主机选择需要查看哪些监控数据，如图-10所示。

图-10
找到需要监控的数据后，可以点击后面的Graph查看监控图形，如图-11所示。

图-11
4 案例4：自定义Zabbix监控项目
4.1 问题

沿用练习二，使用Zabbix实现自定义监控，实现以下目标：监控Linux服务器系统账户的数量。
4.2 方案

需要使用Zabbix自定义key的方式实现自定义监控，参考如下操作步骤：
创建自定义key
创建监控项目
创建监控图形
将监控模板关联到主机
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：被监控主机创建自定义key（在192.168.2.100操作）

1）创建自定义key
自定义key语法格式为：UserParameter=自定义key名称,命令。
自定义的key文件一般存储在/usr/local/etc/zabbix_agentd.conf.d/目录，这里还需要修改zabbix_agentd.conf文件，允许自定义监控key，来读取该目录下的所有文件 。
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Include=/usr/local/etc/zabbix_agentd.conf.d/                //加载配置文件目录
[root@zabbixclient_web1 ~]# cd /usr/local/etc/zabbix_agentd.conf.d/
[root@zabbixclient_web1 zabbix_agentd.conf.d]# vim count.line.passwd
UserParameter=count.line.passwd,wc -l /etc/passwd | awk ' {print $1} '
////自定义key语法格式:
//UserParameter=自定义key名称,命令
2）测试自定义key是否正常工作
[root@zabbixclient_web1 ~]# killall  zabbix_agentd
[root@zabbixclient_web1 ~]# zabbix_agentd                                //重启agent服务
[root@zabbixclient_web1 ~]# zabbix_get -s 127.0.0.1 -k count.line.passwd
21
注意：如zabbix_get命令执行错误，提示Check access restrictions in Zabbix agent configuration，则需要检查agent配置文件是否正确：
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5
ServerActive=127.0.0.1,192.168.2.5
步骤二：创建监控模板

模板、应用集与监控项目的关系图，参考图-12所示

图-12
1）添加监控模板
登录Zabbix Web监控控制台，通过Configuration(配置)-->Template(模板)-->Create template(创建模板)，填写模板名称，新建模板群组，如图-13所示。

图-13
创建模板后，默认模板中没有任何应用、项目、触发器、图形等，如图-14所示。

图-14
2）创建应用
创建完成模板后，默认模板中没有任何应用、项目、触发器、图形等资源。这里需要点击模板后面的Application（应用集）链接打开创建应用的页面，如图-15所示。

图-15
点击Application（应用集）后，会刷新出图-16所示页面，在该页面中点击Create application（创建应用集）按钮。

图-16
设置应用名称如图-17所示。

图-17
3）创建监控项目item（监控项）
与创建应用一样，在模板中还需要创建监控项目，如图-18所示，并在刷新出的新页面中选择Create items（创建监控项）创建项目，如图-19所示。

图-18

图-19
接下来，还需要给项目设置名称及对应的自定义key，如图-20所示。

图-20
4）创建图形
为了后期可以通过图形的方式展示监控数据，还需要在模板中创建图形，设置方法与前面的步骤一致，在监控模板后面点击Graph（图形）即可创建图形，设置监控图形基于什么监控数据，如图-21所示。

图-21
5）将模板链接到被监控主机
将完整的监控模板制作完成后，就可以将模板链接到主机实现监控功能了。首先找到被监控主机Configuration（配置）-->Hosts（主机），如图-22所示。

图-22
点击需要的被监控主机链接，打开监控主机设置页面，在Template（模板）页面中选择需要链接到该主机的模板，在此选择刚刚创建的模板count_line.passwd添加即可，如图-23所示。

图-23
6）查看监控数据图形
点击Monitoring（监控中）-->Craphs（图形），根据需要选择条件，查看监控图形，如图-24和图-25所示。


图-25





6666666666666666666666666666666666666666666666666666666666666666666
666666666666666666666666666666666666666666666666666666666666666666666
6666666666666666666666666666666666666666666666666666666666666666666666





****zabbix 报警
	trigger 触发器     action  动作
	expression 触发器表达式
	zabbix 自动发现 （discovery
	zabbix 主动监控 
	vim /usr/local/etc/zabbix_agentd.conf
	拓扑图与聚合图形
	自定义监控 nginx ，status
	UserParameter=ping[*],echo $1
	vim /usr/local/etc/zabbix_agentd.conf.d/*
	vim /usr/local/bin/nginx_status.sh
	zabbix_get -s 127.0.0.1 -k 'nginx.status.sh[active]'
	
	TCP 三次握手，四次断开
	ab -c 1000 -n 100000 http://192.168.2.100/
	ss -antup
	vim /usr/local/bin/net_status.sh
	zabbix_get -s 127.0.0.1  -k 'net.status[time_wait]'
	监控netstatus




Top
NSD SECURITY DAY06

案例1：实现Zabbix报警功能
案例2：Zabbix自动发现
案例3：Zabbix主动监控
案例4：拓扑图与聚合图形
案例5：自定义监控案例
1 案例1：实现Zabbix报警功能
1.1 问题

沿用第5天Zabbix练习，使用Zabbix实现报警功能，实现以下目标：
监控Linux服务器系统账户
创建Media，设置邮件服务器及收件人邮箱
当系统账户数量超过26人时发送报警邮件
1.2 方案

自定义的监控项默认不会自动报警，首页也不会提示错误，需要配置触发器与报警动作才可以自定报警。
什么是触发器（trigger）？
表达式，如内存不足300M，用户超过30个等
当出发条件发生后，会导致一个触发事件
触发事件会执行某个动作
什么是动作（action）？
动作是触发器的条件被触发后所执行的行为
可以是发送邮件、也可以是重启某个服务等
参考如下操作步骤：
创建触发器并设置标记
设置邮箱
创建Action动作
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建触发器规则

1）创建触发器
创建触发器时强烈建议使用英文的语言环境，通过Configuration--> Templates，找到我们之前创建的count.line.passwd模板，点击模板后面的triggers，如图-1所示。

图-1
2）触发器表达式
创建触发器时需要定义表达式，触发器表达式（Expression）是触发异常的条件，触发器表达式格式如下：
{<server>:<key>.<function>(<parameter>)}<operator><constant>
{主机：key.函数(参数)}<表达式>常数
在如图-2所示的蓝色方框中编写触发器表达式，可以直接手写，也可以通过add选择表达式模板。

图-2
下面，我们看几个表达式的案例：
{web1:system.cpu.load[all,avg1].last(0)}>5	//0为最新数据
如果web1主机最新的CPU平均负载值大于5，则触发器状态Problem
{vfs.fs.size[/,free].max(5m)}<10G	//5m为最近5分钟
根分区，最近5分钟的最大容量小于10G，则状态进入Problem
{vfs.file.cksum[/etc/passwd].diff(0)}>0	//0为最新数据
最新一次校验/etc/passwd如果与上一次有变化，则状态进入Problem
大多数函数使用秒作为参数，可以使用#来表示其他含义（具体参考表-1）。
avg, count, last, min and max 等函数支持额外的第二个参数time_shift（时间偏移量），这个参数允许从过去一段时间内引用数据。
3）配置触发器
设置触发器名称，如图-3所示，点击add添加表达式，填写表达式：监控项为账户数量，最近300秒账户数量大于26（根据系统账户数量实际填写），效果如图-4所示。

图-3

图-4
选择触发器报警级别，如图-5所示，Add创建该触发器，如图-6所示。

图-5

图-6
步骤二：设置邮件

1）创建Media
通过Administration（管理）-->Media Type（报警媒体类型）-->选择Email（邮件），如图-7所示。

图-7
设置邮件服务器信息，设置邮件服务器及邮件账户信息，如图-8所示。

图-8
2)为用户添加Media
在Administration（管理）-->Users（用户）中找到选择admin账户，如图-9所示。

图-9
点击Admin账户后，在弹出的界面中选择Media（报警媒介）菜单-->点击Add(添加)报警媒介，如图-10所示。

图-10
点击Add（添加）后，在Meida Type中填写报警类型，收件人，时间等信息，如图-11所示。

图-11
步骤三：创建Action动作

1）Action动作
Action（动作）是定义当触发器被触发时的时候，执行什么行为。
通过Configuration（配置）-->Actions（动作）-->Create action（创建动作），如图-12所示。

图-12
2）配置Action动作的触发条件
填写Action动作的名称，配置什么触发器被触发时会执行本Action动作（账户数量大于26），如图-13所示。

图-13
3）配置Action动作的具体行为
配置动作的具体操作行为（发送信息或执行远程命令），无限次数发送邮件，60秒1次，发送给Admin用户，如图-14和图-15所示。

图-14

图-15
4）测试效果
在被监控主机创建账户（让账户数量大于26），然后登录监控端Web页面，在仪表盘中查看问题报警（需要等待一段时间），如图-16所示。

图-16
查看报警邮件，在监控服务器上使用mail命令查收报警邮件，如图-17所示。

图-17
2 案例2：Zabbix自动发现
2.1 问题

沿用前面的练习，配置Zabbix的自动发现机制，实现以下目标：
创建自动发现规则
创建自动发现后的动作，添加主机、为主机链接模板
2.2 方案

什么是自动发现（Discovery）？
当Zabbix需要监控的设备越来越多，手动添加监控设备越来越有挑战，此时，可以考虑使用自动发现功能，自动添加被监控主机，实现自动批量添加一组监控主机功能。
自动发现可以实现：
自动发现、添加主机，自动添加主机到组；
自动连接模板到主机，自动创建监控项目与图形等。
自动发现（Discovery）流程：
创建自动发现规则
创建Action动作，说明发现主机后自动执行什么动作
通过动作，执行添加主机，链接模板到主机等操作
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：自动发现规则

1）创建自动发现规则
通过Configuration（配置）-->Discovery（自动发现）-->Create discovery rule（创建发现规则），如图-18所示。

图-18
2）填写规则
填写自动发现的IP范围（逗号隔开可以写多个），多久做一次自动发现（默认为1小时，仅实验修改为1m），如图-19所示。配置检查的方式：HTTP、FTP、Agent的自定义key等检查，如图-20所示。

图-19

图-20
步骤二：创建动作

1）创建Action动作
通过Configuration（配置）--> Actions Event source(事件源)：自动发现(Discovery)-->Create action（创建动作），如图-21所示。

图-21
2）配置Action动作具体行为
配置动作，添加动作名称，添加触发动作的条件，如图-22所示。

图-22
点击操作（触发动作后要执行的操作指令），操作细节：添加主机到组，与模板链接（HTTP模板），如图-23所示。

图-23
步骤二：添加新的虚拟机

1）创建新的虚拟机
创建一台新的主机，验证zabbix是否可以自动发现该主机，可以重新部署一台新的虚拟机（注意前面的课程，我们已经创建了虚拟机zabbixclient_web2，并且已经安装部署了Zabbix agent，如果没有该虚拟机或没有安装Agent，则需要前在zabbixclient_web2部署Agent），也可以将旧虚拟机的IP地址，临时修改为其他IP。
2）验证结果
登陆Zabbix服务器的Web页面，查看主机列表，确认新添加的主机是否被自动加入监控主机列表，是否自动绑定了监控模板。
3 案例3：Zabbix主动监控
3.1 问题

沿用前面的练习，配置Zabbix主动监控，实现以下目标：
修改被监控主机agent为主动监控模式
克隆模板，修改模板为主动监控模板
添加监控主机，并链接主动监控模板
3.2 方案

默认zabbix采用的是被动监控，主动和被动都是对被监控端主机而言的！
被动监控：Server向Agent发起连接，发送监控key，Agent接受请求，响应监控数据。
主动监控：Agent向Server发起连接，Agent请求需要检测的监控项目列表，Server响应Agent发送一个items列表，Agent确认收到监控列表，TCP连接完成，会话关闭，Agent开始周期性地收集数据。
区别：Server不用每次需要数据都连接Agent，Agent会自己收集数据并处理数据，Server仅需要保存数据即可。
当监控主机达到一定量级后，Zabbix服务器会越来越慢，此时，可以考虑使用主动监控，释放服务器的压力。
另外，Zabbix也支持分布式监控，也是可以考虑的方案。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：添加被监控主机

1）为被监控主机安装部署zabbix agent
注意：前面的实验，我们已经在zabbixclient_web2主机安装部署了zabbix agent，如果已经完成，则如下操作可以忽略。
[root@zabbixclient_web2 ~]# yum -y install gcc pcre-devel
[root@zabbixclient_web2 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@zabbixclient_web2 ~]# cd zabbix-3.4.4/
[root@zabbixclient_web2 ~]#./configure --enable-agent
[root@zabbixclient_web2 ~]# make && make install
2）修改agent配置文件
将agent监控模式修改为主动模式。
[root@zabbixclient_web2 ~]# vim /usr/local/etc/zabbix_agentd.conf 
#Server=127.0.0.1,192.168.2.5
//注释该行，允许谁监控本机
StartAgents=0            
//被动监控时启动多个进程
//设置为0，则禁止被动监控，不启动zabbix_agentd服务
ServerActive=192.168.2.5
//允许哪些主机监控本机（主动模式），一定要取消127.0.0.1
Hostname=zabbixclient_web2
//告诉监控服务器，是谁发的数据信息
//一定要和zabbix服务器配置的监控主机名称一致（后面设置）
RefreshActiveChecks=120
//默认120秒检测一次
UnsafeUserParameters=1            
//允许自定义key
Include=/usr/local/etc/zabbix_agentd.conf.d/
[root@zabbixclient_web2 ~]# killall zabbix_agentd                    //关闭服务
[root@zabbixclient_web2 ~]# zabbix_agentd                            //启动服务
步骤二：创建主动监控的监控模板

1）克隆Zabbix自动的监控模板
为了方便，克隆系统自带模板（在此基础上就该更方便）。
通过Configuration（配置）-->Templates（模板）-->选择Template OS Linux
-->全克隆，克隆该模板，新建一个新的模板。如图-24所示。
新模板名称为：Template OS Linux ServerActive。

图-24
2）修改模板中的监控项目的监控模式
将模板中的所有监控项目全部修改为主动监控模式，通过Configuration（配置）-->Templates（模板）-->选择新克隆的模板，点击后面的Items（监控项）-->点击全选，选择所有监控项目，点击批量更新，将类型修改为：Zabbix Agent（Active主动模式），如图-25所示。

图-25
3）禁用部分监控项目
批量修改监控项的监控模式后，并非所有监控项目都支持主动模式，批量修改后，会发现有几个没有修改主动模式成功，说明，这些监控项目不支持主动模式，关闭即可。
可以点击类型排序，方便操作，点击状态即可关闭。如图-26所示。

图-26
步骤三：添加监控主机

1）手动添加监控主机（主动模式监控）
在Zabbix监控服务器，添加被监控的主机（主动模式），设置主机名称：zabbixclient_web2	（必须与被监控端的配置文件Hostname一致），将主机添加到Linux servers组，IP地址修改为0.0.0.0，端口设置为0，如图-27和图-28所示。

图-27

图-28
为主机添加监控模板，选择刚刚创建的模板（主动模式），添加链接模板到主机，如图-29所示。

图-29
2）验证监控效果
查看数据图表，通过Monitoring-->Graphs菜单，选择需要查看的主机组、主机以及图形，查看效果，如图-30所示。

图-30
CPU、内存等其他数据可用正常获取，但是，查看分区图表时并无数据，因为分区数据采用的是自动发现监控，与普通监控项一样，修改为主动模式即可，选择Template OS Linux ServerActive模板，修改Discovery自动发现为主动模式。如图-31所示。

图-31
4 案例4：拓扑图与聚合图形
4.1 问题

沿用前面的练习，熟悉zabbix拓扑图与聚合图形，实现以下目标：
创建修改拓扑图
创建聚合图形
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建拓扑图

1）创建拓扑
绘制拓扑图可以快速了解服务器架构，通过Monitoring（监控中）-->Maps（拓扑图），选择默认的Local network拓扑图，编辑即可（也可以新建一个拓扑图），如图-32所示。

图-32
2）拓扑图图表说明
Icon（图标），添加新的设备后可以点击图标修改属性
Shape（形状）
Link（连线），先选择两个图标，再选择连线
完成后，点击Update（更新）
创建完拓扑图，效果如图-33所示。

图-33
步骤二：创建聚合图形

1）创建聚合图形
聚合图形可以在一个页面显示多个数据图表，方便了解多组数据。
通过Monitoring（监控中）-->Screens（聚合图形）-->Create screen(创建聚合图形)即可创建聚合图形，如图-34所示。

图-34
修改聚合图形参数如下：
Owner：使用默认的Admin用户
Name：名称设置为zabbixclient_web2_host
Columns：列数设置为2列
Rows：行数设置为4行
2）为聚合图形中添加监控图形
选择刚刚创建的聚合图形（zabbixclient_web2_host)，点击后面的构造函数（constructor），点击Change(更改)，设置每行每列需要显示的数据图表，如图-35所示。

图-35
5 案例5：自定义监控案例
5.1 问题

沿用前面的练习，使用自定义key监控常用监控项目，实现以下目标：
监控Nginx状态
监控网络连接状态
5.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：监控Nginx服务状态

1）准备环境，部署nginx软件
安装nginx软件，开启status模块
[root@zabbixclient_web1 nginx-1.12.2]# ./configure \
> --with-http_stub_status_module 
[root@zabbixclient_web1 nginx-1.12.2]# make && make install
[root@zabbixclient_web1 ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
        }
… …
[root@zabbixclient_web1 ~]# curl  http://192.168.2.100/status
Active connections: 1 
server accepts handled requests
10 10 3 
Reading: 0 Writing: 1 Waiting: 0
2）自定义监控key
语法格式：
UserParameter=key,command
UserParameter=key[*],<command>
key里的所有参数，都会传递给后面命令的位置变量
如：
UserParameter=ping[*],echo $1
ping[0]，	返回的结果都是0
ping[aaa]，	返回的结果都是aaa
注意：被监控端修改配置文件，注意要允许自定义key并设置Include！
创建自定义key
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf.d/nginx.status
UserParameter=nginx.status[*],/usr/local/bin/nginx_status.sh $1
[root@zabbixclient_web1 ~]# killall zabbix_agentd
[root@zabbixclient_web1 ~]# zabbix_agentd
自定义监控脚本（仅供参考，未检测完整状态）
[root@zabbixclient_web1 ~]# vim /usr/local/bin/nginx_status.sh
#!/bin/bash
case $1 in
active)
    curl -s http://192.168.2.100/status |awk '/Active/{print $NF}';;
waiting)
    curl -s http://192.168.2.100/status |awk '/Waiting/{print $NF}';;
accepts)
    curl -s http://192.168.2.100/status |awk 'NR==3{print $2}';;
esac
[root@zabbixclient_web1 ~]# chmod +x  /usr/local/bin/nginx_status.sh
测试效果：
[root@zabbixclient_web1 ~]# zabbix_get  -s 127.0.0.1 \
 -k 'nginx.status[accepts]'
登陆Zabbix监控Web，创建监控项目item，点击Configuration（配置）-->Hosts(主机)，点击主机后面的items（项目），点击Create item（创建项目）。修改项目参数如图-36所示。

图-36
步骤二：监控网络连接状态

1）了解TCP协议
熟悉TCP三次握手，参考图-37。

图-37
熟悉TCP连接的四次断开，参考图-38。

图-38
2）查看网络连接状态
模拟多人并发连接
[root@zabbixclient_web1 ~]# ab -c 1000 -n 100000 http://192.168.2.100/
查看网络连接状态，仔细观察、分析第二列的数据
[root@zabbixclient_web1 ~]# ss -antup
//-a显示所有
//-t显示TCP连接状态
//-u显示UDP连接状态
//-n以数字形式显示端口号和IP地址
//-p显示连接对应的进程名称
3）创建自定义key
注意：被监控端修改配置文件，注意要允许自定义key并设置Include。
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf.d/net.status
UserParameter=net.status[*],/usr/local/bin/net_status.sh $1
[root@zabbixclient_web1 ~]# killall zabbix_agentd
[root@zabbixclient_web1 ~]# zabbix_agentd
自定义监控脚本（仅供参考，未检测完整状态）
[root@zabbixclient_web1 ~]# vim /usr/local/bin/net_status.sh 
#!/bin/bash
case $1 in
estab)
    ss -antp |awk '/^ESTAB/{x++} END{print x}';;
close_wait)
    ss -antp |awk '/^CLOSE-WAIT/{x++} END{print x}';;
time_wait)
    ss -antp |awk '/^TIME-WAIT/{x++} END{print x}';;
esac 
[root@zabbixclient_web1 ~]# chmod +x  /usr/local/bin/net_status.sh
测试效果：
[root@zabbixclient_web1 ~]# zabbix_get  -s 127.0.0.1 \
-k 'net.status[time_wait]'
4) 监控netstatus
在监控服务器，添加监控项目item，Configuration-->Hosts点击主机后面的items
点击Create item，如图-39所示。

图-39




###################################################
##################################################
####################################################






****** chage   账户
	passwd 
	chattr 、lsatter
	su   sudo     visudo =vim /etc/sudoers
	ssh  sshd 黑白名单，远程权限  密钥验证
	ssh-keygen     whoami
	selinux   sestatus   chcon  



******  
	md5 校验工具  md5sum
	GnuPG  加解密工具 gpg --version
	AIDE 入侵监测系统  aide
	NMAP 扫描分析工具  nmap
	tcpdump 网络抓包工具 tcpdump 




******audit  监控文件 审计
	常见服务的安全    优化   nginx   mysql  tomcat
	diff  和patch 工具打补丁



****** iptables  四表五链  
	4表  nat    filter   raw   mangle
	5链  INPUT  OUTPUT  FORWARD  PREROUTING  POSTROUTING
	选项  -A -I     -L -n --line-numbers    -D -F   -P 	
	通用匹配  -p  -s,-d  -i,-o    --sport,--dport 
						 --icmp-type ICMP 类型	
	#service iptables save  #永久保存所有iptables 规则


*** ps  uptime  free   swapon -s    df -h    ifconfig
      netstat,ss   ping  traceroute    iostat
***  部署监控	
	zabbix
	



























&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&







	nginx    /usr/local/nginx/  *    --with-http_ssl_module

	LNMP    php-fpm  /etc/php-fpm.d/www.conf

	HTTP  TCP/UCP  四层   --with-stream    ss  netstat  -antpul

	http {  upstream xxx {  ..

	./configure --help |grep status  
		 --with-http_stub_status_module

	gzip   压缩

	EVENT 模块优化   

	mariadb      memcached  缓存服务器
	/usr/lib/systemd/system/memcached.service
	/etc/sysconfig/memcached

	tailf  /usr/local/nginx/logs/error.log  查看报错信息


	PHP  的 session  /var/lib/php/session


	JDK  java 的核心   tomcat

	java-1.8.0-openjdk     java-1.8.0-openjdk-headless
	java -version

	/usr/local/tomcat/* 

	Varnish  缓存服务器     ？ memcached

	subversion  svn  版本控制系统

	svnsdmin help       svn     git

	mkdir /var/svn
	svnadmin create /var/svn/xxx
	du -sh  xxx  查看空仓库的大小

	/usr/lib/systemd/system   systemctl  可以启动的文件


	nginx  的 RPM包    rpm-build  装包



	VPN  虚拟专用网络   
	 GRE VPN      ， PPTP VPN    ，L2TP+IPSec VPN


	NTP    chrony
	
	pssh  远程套件工具    装包    man pssh
	
	pscp.pssh       pslurp      pnuke





























